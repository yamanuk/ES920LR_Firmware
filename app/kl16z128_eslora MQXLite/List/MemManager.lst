###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         14/May/2020  16:51:00
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\MemManager\Source\MemManager.c
#    Command line      =
#        -f C:\Users\81901\AppData\Local\Temp\EW58FA.tmp
#        (C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\MemManager\Source\MemManager.c
#        --preprocess=s
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -lcN
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -o
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\include\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\config\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\compiler\iar\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Generated_Code\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\PExSupport\Kinetis\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\OSAbstraction\MQXLite\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Common\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\Lists\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\FunctionLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\SecLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Panic\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\SerialManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\MemManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Messaging\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\Phy\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\SMAC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\ADC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\BME\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Flash\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\I2C\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LED\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LLWU\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LPTMR\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\SMC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\MCG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Reset\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List\MemManager.lst
#    Object file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj\MemManager.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\MemManager\Source\MemManager.c
      1          /*!
      2          * Copyright (c) 2014, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file MemManager.c
      6          * This is the source file for the Memory Manager.
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          
     35          /*! *********************************************************************************
     36          *************************************************************************************
     37          * Include
     38          *************************************************************************************
     39          ********************************************************************************** */
     40          #include "EmbeddedTypes.h"
     41          #include "cmsis_os.h"
     42          #include "Panic.h"
     43          #include "MemManager.h"
     44          
     45          /*! *********************************************************************************
     46          *************************************************************************************
     47          * Private memory declarations
     48          *************************************************************************************
     49          ********************************************************************************** */
     50          
     51          #define _block_size_  {
     52          #define _number_of_blocks_  ,
     53          #define _eol_  },
     54          
     55          poolInfo_t poolInfo[] =
     56          {
     57            PoolsDetails_c
     58            {0, 0} /*termination tag*/
     59          };
     60          
     61          #undef _block_size_
     62          #undef _number_of_blocks_
     63          #undef _eol_
     64          
     65          #define _block_size_ (sizeof(listHeader_t)+
     66          #define _number_of_blocks_ ) *
     67          #define _eol_  +
     68          
     69          #define heapSize_c (PoolsDetails_c 0)
     70          
     71          // Heap
     72          uint8_t memHeap[heapSize_c];
     73          const uint32_t heapSize = heapSize_c;
     74          
     75          #undef _block_size_
     76          #undef _number_of_blocks_
     77          #undef _eol_
     78          
     79          #define _block_size_ 0 *
     80          #define _number_of_blocks_ + 0 *
     81          #define _eol_  + 1 +
     82          
     83          #define poolCount (PoolsDetails_c 0)
     84          
     85          // Memory pool info and anchors.
     86          pools_t memPools[poolCount];
     87          
     88          #undef _block_size_
     89          #undef _number_of_blocks_
     90          #undef _eol_
     91          
     92          #ifdef MEM_TRACKING
     93          
     94          #define _block_size_ 0*
     95          #define _number_of_blocks_ +
     96          #define _eol_  +
     97          
     98          #define mTotalNoOfMsgs_d (PoolsDetails_c 0)
     99          static const uint16_t mTotalNoOfMsgs_c = mTotalNoOfMsgs_d;
    100          blockTracking_t memTrack[mTotalNoOfMsgs_d];
    101          
    102          #undef _block_size_
    103          #undef _number_of_blocks_
    104          #undef _eol_
    105          
    106          #endif /*MEM_TRACKING*/
    107          
    108          // Free messages counter. Not used by module.
    109          uint16_t gFreeMessagesCount;
    110          
    111          /*! *********************************************************************************
    112          *************************************************************************************
    113          * Public functions
    114          *************************************************************************************
    115          ********************************************************************************** */
    116          
    117          /*! *********************************************************************************
    118          * \brief   This function initializes the message module private variables.
    119          *          Must be called at boot time, or if device is reset.
    120          *
    121          * \param[in] none
    122          *
    123          * \return MEM_SUCCESS_c if initialization is successful. (It's always successful).
    124          *
    125          ********************************************************************************** */
    126          memStatus_t MEM_Init()
    127          {
    128            poolInfo_t *pPoolInfo = poolInfo; // IN: Memory layout information
    129            pools_t *pPools = memPools;// OUT: Will be initialized with requested memory pools.
    130            uint8_t *pHeap = memHeap;// IN: Memory heap.
    131          
    132            uint8_t poolN;
    133          #ifdef MEM_TRACKING
    134            uint16_t memTrackIndex = 0;
    135          #endif /*MEM_TRACKING*/
    136          
    137            gFreeMessagesCount = 0;
    138          
    139            for(;;)
    140            {
    141              poolN = pPoolInfo->poolSize;
    142              ListInit((listHandle_t)&pPools->anchor, poolN);
    143          #ifdef MEM_STATISTICS
    144              pPools->poolStatistics.numBlocks = 0;
    145              pPools->poolStatistics.allocatedBlocks = 0;
    146              pPools->poolStatistics.allocatedBlocksPeak = 0;
    147              pPools->poolStatistics.allocationFailures = 0;
    148              pPools->poolStatistics.freeFailures = 0;
    149          #ifdef MEM_TRACKING
    150              pPools->poolStatistics.poolFragmentWaste = 0;
    151              pPools->poolStatistics.poolFragmentWastePeak = 0;
    152          #endif /*MEM_TRACKING*/
    153          #endif /*MEM_STATISTICS*/
    154          
    155              while(poolN)
    156              {
    157                // Add block to list of free memory.
    158                ListAddTail((listHandle_t)&pPools->anchor, (listElementHandle_t)&((listHeader_t *)pHeap)->link);
    159                ((listHeader_t *)pHeap)->pParentPool = pPools;
    160          #ifdef MEM_STATISTICS
    161                pPools->poolStatistics.numBlocks++;
    162          #endif /*MEM_STATISTICS*/
    163          
    164                gFreeMessagesCount++;
    165          #ifdef MEM_TRACKING
    166                memTrack[memTrackIndex].blockAddr = (void *)(pHeap + sizeof(listHeader_t));
    167                memTrack[memTrackIndex].blockSize = pPoolInfo->blockSize;
    168                memTrack[memTrackIndex].fragmentWaste = 0;
    169                memTrack[memTrackIndex].allocAddr = NULL;
    170                memTrack[memTrackIndex].allocCounter = 0;
    171                memTrack[memTrackIndex].allocStatus = MEM_TRACKING_FREE_c;
    172                memTrack[memTrackIndex].freeAddr = NULL;
    173                memTrack[memTrackIndex].freeCounter = 0;
    174                memTrackIndex++;
    175          #endif /*MEM_TRACKING*/
    176          
    177                  // Add block size (without list header)
    178                pHeap += pPoolInfo->blockSize + sizeof(listHeader_t);
    179                poolN--;
    180              }
    181          
    182              pPools->blockSize = pPoolInfo->blockSize;
    183              pPools->nextBlockSize = (pPoolInfo+1)->blockSize;
    184              if(pPools->nextBlockSize == 0)
    185              {
    186                break;
    187              }
    188          
    189              pPools++;
    190              pPoolInfo++;
    191            }
    192            return MEM_SUCCESS_c;
    193          }
    194          
    195          /*! *********************************************************************************
    196          * \brief    This function returns the number of available blocks greater or
    197          *           equal to the given size.
    198          *
    199          * \param[in] size - Size of blocks to check for availability.
    200          *
    201          * \return Number of available blocks greater or equal to the given size.
    202          *
    203          * \pre Memory manager must be previously initialized.
    204          *
    205          ********************************************************************************** */
    206          uint32_t MEM_GetAvailableBlocks
    207            (
    208            uint32_t size
    209            )
    210          {
    211            pools_t *pPools = memPools;
    212            uint32_t pTotalCount = 0;
    213          
    214            for(;;)
    215            {
    216              if(size <= pPools->blockSize)
    217              {
    218                pTotalCount += ListGetSize((listHandle_t)&pPools->anchor);
    219              }
    220          
    221              if(pPools->nextBlockSize == 0)
    222              {
    223                break;
    224              }
    225          
    226              pPools++;
    227            }
    228          
    229            return  pTotalCount;
    230          }
    231          
    232          /*! *********************************************************************************
    233          * \brief     Allocate a block from the memory pools. The function uses the
    234          *            numBytes argument to look up a pool with adequate block sizes.
    235          * \param[in] numBytes - Size of buffer to allocate.
    236          *
    237          * \return Pointer to the allocated buffer, NULL if failed.
    238          *
    239          * \pre Memory manager must be previously initialized.
    240          *
    241          ********************************************************************************** */
    242          void* MEM_BufferAlloc
    243            (
    244            uint32_t numBytes // IN: Minimum number of bytes to allocate
    245            )
    246          {
    247          #ifdef MEM_TRACKING
    248          
    249            /* Save the Link Register */
    250            volatile uint32_t savedLR;
    251          //  __asm("str  r14, [SP]");
    252            __asm("push {r2}  ");
    253            __asm("push {LR} ");
    254            __asm("pop  {r2} ");
    255            __asm("str  r2, [SP, #4]");
    256            __asm("pop {r2}");
    257          
    258          #endif /*MEM_TRACKING*/
    259          
    260            pools_t *pPools = memPools;
    261            listHeader_t *pBlock;
    262          
    263          #ifdef MEM_TRACKING
    264            uint16_t requestedSize = numBytes;
    265          #endif /*MEM_TRACKING*/
    266          
    267            osInterruptDisable();
    268          
    269            while(numBytes)
    270            {
    271              if(numBytes <= pPools->blockSize)
    272              {
    273                pBlock = (listHeader_t *)ListRemoveHead((listHandle_t)&pPools->anchor);
    274          
    275                if(NULL != pBlock)
    276                {
    277                  pBlock++;
    278                  gFreeMessagesCount--;
    279          
    280          #ifdef MEM_STATISTICS
    281                  pPools->poolStatistics.allocatedBlocks++;
    282                  if ( pPools->poolStatistics.allocatedBlocks > pPools->poolStatistics.allocatedBlocksPeak )
    283                  {
    284                    pPools->poolStatistics.allocatedBlocksPeak = pPools->poolStatistics.allocatedBlocks;
    285                  }
    286                  MEM_ASSERT(pPools->poolStatistics.allocatedBlocks <= pPools->poolStatistics.numBlocks);
    287          #endif /*MEM_STATISTICS*/
    288          
    289          #ifdef MEM_TRACKING
    290                  MEM_Track(pBlock, MEM_TRACKING_ALLOC_c, savedLR, requestedSize);
    291          #endif /*MEM_TRACKING*/
    292                  osInterruptEnable();
    293                  return pBlock;
    294                }
    295                else
    296                {
    297                  if(numBytes > pPools->nextBlockSize) break;
    298                  // No more blocks of that size, try next size.
    299                  numBytes = pPools->nextBlockSize;
    300                }
    301              }
    302                // Try next pool
    303              if(pPools->nextBlockSize)
    304                pPools++;
    305              else
    306                break;
    307            }
    308          #ifdef MEM_STATISTICS
    309            pPools->poolStatistics.allocationFailures++;
    310          #endif /*MEM_STATISTICS*/
    311          #ifdef MEM_TRACKING
    312            panic( 0, (uint32_t)MEM_BufferAlloc, savedLR, 0);
    313          #else
    314            panic( 0, (uint32_t)MEM_BufferAlloc, 0, 0);
    315          #endif
    316            osInterruptEnable();
    317            return NULL;
    318          }
    319          
    320          /*! *********************************************************************************
    321          * \brief     Deallocate a memory block by putting it in the corresponding pool
    322          *            of free blocks.
    323          *
    324          * \param[in] buffer - Pointer to buffer to deallocate.
    325          *
    326          * \return MEM_SUCCESS_c if deallocation was successful, MEM_FREE_ERROR_c if not.
    327          *
    328          * \pre Memory manager must be previously initialized.
    329          *
    330          * \remarks Never deallocate the same buffer twice.
    331          *
    332          ********************************************************************************** */
    333          memStatus_t MEM_BufferFree
    334            (
    335            void* buffer // IN: Block of memory to free
    336            )
    337          {
    338              pools_t *pParentPool;
    339              pools_t *pool;
    340          	
    341          #ifdef MEM_TRACKING
    342          
    343            /* Save the Link Register */
    344            volatile uint32_t savedLR;
    345          //  __asm("str  r14, [SP]");
    346            __asm("push {r1}  ");
    347            __asm("push {LR} ");
    348            __asm("pop  {r1} ");
    349            __asm("str  r1, [SP, #4]");
    350            __asm("pop {r1}");
    351          #endif /*MEM_TRACKING*/
    352          
    353            if(buffer == NULL)
    354            {
    355              return MEM_FREE_ERROR_c;
    356            }
    357          
    358            osInterruptDisable();
    359          
    360            pParentPool = (pools_t *)((listHeader_t *)buffer-1)->pParentPool;
    361          
    362            pool = memPools;
    363            for(;;)
    364            {
    365              if (pParentPool == pool)
    366                break;
    367              if(pool->nextBlockSize == 0)
    368              {
    369          #ifdef MEM_STATISTICS
    370                pParentPool->poolStatistics.freeFailures++;
    371          #endif /*MEM_STATISTICS*/
    372                osInterruptEnable();
    373                return MEM_FREE_ERROR_c;
    374              }
    375              pool++;
    376            }
    377          
    378            gFreeMessagesCount++;
    379          
    380            ListAddTail((listHandle_t)&pParentPool->anchor, (listElementHandle_t)&((listHeader_t *)buffer-1)->link);
    381          
    382          #ifdef MEM_STATISTICS
    383            MEM_ASSERT(pParentPool->poolStatistics.allocatedBlocks > 0);
    384            pParentPool->poolStatistics.allocatedBlocks--;
    385          #endif /*MEM_STATISTICS*/
    386          
    387          #ifdef MEM_TRACKING
    388            MEM_Track(buffer, MEM_TRACKING_FREE_c, savedLR, 0);
    389          #endif /*MEM_TRACKING*/
    390            osInterruptEnable();
    391            return MEM_SUCCESS_c;
    392          }
    393          
    394          /*! *********************************************************************************
    395          * \brief     Determines the size of a memory block
    396          *
    397          * \param[in] buffer - Pointer to buffer.
    398          *
    399          * \return size of memory block
    400          *
    401          * \pre Memory manager must be previously initialized.
    402          *
    403          ********************************************************************************** */
    404          uint16_t MEM_BufferGetSize
    405          (
    406          void* buffer // IN: Block of memory to free
    407          )
    408          {
    409              if( buffer )
    410              {
    411                  return ((pools_t *)((listHeader_t *)buffer-1)->pParentPool)->blockSize;
    412              }
    413          
    414              return 0;
    415          }
    416          
    417          /*! *********************************************************************************
    418          *************************************************************************************
    419          * Private functions
    420          *************************************************************************************
    421          ********************************************************************************** */
    422          /*! *********************************************************************************
    423          * \brief     This function updates the tracking array element corresponding to the given
    424          *            block.
    425          *
    426          * \param[in] block - Pointer to the block.
    427          * \param[in] alloc - Indicates whether an allocation or free operation was performed
    428          * \param[in] address - Address where MEM_BufferAlloc or MEM_BufferFree was called
    429          * \param[in] requestedSize - Indicates the requested buffer size  passed to MEM_BufferAlloc.
    430          *                            Has no use if a free operation was performed.
    431          *
    432          * \return Returns TRUE if correct allocation or dealocation was performed, FALSE if a
    433          *         buffer was allocated or freed twice.
    434          *
    435          ********************************************************************************** */
    436          #ifdef MEM_TRACKING
    437          uint8_t MEM_Track(listHeader_t *block, memTrackingStatus_t alloc, uint32_t address, uint16_t requestedSize)
    438          {
    439            uint16_t i;
    440            blockTracking_t *pTrack = NULL;
    441          #ifdef MEM_STATISTICS
    442            poolStat_t * poolStatistics = (poolStat_t *)&((pools_t *)( (listElementHandle_t)(block-1)->pParentPool ))->poolStatistics;
    443          #endif
    444          
    445            for( i=0; i<mTotalNoOfMsgs_c; i++ )
    446            {
    447                if( block == memTrack[i].blockAddr )
    448                {
    449                    pTrack = &memTrack[i];
    450                    break;
    451                }
    452            }
    453          
    454            if( !pTrack || pTrack->allocStatus == alloc)
    455            {
    456                panic( 0, (uint32_t)MEM_Track, 0, 0);
    457                return FALSE;
    458            }
    459          
    460            pTrack->allocStatus = alloc;
    461          
    462            if(alloc == MEM_TRACKING_ALLOC_c)
    463            {
    464              pTrack->fragmentWaste = pTrack->blockSize - requestedSize;
    465              pTrack->allocCounter++;
    466              pTrack->allocAddr = (void *)address;
    467          #ifdef MEM_STATISTICS
    468          
    469              poolStatistics->poolFragmentWaste += pTrack->fragmentWaste;
    470              if(poolStatistics->poolFragmentWaste > poolStatistics->poolFragmentWastePeak)
    471                poolStatistics->poolFragmentWastePeak = poolStatistics->poolFragmentWaste;
    472          #endif /*MEM_STATISTICS*/
    473            }
    474            else
    475            {
    476          #ifdef MEM_STATISTICS
    477              poolStatistics->poolFragmentWaste -= pTrack->fragmentWaste;
    478          #endif /*MEM_STATISTICS*/
    479              pTrack->fragmentWaste = 0;
    480              pTrack->freeCounter++;
    481              pTrack->freeAddr = (void *)address;
    482            }
    483          
    484            return TRUE;
    485          }
    486          #endif /*MEM_TRACKING*/
    487          
    488          /*! *********************************************************************************
    489          * \brief     Performs a write-read-verify test for every byte in all memory pools.
    490          *
    491          * \return Returns MEM_SUCCESS_c if test was successful, MEM_ALLOC_ERROR_c if a
    492          *         buffer was not allocated successufuly, MEM_FREE_ERROR_c  if a
    493          *         buffer was not freed successufuly or MEM_UNKNOWN_ERROR_c if a verify error,
    494          *         heap overflow or data corruption occurred.
    495          *
    496          ********************************************************************************** */
    497          uint32_t MEM_WriteReadTest(void)
    498          {
    499            uint8_t *data, count = 1;
    500            uintn32_t idx1,idx2,idx3;
    501            uint32_t freeMsgs;
    502          
    503            /*memory write test*/
    504            freeMsgs = MEM_GetAvailableBlocks(0);
    505          
    506            for(idx1=0; poolInfo[idx1].blockSize != 0; idx1++)
    507            {
    508              for(idx2=0; idx2 < poolInfo[idx1].poolSize; idx2++)
    509              {
    510                data = (uint8_t *)MEM_BufferAlloc(poolInfo[idx1].blockSize);
    511          
    512                if(data == NULL)
    513                {
    514                  return MEM_ALLOC_ERROR_c;
    515                }
    516          
    517                for(idx3=0; idx3 < poolInfo[idx1].blockSize; idx3++)
    518                {
    519                  if(data > memHeap + heapSize)
    520                  {
    521                    return MEM_UNKNOWN_ERROR_c;
    522                  }
    523                  *data = count & 0xff;
    524                  data++;
    525                }
    526                count++;
    527              }
    528            }
    529          
    530            count = 1;
    531            data = memHeap;
    532            /*memory read test*/
    533            for(idx1=0; poolInfo[idx1].blockSize != 0; idx1++)
    534            {
    535              for(idx2=0; idx2 < poolInfo[idx1].poolSize; idx2++)
    536              {
    537                /*New block; jump over list header*/
    538                data = data + sizeof(listHeader_t);
    539                for(idx3=0; idx3<poolInfo[idx1].blockSize; idx3++)
    540                {
    541                  if(*data == count)
    542                  {
    543                    data++;
    544                  }
    545                  else
    546                  {
    547                    return MEM_UNKNOWN_ERROR_c;
    548                  }
    549                }
    550                if(MEM_BufferFree( data - poolInfo[idx1].blockSize) != MEM_SUCCESS_c)
    551                {
    552                  return MEM_FREE_ERROR_c;
    553                }
    554                count++;
    555              }
    556            }
    557            if(MEM_GetAvailableBlocks(0) != freeMsgs)
    558            {
    559              return MEM_UNKNOWN_ERROR_c;
    560            }
    561          #ifdef MEM_STATISTICS
    562            for(idx1 = 0; poolInfo[idx1].blockSize != 0; idx1++)
    563            {
    564              memPools[idx1].poolStatistics.allocatedBlocksPeak = 0;
    565            }
    566          #endif /*MEM_STATISTICS*/
    567          
    568            return MEM_SUCCESS_c;
    569          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MEM_BufferAlloc
        16   -> ListRemoveHead
        16   -> osInterruptDisable
        16   -> osInterruptEnable
        16   -> panic
      16   MEM_BufferFree
        16   -> ListAddTail
        16   -> osInterruptDisable
        16   -> osInterruptEnable
        16 __aeabi_uread4
       4   MEM_BufferGetSize
         4 __aeabi_uread4
      16   MEM_GetAvailableBlocks
        16   -> ListGetSize
      24   MEM_Init
        24   -> ListAddTail
        24   -> ListInit
        24 __aeabi_uwrite4
      32   MEM_WriteReadTest
        32   -> MEM_BufferAlloc
        32   -> MEM_BufferFree
        32   -> MEM_GetAvailableBlocks


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
     130  MEM_BufferAlloc
      86  MEM_BufferFree
      36  MEM_BufferGetSize
      60  MEM_GetAvailableBlocks
     152  MEM_Init
     290  MEM_WriteReadTest
       2  gFreeMessagesCount
       4  heapSize
   2'944  memHeap
      48  memPools
      16  poolInfo

 
 2'994 bytes in section .bss
    16 bytes in section .data
     4 bytes in section .rodata
   782 bytes in section .text
 
   782 bytes of CODE  memory
     4 bytes of CONST memory
 3'010 bytes of DATA  memory

Errors: none
Warnings: none
