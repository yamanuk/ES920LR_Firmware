###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         14/May/2020  16:51:00
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                         
#    Endian                        =  little
#    Source file                   =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\mqxlite.c
#    Command line                  =
#        -f C:\Users\81901\AppData\Local\Temp\EW5B71.tmp
#        (C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\mqxlite.c
#        --preprocess=s
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -lcN
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -o
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\include\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\config\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\compiler\iar\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Generated_Code\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\PExSupport\Kinetis\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\OSAbstraction\MQXLite\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Common\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\Lists\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\FunctionLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\SecLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Panic\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\SerialManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\MemManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Messaging\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\Phy\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\SMAC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\ADC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\BME\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Flash\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\I2C\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LED\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LLWU\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LPTMR\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\SMC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\MCG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Reset\
#        -On)
#    Locale                        =  C
#    List file                     =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List\mqxlite.lst
#    Object file                   =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj\mqxlite.o
#    Runtime model:                   
#      __SystemLibrary             =  DLib
#      __dlib_jmp_buf_num_elements =  8
#      __dlib_version              =  6
#
###############################################################################

C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\mqxlite.c
      1          /*HEADER**********************************************************************
      2          *
      3          * Copyright (c) 2008-2010 Freescale Semiconductor;
      4          * All Rights Reserved
      5          *
      6          * Copyright (c) 2004-2008 Embedded Access Inc.;
      7          * All Rights Reserved
      8          *
      9          * Copyright (c) 1989-2008 ARC International;
     10          * All Rights Reserved
     11          *
     12          ******************************************************************************
     13          *
     14          * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
     15          * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     16          * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     17          * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     18          * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     19          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     20          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     21          * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     22          * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     23          * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     24          * THE POSSIBILITY OF SUCH DAMAGE.
     25          *
     26          ******************************************************************************
     27          *
     28          * $FileName: mqx.c$
     29          * $Version : 3.8.31.3$
     30          * $Date    : Feb-24-2012$
     31          *
     32          * Comments:
     33          *
     34          *   This file contains the source for the main MQX function _mqx().
     35          *
     36          *END*************************************************************************/
     37          
     38          #ifndef __NO_SETJMP
     39          #include <setjmp.h>
     40          #endif
     41          
     42          #include "mqx_inc.h"
     43          
     44          /*
     45           * A global zero initialized MQX tick structure.
     46           * It is used by various MQX functions that need
     47           * to zero initialize local tick structures. An
     48           * extern to it is provided in MQX.H so applications
     49           * can use it as well.
     50           */
     51          const MQX_TICK_STRUCT _mqx_zero_tick_struct;
     52          
     53          /* Version/vendor identification also used by TAD to determine paths to its context files */
     54          const uint_32      _mqx_version_number      = 0x04000000;
     55          const char * const _mqx_version             = "4.0.0";
     56          const char * const _mqx_vendor              = "Freescale/Freescale MQX";
     57          const char * const _mqx_path                = MQX_PATH;
     58          /* Version strings */
     59          const char * const _mqx_generic_revision    = REAL_NUM_TO_STR(GEN_REVISION);
     60          const char * const _mqx_psp_revision        = REAL_NUM_TO_STR(PSP_REVISION);
     61          const char * const _mqx_copyright           = "(c) 2011 Freescale Semiconductor. All rights reserved.";
     62          const char * const _mqx_date                = __DATE__ " at " __TIME__;
     63          
     64          /* Identify MQX Lite version number and version to source files (generated in user_config.h) */
     65          const uint_32      _mqxlite_version_number  = MQX_LITE_VERSION_NUMBER;
     66          const char * const _mqxlite_version         = MQX_LITE_VERSION;
     67          
     68          
     69          /* A global pointer to the location of the kernel data structure */
     70          KERNEL_ACCESS struct   kernel_data_struct * _mqx_kernel_data = (pointer)-1;
     71          KERNEL_ACCESS volatile pointer              _mqx_system_stack;
     72          
     73          /* Error return jump buffer for kernel errors */
     74          #if MQX_EXIT_ENABLED || MQX_CRIPPLED_EVALUATION
     75          jmp_buf _mqx_exit_jump_buffer_internal;
     76          #endif
     77          
     78          
     79          /*!
     80           * \brief Initializes MQXLite on the processor.
     81           *
     82           * The function does the following:
     83           * \n - Initializes kernel data.
     84           * \n - Creates the interrupt stack.
     85           * \n - Creates the ready queues.
     86           * \n - Creates a lightweight semaphore for task creation/destruction.
     87           * \n - Initializes interrupts.
     88           * \n - Initializes system timer.
     89           *
     90           * \param[in] mqx_init Pointer to the MQXLITE initialization structure for the
     91           * processor.
     92           *
     93           * \return MQX_OK
     94           * \return Initialization error code
     95           *
     96           * \warning Must be called exactly once per processor.
     97           *
     98           * \see _mqxlite
     99           * \see _mqx_exit
    100           * \see MQXLITE_INITIALIZATION_STRUCT
    101           */
    102          _mqx_uint _mqxlite_init
    103          (
    104              MQXLITE_INITIALIZATION_STRUCT const * mqx_init
    105          )
    106          { /* Body */
    107          #if MQX_USE_IDLE_TASK == 0
    108              TD_STRUCT_PTR           td_ptr;
    109              pointer                 sys_td_stack_ptr;
    110              uchar_ptr               sys_stack_base_ptr;
    111          #endif
    112              KERNEL_DATA_STRUCT_PTR  kernel_data;
    113              pointer                 stack_ptr;
    114              _mqx_uint               result = MQX_OK;
    115          
    116              /*
    117               * The kernel data structure starts at the start of kernel memory,
    118               * as specified in the initialization structure. Make sure address
    119               * specified is aligned
    120               */
    121              kernel_data = (KERNEL_DATA_STRUCT_PTR) (mqx_init->START_OF_KERNEL_MEMORY);
    122          
    123              /* Set the global pointer to the kernel data structure */
    124              _SET_KERNEL_DATA(kernel_data);
    125          
    126              /* The following assignments are done to force the linker to include
    127               * the symbols, which are required by TAD.
    128               * Note that we should use address of the variable so it is not optimized
    129               * as direct constant assignment when optimization level is high.
    130               * Note that counter will be immediately reset to zero on the subsequent
    131               * _mem_zero call. */
    132              {
    133                  MQX_INITIALIZATION_STRUCT  * MQX_init_struct_ptr;
    134          
    135                  *(volatile pointer*) kernel_data = (pointer) & _mqx_version_number;
    136                  *(volatile pointer*) kernel_data = (pointer) & _mqx_vendor;
    137                  *(volatile pointer*) kernel_data = (pointer) & _mqx_path;
    138                  *(volatile pointer*) kernel_data = (pointer) & _mqxlite_version_number;
    139                  *(volatile pointer*) kernel_data = (pointer) & MQX_init_struct_ptr;
    140              }
    141              /* Initialize the kernel data to zero. */
    142              _mem_zero((pointer) kernel_data, (_mem_size) sizeof(KERNEL_DATA_STRUCT));
    143          
    144          #if MQX_CHECK_ERRORS && MQX_VERIFY_KERNEL_DATA
    145              /* Verify that kernel data can be read and written correctly without
    146               * errors.  This is necessary during BSP development to validate the
    147               * DRAM controller is initialized properly.
    148               */
    149              if (PSP_KERNEL_DATA_VERIFY_ENABLE) {
    150                  /* This memory check is dangerous, because can destroy boot stack
    151                   * stack which is used !!! -> MQX will failed !
    152                   * Set PSP_KERNEL_DATA_VERIFY_ENABLE to 1
    153                   * only if your boot stack is out of MQX memory heap
    154                   */
    155          
    156                  result = _mem_verify((uchar_ptr)kernel_data + sizeof(KERNEL_DATA_STRUCT),
    157                                  mqx_init->END_OF_KERNEL_MEMORY);
    158                  if ( result != MQX_OK ) {
    159                      return (result); /* RETURN TO USER */
    160                  }
    161              }
    162          #endif /* MQX_CHECK_ERRORS && MQX_VERIFY_KERNEL_DATA */
    163              /* Copy the MQX initialization structure into kernel data. */
    164              kernel_data->INIT = *mqx_init;
    165          
    166              /* init kernel data structures */
    167              _mqx_init_kernel_data_internal();
    168          
    169          #if MQX_USE_INTERRUPTS
    170          
    171              /* Now obtain the interrupt stack */
    172              if (kernel_data->INIT.INTERRUPT_STACK_LOCATION) {
    173                  stack_ptr = kernel_data->INIT.INTERRUPT_STACK_LOCATION;
    174                  result = kernel_data->INIT.INTERRUPT_STACK_SIZE;
    175              }
    176              else
    177              {
    178                  return (MQX_INVALID_PARAMETER);
    179              } /* Endif */
    180          
    181          #if MQX_MONITOR_STACK
    182              _task_fill_stack_internal((_mqx_uint_ptr)stack_ptr, result);
    183          #endif
    184          
    185              kernel_data->INTERRUPT_STACK_PTR = _GET_STACK_BASE(stack_ptr, result);
    186          
    187          #endif /* MQX_USE_INTERRUPTS */
    188          
    189          #if MQX_USE_IDLE_TASK == 0
    190              {
    191                  /*
    192                   * Set the stack for the system TD, in case the idle task gets blocked
    193                   * by an exception or if idle task is not used.
    194                   */
    195                  TD_STRUCT_PTR   td_ptr;
    196                  uchar_ptr       stack_base_ptr;
    197          
    198                  stack_base_ptr = (uchar_ptr) _GET_STACK_BASE(mqx_system_stack, PSP_MINSTACKSIZE);
    199                  td_ptr = SYSTEM_TD_PTR(kernel_data);
    200                  td_ptr->STACK_PTR   = (pointer)(stack_base_ptr - sizeof(PSP_STACK_START_STRUCT));
    201                  td_ptr->STACK_BASE  = stack_base_ptr;
    202          #if MQX_TD_HAS_STACK_LIMIT
    203                  td_ptr->STACK_LIMIT = _GET_STACK_LIMIT(mqx_system_stack, PSP_MINSTACKSIZE);
    204          #endif
    205                  _mqx_system_stack   = td_ptr->STACK_PTR;
    206              }
    207          #endif /* MQX_USE_IDLE_TASK */
    208          
    209              /* Build the MQX ready to run queues */
    210              result = _psp_init_readyqs();
    211          #if MQX_CHECK_MEMORY_ALLOCATION_ERRORS
    212              if ( result != MQX_OK ) {
    213                  return (result); /* RETURN TO USER */
    214              } /* Endif */
    215          #endif
    216          
    217          #if MQX_USE_COMPONENTS
    218              /* Create a light wait semaphore for component creation */
    219              _lwsem_create((LWSEM_STRUCT_PTR)&kernel_data->COMPONENT_CREATE_LWSEM, 1);
    220          #endif
    221          
    222              /* Create a light wait semaphore for task creation/destruction creation */
    223              _lwsem_create((LWSEM_STRUCT_PTR) & kernel_data->TASK_CREATE_LWSEM, 1);
    224          
    225              /* Set the CPU type */
    226              _mqx_set_cpu_type(MQX_CPU);
    227          
    228              result = _psp_int_init(FIRST_INTERRUPT_VECTOR_USED, LAST_INTERRUPT_VECTOR_USED);
    229              if (result != MQX_OK) {
    230                  return(result); /* RETURN TO USER */
    231              }
    232          
    233              /* set possible new interrupt vector table
    234               * if MQX_ROM_VECTORS = 0 switch to ram interrupt table which
    235               * was initialized in _psp_int_init)
    236               */
    237              _int_set_vector_table((uint32_t)(&__vect_table));
    238          
    239              /*
    240               * Initialize System Timer and Ticks parameters in kernel_data structure
    241               */
    242              {
    243                  MQXLITE_SYSTEM_TIMER_INIT(NULL);
    244          
    245                  MQXLITE_SYSTEM_TIMER_GET_PERIOD_TICKS(NULL, (uint32_t *)&kernel_data->HW_TICKS_PER_TICK);
    246          
    247                  kernel_data->TICKS_PER_SECOND = MQXLITE_SYSTEM_TIMER_GET_TICS_PER_SECOND(NULL);
    248          
    249                  MQXLITE_SYSTEM_TIMER_SET_HWTICKS_FUNCTION(NULL);
    250              }
    251          
    252              return MQX_OK; /* To satisfy lint */
    253          
    254          } /* Endbody */
    255          
    256          /*!
    257           * \brief Starts MQXLite on the processor.
    258           *
    259           * The function does the following:
    260           * \n - Starts system timer.
    261           * \n - Starts MQX tasks.
    262           * \n - Starts autostart application tasks.
    263           *
    264           * \return Does not return (Success.)
    265           * \return If application calls _mqx_exit(), error code that it passed to _mqx_exit().
    266           *
    267           * \warning Must be called exactly once per processor.
    268           *
    269           * \see _mqxlite_init
    270           * \see _mqx_exit
    271           */
    272          _mqx_uint _mqxlite(void)
    273          { /* Body */
    274              KERNEL_DATA_STRUCT_PTR              kernel_data;
    275              TD_STRUCT_PTR                       td_ptr;
    276          
    277          #if MQX_EXIT_ENABLED || MQX_CRIPPLED_EVALUATION
    278              /* Setup a longjmp buffer using setjmp, so that if an error occurs
    279               * in mqx initialization, we can perform a longjmp to this location.
    280               *
    281               * Also _mqx_exit will use this jumpbuffer to longjmp to here in order
    282               * to cleanly exit MQX.
    283               */
    284              if ( MQX_SETJMP( _mqx_exit_jump_buffer_internal ) ) {
    285                  _GET_KERNEL_DATA(kernel_data);
    286                  _int_set_vector_table(kernel_data->USERS_VBR);
    287                  return kernel_data->USERS_ERROR;
    288              } /* Endif */
    289          #endif
    290          
    291          
    292              _GET_KERNEL_DATA(kernel_data);
    293          
    294          
    295              /* Create the idle task */
    296          #if MQX_USE_IDLE_TASK
    297              td_ptr = _task_init_internal((TASK_TEMPLATE_STRUCT_PTR)&kernel_data->IDLE_TASK_TEMPLATE,
    298                                          kernel_data->ACTIVE_PTR->TASK_ID,
    299                                          #if MQX_ENABLE_LOW_POWER
    300                                              (uint_32)1,
    301                                          #else
    302                                              (uint_32)0,
    303                                          #endif
    304                                           FALSE,
    305                                           kernel_data->INIT.IDLE_TASK_STACK_LOCATION,
    306                                           kernel_data->IDLE_TASK_TEMPLATE.TASK_STACKSIZE);
    307              #if MQX_CHECK_ERRORS
    308                  if (td_ptr == NULL) {
    309                      _mqx_exit(MQX_OUT_OF_MEMORY);
    310                  } /* Endif */
    311              #endif
    312              _task_ready_internal(td_ptr);
    313          #endif /* MQX_USE_IDLE_TASK */
    314          
    315              /* Check here for auto-create tasks, and create them here */
    316              {
    317                  TASK_TEMPLATE_STRUCT_PTR    template_ptr;
    318                  int                         task_index = 0;
    319          
    320                  template_ptr = kernel_data->INIT.TASK_TEMPLATE_LIST;
    321          
    322                  while (template_ptr->TASK_TEMPLATE_INDEX) {
    323                      if (template_ptr->TASK_ATTRIBUTES & MQX_AUTO_START_TASK) {
    324                          td_ptr = _task_init_internal(template_ptr,
    325                                                       kernel_data->ACTIVE_PTR->TASK_ID,
    326                                                       template_ptr->CREATION_PARAMETER,
    327                                                       FALSE,
    328                                                       (pointer)mqx_task_stack_pointers[task_index],
    329                                                       (_mem_size)template_ptr->TASK_STACKSIZE);
    330              #if MQX_CHECK_MEMORY_ALLOCATION_ERRORS
    331                          if (td_ptr == NULL) {
    332                              _mqx_exit(MQX_OUT_OF_MEMORY);
    333                          } /* Endif */
    334              #endif
    335                          _task_ready_internal(td_ptr);
    336                      } /* Endif */
    337                      ++template_ptr;
    338                      ++task_index;
    339                  } /* Endwhile */
    340              }
    341          
    342              /* System timer start */
    343              MQXLITE_SYSTEM_TIMER_START(NULL);
    344              _sched_start_internal(); /* WILL NEVER RETURN FROM HERE */
    345          
    346              return MQX_OK; /* To satisfy lint */
    347          } /* Endbody */
    348          
    349          /*!
    350           * \brief Terminate the MQX application and return to the environment that started
    351           * the application.
    352           *
    353           * The function returns back to the environment that called _mqxlite(). If the
    354           * application has installed the MQX exit handler (_mqx_set_exit_handler()),
    355           * _mqx_exit() calls the MQX exit handler before it exits. By default,
    356           * _bsp_exit_handler() is installed as the MQX exit handler in each BSP.
    357           *
    358           * \note
    359           * It is important to ensure that the environment (boot call stack) the MQX is
    360           * returning to is in the consistent state. This is not provided by distributed
    361           * MQX BSPs, because the boot stack is reused (rewritten) by MQX Kernel data. Set
    362           * the boot stack outside of Kernel data section to support correct _mqx_exit
    363           * functionality.
    364           *
    365           * \param[in] error Error code to return to the function that called _mqxlite_init()
    366           * or _mqxlite().
    367           *
    368           * \warning Behavior depends on the BSP.
    369           *
    370           * \see mqxlite_init
    371           * \see mqxlite
    372           */
    373          void _mqx_exit
    374          (
    375              _mqx_uint error
    376          )
    377          { /* Body */
    378              KERNEL_DATA_STRUCT_PTR kernel_data;
    379          
    380              _int_disable();
    381          
    382              _GET_KERNEL_DATA(kernel_data);
    383              _KLOGE2(KLOG_mqx_exit, error);
    384          
    385          #if MQX_EXIT_ENABLED
    386              kernel_data->USERS_ERROR = error;
    387              if (kernel_data->EXIT_HANDLER) {
    388                  (*kernel_data->EXIT_HANDLER)();
    389              }/* Endif */
    390              MQX_LONGJMP( _mqx_exit_jump_buffer_internal, 1 );
    391          #else
    392              while (TRUE) {
    393              } /* Endwhile */
    394          #endif /* MQX_EXIT_ENABLED */
    395          } /* Endbody */
    396          
    397          /* EOF */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _mqx_exit
        16   -- Indirect call
        16   -> _int_disable
        16   -> longjmp
      32   _mqxlite
        32   -> SystemTimer1_Enable
        32   -> _int_set_vector_table
        32   -> _mqx_exit
        32   -> _sched_start_internal
        32   -> _task_init_internal
        32   -> _task_ready_internal
        32   -> setjmp
      32   _mqxlite_init
        32   -> SystemTimer1_GetPeriodTicks
        32   -> SystemTimer1_GetTicsPerSecond
        32   -> SystemTimer1_Init
        32   -> __aeabi_memcpy4
        32   -> _int_set_vector_table
        32   -> _lwsem_create
        32   -> _mem_zero
        32   -> _mqx_init_kernel_data_internal
        32   -> _mqx_set_cpu_type
        32   -> _psp_init_readyqs
        32   -> _psp_int_init
        32   -> _task_fill_stack_internal
        32   -> _time_set_hwtick_function


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       8  ?_0
      24  ?_1
      72  ?_2
      16  ?_3
      16  ?_4
      56  ?_5
      24  ?_6
       8  ?_7
       4  _mqx_copyright
       4  _mqx_date
      46  _mqx_exit
      64  _mqx_exit_jump_buffer_internal
       4  _mqx_generic_revision
       4  _mqx_kernel_data
       4  _mqx_path
       4  _mqx_psp_revision
       4  _mqx_system_stack
       4  _mqx_vendor
       4  _mqx_version
       4  _mqx_version_number
      12  _mqx_zero_tick_struct
     170  _mqxlite
     218  _mqxlite_init
       4  _mqxlite_version
       4  _mqxlite_version_number

 
  68 bytes in section .bss
   4 bytes in section .data
 276 bytes in section .rodata
 470 bytes in section .text
 
 470 bytes of CODE  memory
 276 bytes of CONST memory
  72 bytes of DATA  memory

Errors: none
Warnings: none
