###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         14/May/2020  16:51:02
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\SerialManager\Source\SerialManager.c
#    Command line      =
#        -f C:\Users\81901\AppData\Local\Temp\EW6103.tmp
#        (C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\SerialManager\Source\SerialManager.c
#        --preprocess=s
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -lcN
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -o
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\include\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\config\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\compiler\iar\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Generated_Code\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\PExSupport\Kinetis\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\OSAbstraction\MQXLite\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Common\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\Lists\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\FunctionLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\SecLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Panic\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\SerialManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\MemManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Messaging\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\Phy\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\SMAC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\ADC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\BME\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Flash\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\I2C\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LED\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LLWU\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LPTMR\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\SMC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\MCG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Reset\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List\SerialManager.lst
#    Object file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj\SerialManager.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\SerialManager\Source\SerialManager.c
      1          /*!
      2          * Copyright (c) 2014, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file SerialManager.c
      6          * This is the source file for the Serial Manager.
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          
     35          /*! *********************************************************************************
     36          *************************************************************************************
     37          * Include
     38          *************************************************************************************
     39          ********************************************************************************** */
     40          
     41          #include "SerialManager.h"
     42          #include "Panic.h"
     43          #include "MemManager.h"
     44          #include "Messaging.h"
     45          #include "FunctionLib.h"
     46          
     47          #if (gSerialMgrUseUartA_c)
     48          #include "UARTA.h"
     49          #endif
     50          #if (gSerialMgrUseUartB_c)
     51          #include "UARTB.h"
     52          #endif
     53          #if (gSerialMgrUseIIC_c)
     54          #include "I2CDriver.h"
     55          #endif
     56          #if (gSerialMgrUseSPI_c)
     57          #include "SPISlave.h"
     58          #endif
     59          
     60          #if (gSerialMgrUseIIC_c || gSerialMgrUseSPI_c)
     61          #include "DataAvailablePin.h"
     62          #endif
     63          
     64          #include <string.h>
     65          
     66          
     67          /*! *********************************************************************************
     68          *************************************************************************************
     69          * Private macros
     70          *************************************************************************************
     71          ********************************************************************************** */
     72          #define mSerial_IncIdx_d(idx, max) if( ++(idx) >= (max) )  (idx) = 0;
     73          
     74          #define mSerial_DecIdx_d(idx, max) if( (idx) > 0 )  (idx)--;     \
     75                                        else  (idx) = (max) - 1;
     76          
     77          /*! *********************************************************************************
     78          *************************************************************************************
     79          * Private prototypes
     80          *************************************************************************************
     81          ********************************************************************************** */
     82          #if (gSerialManagerMaxInterfaces_c)
     83          static void SerialManagerTask(void const *argument);
     84          serialStatus_t Serial_WriteInternal (uint8_t InterfaceId);
     85          uint16_t Serial_ReadInternal(uint8_t InterfaceId, uint8_t *pData, uint16_t dataSize);
     86          
     87          void SerialManager_RxNotify(LDD_TUserData *UserDataPtr);
     88          void SerialManager_TxNotify(LDD_TUserData *UserDataPtr);
     89          #if (gSerialMgrUseIIC_c)
     90          void SerialManager_IICErrorNotify( LDD_TUserData *pData );
     91          #endif
     92          
     93          static inline serialStatus_t Serial_WriteCommon( uint8_t InterfaceId,
     94                                            uint8_t *pBuf,
     95                                            uint16_t bufLen,
     96                                            pSerialCallBack_t cb,
     97                                            void *pTxParam,
     98                                            uint8_t extraFlags);
     99          static void Serial_TxQueueMaintenance(serial_t *pSer);
    100          #endif
    101          
    102          /************************************************************************************
    103          *************************************************************************************
    104          * Private type definitions
    105          *************************************************************************************
    106          ************************************************************************************/
    107          /* Defines events recognized by the SerialManager's Task */
    108          typedef enum{
    109              gSMGR_Rx_c     = (1<<0),
    110              gSMGR_TxDone_c = (1<<1),
    111              gSMGR_TxNew_c  = (1<<2)
    112          }serialEventType_t;
    113          
    114          /*! *********************************************************************************
    115          *************************************************************************************
    116          * Public memory declarations
    117          *************************************************************************************
    118          ********************************************************************************** */
    119          extern void (*SerialManager_RxNotify_fptr)(LDD_TUserData*);
    120          extern void (*SerialManager_TxNotify_fptr)(LDD_TUserData*);
    121          extern void (*SerialManager_IICErrorNotify_fptr)(LDD_TUserData*);
    122          
    123          /*! *********************************************************************************
    124          *************************************************************************************
    125          * Private memory declarations
    126          *************************************************************************************
    127          ********************************************************************************** */
    128          #if gSerialManagerMaxInterfaces_c
    129          #if defined(__GNUC__)
    130          osThreadLink_t osThreadLink_SerialManagerTask[1] = {0};
    131          uint8_t osThread_SerialManagerTask_stack[(gSerialTaskStackSize_c)*(1)];
    132          uint8_t osThread_SerialManagerTask_signal[36*(1)];
    133          osThreadDef_t os_thread_def_SerialManagerTask = { SerialManagerTask,
    134                                                            gSerialTaskPriority_c,
    135                                                            1,
    136                                                            gSerialTaskStackSize_c,
    137                                                            osThread_SerialManagerTask_stack,
    138                                                            osThread_SerialManagerTask_signal,
    139                                                            osThreadLink_SerialManagerTask,
    140                                                            "SerialManagerTask"};
    141          #else
    142          osThreadDef( SerialManagerTask, gSerialTaskPriority_c, 1, gSerialTaskStackSize_c );
    143          #endif
    144          osThreadId  gSerialManagerTaskId = NULL;
    145          serial_t    mSerials[gSerialManagerMaxInterfaces_c];
    146          #endif
    147          
    148          /*! *********************************************************************************
    149          *************************************************************************************
    150          * Public functions
    151          *************************************************************************************
    152          ********************************************************************************** */
    153          
    154          /*! *********************************************************************************
    155          * \brief   Creates the SerialManager's task and initializes internal data structures
    156          *
    157          ********************************************************************************** */
    158          void SerialManager_Init( void )
    159          {
    160          #if (gSerialManagerMaxInterfaces_c)
    161              /* Check if SMGR is already initialized */
    162              if( gSerialManagerTaskId )
    163                  return;
    164          
    165          #if (gSerialMgrUseIIC_c || gSerialMgrUseSPI_c)
    166              DataAvailablePin_Init(NULL);
    167          #endif
    168          
    169              SerialManager_RxNotify_fptr = SerialManager_RxNotify;
    170              SerialManager_TxNotify_fptr = SerialManager_TxNotify;
    171          
    172              /* Fill the structure with zeros */
    173              FLib_MemSet( mSerials, 0x00, sizeof(mSerials) );
    174          
    175              gSerialManagerTaskId = osThreadCreate(osThread(SerialManagerTask), NULL);
    176          #endif
    177          }
    178          
    179          /*! *********************************************************************************
    180          * \brief   The main task of the Serial Manager
    181          *
    182          * \param[in] initialData unused
    183          *
    184          ********************************************************************************** */
    185          #if (gSerialManagerMaxInterfaces_c)
    186          static void SerialManagerTask(void const *argument)
    187          {
    188              uint16_t i;
    189              uint8_t ev;
    190          
    191              for( i = 0; i < gSerialManagerMaxInterfaces_c; i++ )
    192                  mSerials[i].txCurrent = gSerialMgrInvalidIdx_c;
    193          
    194              while( 1 )
    195              {
    196                  /* Wait for an event. The task will block here. */
    197                  osSignalWait( 0, osWaitForever );
    198          
    199                  for( i = 0; i < gSerialManagerMaxInterfaces_c; i++ )
    200                  {
    201                      osInterruptDisable();
    202                      ev = mSerials[i].flags;
    203                      mSerials[i].flags = 0;
    204                      osInterruptEnable();
    205          
    206                      if ( (ev & gSMGR_Rx_c) &&
    207                           (NULL != mSerials[i].rxCallback) )
    208                      {
    209                          mSerials[i].rxCallback( mSerials[i].pRxParam );
    210                      }
    211          
    212                      if( ev & gSMGR_TxDone_c )
    213                      {
    214                          Serial_TxQueueMaintenance(&mSerials[i]);
    215                      }
    216          
    217          
    218                      /* If the Serial is IDLE and there is data to tx */
    219                      if(
    220                          ( mSerials[i].txCurrent == gSerialMgrInvalidIdx_c ) &&
    221                          ( mSerials[i].txQueue[mSerials[i].txOut].flags & gSerialMgrBufferInUse_c ) &&
    222                          ( mSerials[i].txQueue[mSerials[i].txOut].dataSize )
    223                        )
    224                      {
    225                          mSerials[i].txCurrent = mSerials[i].txOut;
    226                          if ( gSerial_Success_c != Serial_WriteInternal( i ) )
    227                          {
    228                              SerialManager_TxNotify( (LDD_TUserData *)i );
    229                          }
    230                      }
    231          
    232                  }
    233              } /* while(1) */
    234          }
    235          #endif
    236          
    237          /*! *********************************************************************************
    238          * \brief   Initialize a communication interface.
    239          *
    240          * \param[in] pInterfaceId pointer to a location where the interface Id will be stored
    241          * \param[in] interfaceType the tupe of the interface: UART/SPI/IIC/USB
    242          * \param[in] channel the number of the HW module (ex: if UART1 is used, this value should be 1)
    243          *
    244          * \return The interface number if success or gSerialManagerInvalidInterface_c if an error occured.
    245          *
    246          ********************************************************************************** */
    247          serialStatus_t Serial_InitInterface( uint8_t *pInterfaceId,
    248                                               serialInterfaceType_t interfaceType,
    249                                               uint8_t channel )
    250          {
    251          #if gSerialManagerMaxInterfaces_c
    252              uint8_t i;
    253          
    254              *pInterfaceId = gSerialMgrInvalidIdx_c;
    255          
    256              for ( i=0; i<gSerialManagerMaxInterfaces_c; i++ )
    257              {
    258                  if ( (mSerials[i].serialType == interfaceType) &&
    259                      (mSerials[i].serialChannel == channel) )
    260                  {
    261                      /* The Interface is allready opened. */
    262                      return gSerial_InterfaceInUse_c;
    263                  }
    264                  else if ( mSerials[i].serialType == gSerialMgrNone_c )
    265                  {
    266                      mSerials[i].serialChannel = channel;
    267                      switch ( interfaceType )
    268                      {
    269          #if (gSerialMgrUseUartA_c || gSerialMgrUseUartB_c)
    270                      case gSerialMgrUart_c:
    271                          switch(mSerials[i].serialChannel)
    272                          {
    273          #if gSerialMgrUseUartA_c
    274                          case 1:
    275                              mSerials[i].serialIf = UARTA_Init( (void*)i );
    276                              break;
    277          #endif
    278          #if gSerialMgrUseUartB_c
    279                          case 2:
    280                              mSerials[i].serialIf = UARTB_Init( (void*)i );
    281                              UARTB_ConnectPin(NULL, LDD_SERIAL_RX_PIN | LDD_SERIAL_TX_PIN);
    282                              break;
    283          #endif
    284                          default:
    285                              return gSerial_InvalidInterface_c;
    286                          }
    287                          if (NULL == mSerials[i].serialIf)
    288                          {
    289                              return gSerial_InternalError_c;
    290                          }
    291                          else
    292                          {
    293                              /* init Rx process */
    294                              switch(mSerials[i].serialChannel)
    295                              {
    296          #if gSerialMgrUseUartA_c
    297                              case 1:
    298                                  UARTA_ReceiveBlock( mSerials[i].serialIf, &mSerials[i].rxBuffer[mSerials[i].rxIn], 1 );
    299                                  break;
    300          #endif
    301          #if gSerialMgrUseUartB_c
    302                              case 2:
    303                                  UARTB_ReceiveBlock( mSerials[i].serialIf, &mSerials[i].rxBuffer[mSerials[i].rxIn], 1 );
    304                                  break;
    305          #endif
    306                              default:
    307                                  return gSerial_InvalidInterface_c;
    308                              }
    309                          }
    310                          break;
    311          #endif
    312          #if gSerialMgrUseUSB_c
    313                      case gSerialMgrUSB_c:
    314                          if( gSerial_Success_c != serialInitUsb( i ) )
    315                              return gSerial_InternalError_c;
    316                          break;
    317          #endif
    318          #if gSerialMgrUseIIC_c
    319                      case gSerialMgrIICMaster_c:
    320                      case gSerialMgrIICSlave_c:
    321                          switch(mSerials[i].serialChannel)
    322                          {
    323                          case 1:
    324                              mSerials[i].serialIf = I2CDriver_Init( (void*)i );
    325                              DataAvailablePin_Init(NULL);
    326                              SerialManager_IICErrorNotify_fptr = SerialManager_IICErrorNotify;
    327                              break;
    328                          default:
    329                              return gSerial_InvalidInterface_c;
    330                          }
    331          
    332                          if (NULL == mSerials[i].serialIf)
    333                          {
    334                              return gSerial_InternalError_c;
    335                          }
    336          
    337                          if(interfaceType == gSerialMgrIICSlave_c)
    338                          {
    339                              switch(mSerials[i].serialChannel)
    340                              {
    341                              case 1:
    342                                  DataAvailablePin_SetPortEventCondition(NULL, DataAvailablePin_DAP_MASK, LDD_GPIO_DISABLED);
    343                                  DataAvailablePin_SetPortOutputDirection(NULL, DataAvailablePin_DAP_MASK, 0);
    344                                  I2CDriver_SlaveReceiveBlock(mSerials[i].serialIf, &mSerials[i].rxBuffer[mSerials[i].rxIn], 1);
    345                                  break;
    346                              default:
    347                                  return gSerial_InvalidInterface_c;
    348                              }
    349                          }
    350                          else
    351                          {
    352                              DataAvailablePin_SetPortEventCondition(NULL, DataAvailablePin_DAP_MASK, LDD_GPIO_RISING);
    353                              DataAvailablePin_SetPortInputDirection(NULL, DataAvailablePin_DAP_MASK);
    354                              I2CDriver_SelectSlaveDevice(mSerials[i].serialIf,
    355                                                    LDD_I2C_ADDRTYPE_7BITS,
    356                                                    gSerialMgrIICAddress_c);
    357                          }
    358                          break;
    359          #endif
    360          #if gSerialMgrUseSPI_c
    361                      case gSerialMgrSPIMaster_c:
    362                      case gSerialMgrSPISlave_c:
    363                          switch(mSerials[i].serialChannel)
    364                          {
    365                          case 1:
    366                              mSerials[i].serialIf = SPISlave_Init( (void*)i );
    367                              SPISlave_ConnectPin(mSerials[i].serialIf,
    368                                                  LDD_SPISLAVE_INPUT_PIN |
    369                                                  LDD_SPISLAVE_OUTPUT_PIN |
    370                                                  LDD_SPISLAVE_CLK_PIN |
    371                                                  LDD_SPISLAVE_SS_PIN);
    372                              DataAvailablePin_Init(NULL);
    373                              break;
    374                          default:
    375                              return gSerial_InvalidInterface_c;
    376                          }
    377          
    378                          if (NULL == mSerials[i].serialIf)
    379                          {
    380                              return gSerial_InternalError_c;
    381                          }
    382          
    383                          if(interfaceType == gSerialMgrSPISlave_c)
    384                          {
    385                              switch(mSerials[i].serialChannel)
    386                              {
    387                              case 1:
    388                                  DataAvailablePin_SetPortEventCondition(NULL, DataAvailablePin_DAP_MASK, LDD_GPIO_DISABLED);
    389                                  DataAvailablePin_SetPortOutputDirection(NULL, DataAvailablePin_DAP_MASK, 0);
    390                                  SPISlave_ReceiveBlock(mSerials[i].serialIf, &mSerials[i].rxBuffer[mSerials[i].rxIn], 1);
    391                                  break;
    392                              default:
    393                                  return gSerial_InvalidInterface_c;
    394                              }
    395                          }
    396                          else
    397                          {
    398                              DataAvailablePin_SetPortEventCondition(NULL, DataAvailablePin_DAP_MASK, LDD_GPIO_RISING);
    399                              DataAvailablePin_SetPortInputDirection(NULL, DataAvailablePin_DAP_MASK);
    400                          }
    401                          break;
    402          #endif
    403                      default:
    404                          return gSerial_InvalidInterface_c;
    405                      }
    406          
    407                      mSerials[i].txSyncSem = osSemaphoreCreate(NULL, 0);
    408                      if ( NULL == mSerials[i].txSyncSem )
    409                          return gSerial_SemCreateError_c;
    410          
    411          #if gSerialMgr_BlockSenderOnQueueFull_c
    412                      mSerials[i].txQueueSem = osSemaphoreCreate(NULL, 0);
    413                      if ( NULL == mSerials[i].txQueueSem )
    414                          return gSerial_SemCreateError_c;
    415          #endif
    416          
    417                      mSerials[i].serialType = interfaceType;
    418                      *pInterfaceId = i;
    419                      return gSerial_Success_c;
    420                  }
    421              }
    422          
    423              /* There are no more free interfaces. */
    424              return gSerial_MaxInterfacesReached_c;
    425          #else
    426              (void)interfaceType;
    427              (void)channel;
    428              (void)pInterfaceId;
    429              return gSerial_Success_c;
    430          #endif
    431          }
    432          
    433          /*! *********************************************************************************
    434          * \brief   Transmit a data buffer asynchronously
    435          *
    436          * \param[in] InterfaceId the interface number
    437          * \param[in] pBuf pointer to data location
    438          * \param[in] bufLen the number of bytes to be sent
    439          * \param[in] pSerialRxCallBack pointer to a function that will be called when
    440          *            a new char is available
    441          *
    442          * \return The status of the operation
    443          *
    444          ********************************************************************************** */
    445          serialStatus_t Serial_AsyncWrite( uint8_t InterfaceId,
    446                                            uint8_t *pBuf,
    447                                            uint16_t bufLen,
    448                                            pSerialCallBack_t cb,
    449                                            void *pTxParam )
    450          {
    451          #if gSerialManagerMaxInterfaces_c
    452              return Serial_WriteCommon(InterfaceId, pBuf, bufLen, cb, pTxParam, 0);
    453          #else
    454              (void)InterfaceId;
    455              (void)pBuf;
    456              (void)bufLen;
    457              (void)cb;
    458              (void)pTxParam;
    459              return gSerial_Success_c;
    460          #endif /* gSerialManagerMaxInterfaces_c */
    461          }
    462          
    463          
    464          /*! *********************************************************************************
    465          * \brief Transmit a data buffer synchronously. The task will block until the Tx is done
    466          *
    467          * \param[in] pBuf pointer to data location
    468          * \param[in] bufLen the number of bytes to be sent
    469          * \param[in] InterfaceId the interface number
    470          *
    471          * \return The status of the operation
    472          *
    473          ********************************************************************************** */
    474          serialStatus_t Serial_SyncWrite( uint8_t InterfaceId,
    475                                           uint8_t *pBuf,
    476                                           uint16_t bufLen )
    477          {
    478              serialStatus_t status = gSerial_Success_c;
    479          #if gSerialManagerMaxInterfaces_c
    480              uint8_t flags = gSerialMgrSyncTx_c;
    481              volatile serial_t *pSer = &mSerials[InterfaceId];
    482          
    483              /* If the calling task is SMGR do not block on semaphore */
    484              if( osThreadGetId() == gSerialManagerTaskId )
    485                  flags = 0;
    486          
    487              status  = Serial_WriteCommon(InterfaceId, pBuf, bufLen, NULL, NULL, flags);
    488          
    489              if( gSerial_Success_c == status )
    490              {
    491                  /* Wait until Tx finishes. The sem will be released by the SMGR task */
    492                  if( flags & gSerialMgrSyncTx_c )
    493                  {
    494                      osSemaphoreWait( pSer->txSyncSem, osWaitForever );
    495                  }
    496                  else
    497                  {
    498                      while(pSer->txCurrent != gSerialMgrInvalidIdx_c);
    499                  }
    500              }
    501          #else
    502              (void)pBuf;
    503              (void)bufLen;
    504              (void)InterfaceId;
    505          #endif /* gSerialManagerMaxInterfaces_c */
    506              return status;
    507          }
    508          
    509          /*! *********************************************************************************
    510          * \brief   Returns a specified number of characters from the Rx buffer
    511          *
    512          * \param[in] InterfaceId the interface number
    513          * \param[out] pData pointer to location where to store the characters
    514          * \param[in] dataSize the number of characters to be read
    515          * \param[out] bytesRead the number of characters read
    516          *
    517          * \return The status of the operation
    518          *
    519          ********************************************************************************** */
    520          serialStatus_t Serial_Read( uint8_t InterfaceId,
    521                                      uint8_t *pData,
    522                                      uint16_t dataSize,
    523                                      uint16_t *bytesRead )
    524          {
    525          #if (gSerialManagerMaxInterfaces_c)
    526          #if gSerialMgr_ParamValidation_d
    527              if ( (InterfaceId >= gSerialManagerMaxInterfaces_c) ||
    528                  (NULL == pData) || (NULL == bytesRead) || (0 == dataSize) )
    529                  return gSerial_InvalidParameter_c;
    530          #endif
    531          
    532              switch ( mSerials[InterfaceId].serialType )
    533              {
    534          #if (gSerialMgrUseUartA_c || gSerialMgrUseUartB_c)
    535              case gSerialMgrUart_c:
    536                  *bytesRead = Serial_ReadInternal( InterfaceId, pData, dataSize );
    537                  return gSerial_Success_c;
    538                  break;
    539          #endif
    540          #if gSerialMgrUseUSB_c
    541              case gSerialMgrUSB_c:
    542                  *bytesRead = serialReadUsb( pData, dataSize, &mSerials[InterfaceId] );
    543                  return gSerial_Success_c;
    544                  break;
    545          #endif
    546          #if gSerialMgrUseIIC_c
    547              case gSerialMgrIICMaster_c:
    548                  switch(mSerials[InterfaceId].serialChannel)
    549                  {
    550                  case 1:
    551                       I2CDriver_MasterReceiveBlock(mSerials[InterfaceId].serialIf, pData, dataSize, LDD_I2C_SEND_STOP);
    552                      *bytesRead = dataSize;
    553                      return gSerial_Success_c;
    554                      break;
    555                  default:
    556                      return gSerial_InvalidInterface_c;
    557                  }
    558                  break;
    559              case gSerialMgrIICSlave_c:
    560                  *bytesRead = Serial_ReadInternal( InterfaceId, pData, dataSize );
    561                  return gSerial_Success_c;
    562                  break;
    563          #endif
    564          #if gSerialMgrUseSPI_c
    565              case gSerialMgrSPISlave_c:
    566                  *bytesRead = Serial_ReadInternal( InterfaceId, pData, dataSize );
    567                  return gSerial_Success_c;
    568                  break;
    569          #endif
    570              default:
    571                  return gSerial_InvalidInterface_c;
    572              }
    573          #else
    574              (void)InterfaceId;
    575              (void)pData;
    576              (void)dataSize;
    577              (void)bytesRead;
    578              return gSerial_InvalidInterface_c;
    579          #endif
    580          }
    581          
    582          /*! *********************************************************************************
    583          * \brief   Returns a the number of bytes available in the RX buffer
    584          *
    585          * \param[in] InterfaceId the interface number
    586          * \param[out] bytesCount the number of bytes available
    587          *
    588          * \return The status of the operation
    589          *
    590          ********************************************************************************** */
    591          serialStatus_t Serial_RxBufferByteCount( uint8_t InterfaceId, uint16_t *bytesCount )
    592          {
    593          #if (gSerialManagerMaxInterfaces_c)
    594          #if gSerialMgr_ParamValidation_d
    595              if ( (InterfaceId >= gSerialManagerMaxInterfaces_c) ||
    596                  (NULL == bytesCount) )
    597                  return  gSerial_InvalidParameter_c;
    598          #endif
    599              if( mSerials[InterfaceId].rxIn >= mSerials[InterfaceId].rxOut )
    600              {
    601                  *bytesCount = mSerials[InterfaceId].rxIn - mSerials[InterfaceId].rxOut;
    602              }
    603              else
    604              {
    605                  *bytesCount = gSerialMgrRxBufSize_c - mSerials[InterfaceId].rxOut + mSerials[InterfaceId].rxIn;
    606              }
    607          #else
    608              (void)bytesCount;
    609              (void)InterfaceId;
    610          #endif
    611              return gSerial_Success_c;
    612          }
    613          
    614          /*! *********************************************************************************
    615          * \brief   Sets a pointer to a function that will be called when data is received
    616          *
    617          * \param[in] InterfaceId the interface number
    618          * \param[in] pfCallBack pointer to the function to be called
    619          * \param[in] pRxParam pointer to a parameter which will be passed to the CB function
    620          *
    621          * \return The status of the operation
    622          *
    623          ********************************************************************************** */
    624          serialStatus_t Serial_SetRxCallBack( uint8_t InterfaceId, pSerialCallBack_t cb, void *pRxParam )
    625          {
    626          #if (gSerialManagerMaxInterfaces_c)
    627          #if gSerialMgr_ParamValidation_d
    628              if ( InterfaceId >= gSerialManagerMaxInterfaces_c )
    629                  return gSerial_InvalidParameter_c;
    630          #endif
    631              mSerials[InterfaceId].rxCallback = cb;
    632              mSerials[InterfaceId].pRxParam = pRxParam;
    633          #else
    634              (void)InterfaceId;
    635              (void)cb;
    636              (void)pRxParam;
    637          #endif
    638              return gSerial_Success_c;
    639          }
    640          
    641          /*! *********************************************************************************
    642          * \brief   Set the communication speed for an interface
    643          *
    644          * \param[in] baudRate communication speed
    645          * \param[in] InterfaceId the interface number
    646          *
    647          * \return The status of the operation
    648          *
    649          ********************************************************************************** */
    650          serialStatus_t Serial_SetBaudRate( uint8_t InterfaceId, uint32_t baudRate  )
    651          {
    652          #if gSerialManagerMaxInterfaces_c
    653          #if gSerialMgr_ParamValidation_d
    654              if ( (InterfaceId >= gSerialManagerMaxInterfaces_c) ||
    655                  (0 == baudRate) )
    656                  return gSerial_InvalidParameter_c;
    657          #endif
    658              switch ( mSerials[InterfaceId].serialType )
    659              {
    660          #if (gSerialMgrUseUartA_c || gSerialMgrUseUartB_c)
    661              LDD_SERIAL_TBaudMode baudRateInternal;
    662              case gSerialMgrUart_c:
    663                  switch ( baudRate )
    664                  {
    665                  case gUARTBaudRate1200_c:
    666                      baudRateInternal = UARTA_BM_1200BAUD;
    667                      break;
    668                  case gUARTBaudRate2400_c:
    669                      baudRateInternal = UARTA_BM_2400BAUD;
    670                      break;
    671                  case gUARTBaudRate4800_c:
    672                      baudRateInternal = UARTA_BM_4800BAUD;
    673                      break;
    674                  case gUARTBaudRate9600_c:
    675                      baudRateInternal = UARTA_BM_9600BAUD;
    676                      break;
    677                  case gUARTBaudRate19200_c:
    678                      baudRateInternal = UARTA_BM_19200BAUD;
    679                      break;
    680                  case gUARTBaudRate38400_c:
    681                      baudRateInternal = UARTA_BM_38400BAUD;
    682                      break;
    683                  case gUARTBaudRate57600_c:
    684                      baudRateInternal = UARTA_BM_57600BAUD;
    685                      break;
    686                  case gUARTBaudRate115200_c:
    687                      baudRateInternal = UARTA_BM_115200BAUD;
    688                      break;
    689                  case gUARTBaudRate230400_c:
    690                      baudRateInternal = UARTA_BM_230400BAUD;
    691                      break;
    692                  default:
    693                      return gSerial_InvalidParameter_c;
    694                  }
    695          
    696                  switch(mSerials[InterfaceId].serialChannel)
    697                  {
    698          #if gSerialMgrUseUartA_c
    699                      case 1:
    700                          if( ERR_OK != UARTA_SelectBaudRate( mSerials[InterfaceId].serialIf, baudRateInternal ) )
    701                              return gSerial_InternalError_c;
    702                          break;
    703          #endif
    704          #if gSerialMgrUseUartB_c
    705                      case 2:
    706                          if( ERR_OK != UARTB_SelectBaudRate( mSerials[InterfaceId].serialIf, baudRateInternal ) )
    707                              return gSerial_InternalError_c;
    708                          break;
    709          #endif
    710                      default:
    711                          return gSerial_InvalidInterface_c;
    712                  }
    713                  break;
    714          #endif
    715          #if gSerialMgrUseIIC_c
    716              case gSerialMgrIICMaster_c:
    717              case gSerialMgrIICSlave_c:
    718                  return gSerial_InvalidInterface_c;
    719                  break;
    720          #endif
    721          #if gSerialMgrUseSPI_c
    722              case gSerialMgrSPIMaster_c:
    723              case gSerialMgrSPISlave_c:
    724                  return gSerial_InvalidInterface_c;
    725                  break;
    726          #endif
    727          #if gSerialMgrUseUSB_c
    728              case gSerialMgrUSB_c:
    729                  /* Nothing to do here. */
    730                  break;
    731          #endif
    732              default:
    733                  return gSerial_InvalidInterface_c;
    734              }
    735          #endif
    736              return gSerial_Success_c;
    737          }
    738          
    739          /*! *********************************************************************************
    740          * \brief   Prints a char to the serial interface
    741          *
    742          * \param[in] InterfaceId the interface number
    743          * \param[in] data to be printed
    744          * \param[in] allowToBlock specify if the task will wait for the tx to finish or not.
    745          *
    746          * \return The status of the operation
    747          *
    748          ********************************************************************************** */
    749          serialStatus_t Serial_PrintBin( uint8_t InterfaceId, uint8_t *data, uint8_t len, serialBlock_t allowToBlock )
    750          {
    751          #if gSerialManagerMaxInterfaces_c
    752              if ( allowToBlock )
    753              {
    754                  return Serial_SyncWrite( InterfaceId, data, len );
    755              }
    756              else
    757              {
    758                  return Serial_AsyncWrite( InterfaceId, data, len, NULL, NULL );
    759              }
    760          #else
    761              (void)data;
    762              (void)allowToBlock;
    763              (void)InterfaceId;
    764              return gSerial_Success_c;
    765          #endif
    766          }
    767          
    768          /*! *********************************************************************************
    769          * \brief   Prints a string to the serial interface
    770          *
    771          * \param[in] InterfaceId the interface number
    772          * \param[in] pString pointer to the string to be printed
    773          * \param[in] allowToBlock specify if the task will wait for the tx to finish or not.
    774          *
    775          * \return The status of the operation
    776          *
    777          ********************************************************************************** */
    778          serialStatus_t Serial_Print( uint8_t InterfaceId, char* pString, serialBlock_t allowToBlock )
    779          {
    780          #if gSerialManagerMaxInterfaces_c
    781              if ( allowToBlock )
    782              {
    783                  return Serial_SyncWrite( InterfaceId, (uint8_t*)pString, strlen(pString) );
    784              }
    785              else
    786              {
    787                  return Serial_AsyncWrite( InterfaceId, (uint8_t*)pString, strlen(pString), NULL, NULL );
    788              }
    789          #else
    790              (void)pString;
    791              (void)allowToBlock;
    792              (void)InterfaceId;
    793              return gSerial_Success_c;
    794          #endif
    795          }
    796          
    797          /*! *********************************************************************************
    798          * \brief   Prints an number in hedadecimal format to the serial interface
    799          *
    800          * \param[in] InterfaceId the interface number
    801          * \param[in] hex pointer to the number to be printed
    802          * \param[in] len the number ob bytes of the number
    803          * \param[in] flags specify display options: comma, space, new line
    804          *
    805          * \return The status of the operation
    806          *
    807          * \remarks The task will waituntil the tx has finished
    808          *
    809          ********************************************************************************** */
    810          serialStatus_t Serial_PrintHex( uint8_t InterfaceId,
    811                                          uint8_t *hex,
    812                                          uint8_t len,
    813                                          uint8_t flags )
    814          {
    815          #if (gSerialManagerMaxInterfaces_c)
    816              uint8_t i=0;
    817              serialStatus_t status;
    818              uint8_t hexString[6]; /* 2 bytes  - hexadecimal display
    819              1 byte   - separator ( comma)
    820              1 byte   - separator ( space)
    821              2 bytes  - new line (\n\r)  */
    822          
    823              if ( !(flags & gPrtHexBigEndian_c) )
    824                  hex = hex + (len-1);
    825          
    826              while ( len )
    827              {
    828                  /* start preparing the print of a new byte */
    829                  i=0;
    830                  hexString[i++] = HexToAscii( (*hex)>>4 );
    831                  hexString[i++] = HexToAscii( *hex );
    832          
    833                  if ( flags & gPrtHexCommas_c )
    834                  {
    835                      hexString[i++] = ',';
    836                  }
    837                  if ( flags & gPrtHexSpaces_c )
    838                  {
    839                      hexString[i++] = ' ';
    840                  }
    841                  hex = hex + (flags & gPrtHexBigEndian_c ? 1 : -1);
    842                  len--;
    843          
    844                  if ( (len == 0) && (flags & gPrtHexNewLine_c) )
    845                  {
    846                      hexString[i++] = '\n';
    847                      hexString[i++] = '\r';
    848                  }
    849          
    850                  /* transmit formatted byte */
    851                  status = Serial_SyncWrite( InterfaceId, (uint8_t*)hexString, (uint8_t)i) ;
    852                  if ( gSerial_Success_c != status )
    853                      return status;
    854              }
    855          #else
    856              /* Avoid compiler warning */
    857              (void)hex;
    858              (void)len;
    859              (void)InterfaceId;
    860              (void)flags;
    861          #endif
    862              return gSerial_Success_c;
    863          }
    864          
    865          /*! *********************************************************************************
    866          * \brief   Prints an unsigned integer to the serial interface
    867          *
    868          * \param[in] InterfaceId the interface number
    869          * \param[in] nr the number to be printed
    870          *
    871          * \return The status of the operation
    872          *
    873          * \remarks The task will waituntil the tx has finished
    874          *
    875          ********************************************************************************** */
    876          serialStatus_t Serial_PrintDec( uint8_t InterfaceId, uint32_t nr )
    877          {
    878          #if (gSerialManagerMaxInterfaces_c)
    879          #define gDecStringLen_d 12
    880              uint8_t i = gDecStringLen_d-1;
    881              uint8_t decString[gDecStringLen_d];
    882          
    883              if ( nr == 0 )
    884              {
    885                  decString[i] = '0';
    886              }
    887              else
    888              {
    889                  while ( nr )
    890                  {
    891                      decString[i] = '0' + (uint8_t)(nr % 10);
    892                      nr = nr / 10;
    893                      i--;
    894                  }
    895                  i++;
    896              }
    897          
    898              /* transmit formatted byte */
    899              return Serial_SyncWrite( InterfaceId, (uint8_t*)&decString[i], gDecStringLen_d-i );
    900          #else
    901              (void)nr;
    902              (void)InterfaceId;
    903              return gSerial_Success_c;
    904          #endif
    905          }
    906          
    907          
    908          /*! *********************************************************************************
    909          * \brief   Configures the enabled hardware modules of the given interface type as a wakeup source from STOP mode
    910          *
    911          * \param[in] interface type of the modules to configure
    912          *
    913          * \return  gSerial_Success_c if there is at least one module to configure
    914          *          gSerial_InvalidInterface_c otherwise
    915          * \pre
    916          *
    917          * \post
    918          *
    919          * \remarks
    920          *
    921          ********************************************************************************** */
    922          
    923          serialStatus_t Serial_EnableLowPowerWakeup( serialInterfaceType_t interfaceType )
    924          {
    925              serialStatus_t status = gSerial_InvalidInterface_c;
    926          #if gSerialManagerMaxInterfaces_c
    927              if(interfaceType == gSerialMgrUart_c)
    928              {
    929                  UART_MemMapPtr uartMapPtr;
    930          #if (gSerialMgrUseUartA_c)
    931                  uartMapPtr = (UART_MemMapPtr)UARTA_PRPH_BASE_ADDRESS;
    932                  UART_BDH_REG(uartMapPtr)   &= ~(UART_BDH_RXEDGIE_MASK);
    933                  // clear RXEDGIF
    934                  UART_S2_REG(uartMapPtr)   = UART_S2_REG(uartMapPtr) & (~UART_S2_LBKDIF_MASK);
    935                  // enable Rx Active edge interrupt
    936                  UART_BDH_REG(uartMapPtr)   |= UART_BDH_RXEDGIE_MASK;
    937                  status = gSerial_Success_c;
    938          #endif
    939          
    940          #if (gSerialMgrUseUartB_c)
    941                  uartMapPtr = (UART_MemMapPtr)UARTB_PRPH_BASE_ADDRESS;
    942                  UART_BDH_REG(uartMapPtr)   &= ~(UART_BDH_RXEDGIE_MASK);
    943                  // clear RXEDGIF
    944                  UART_S2_REG(uartMapPtr)   = UART_S2_REG(uartMapPtr) & (~UART_S2_LBKDIF_MASK);
    945                  // enable Rx Active edge interrupt
    946                  UART_BDH_REG(uartMapPtr)   |= UART_BDH_RXEDGIE_MASK;
    947                  status = gSerial_Success_c;
    948          #endif
    949              }
    950          #else
    951              (void)interfaceType;
    952          #endif
    953              return status;
    954          }
    955          
    956          /*! *********************************************************************************
    957          * \brief   Configures the enabled hardware modules of the given interface type as modules without wakeup capabilities
    958          *
    959          * \param[in] interface type of the modules to configure
    960          *
    961          * \return  gSerial_Success_c if there is at least one module to configure
    962          *          gSerial_InvalidInterface_c otherwise
    963          * \pre
    964          *
    965          * \post
    966          *
    967          * \remarks
    968          *
    969          ********************************************************************************** */
    970          
    971          serialStatus_t Serial_DisableLowPowerWakeup( serialInterfaceType_t interfaceType)
    972          {
    973              serialStatus_t status = gSerial_InvalidInterface_c;
    974          #if gSerialManagerMaxInterfaces_c
    975              if(interfaceType == gSerialMgrUart_c)
    976              {
    977                  UART_MemMapPtr uartMapPtr;
    978          #if (gSerialMgrUseUartA_c)
    979                  uartMapPtr = (UART_MemMapPtr)UARTA_PRPH_BASE_ADDRESS;
    980                  UART_BDH_REG(uartMapPtr)  &= ~(UART_BDH_RXEDGIE_MASK);
    981                  UART_S2_REG(uartMapPtr)   = UART_S2_REG(uartMapPtr) & (~UART_S2_LBKDIF_MASK);
    982                  status = gSerial_Success_c;
    983          #endif
    984          
    985          #if (gSerialMgrUseUartB_c)
    986                  uartMapPtr = (UART_MemMapPtr)UARTB_PRPH_BASE_ADDRESS;
    987                  UART_BDH_REG(uartMapPtr)  &= ~(UART_BDH_RXEDGIE_MASK);
    988                  UART_S2_REG(uartMapPtr)   = UART_S2_REG(uartMapPtr) & (~UART_S2_LBKDIF_MASK);
    989                  status = gSerial_Success_c;
    990          #endif
    991              }
    992          #else
    993              (void)interfaceType;
    994          #endif
    995              return status;
    996          }
    997          
    998          /*! *********************************************************************************
    999          * \brief   Decides whether a enabled hardware module of the given interface type woke up the CPU from STOP mode.
   1000          *
   1001          * \param[in] interface type of the modules to be evaluated as wakeup source.
   1002          *
   1003          * \return  TRUE if a module of the given interface type was the wakeup source
   1004          *          FALSE otherwise
   1005          * \pre
   1006          *
   1007          * \post
   1008          *
   1009          * \remarks
   1010          *
   1011          ********************************************************************************** */
   1012          
   1013          bool_t Serial_IsWakeUpSource( serialInterfaceType_t interfaceType)
   1014          {
   1015              bool_t status = FALSE;
   1016          #if gSerialManagerMaxInterfaces_c
   1017              if(interfaceType == gSerialMgrUart_c)
   1018              {
   1019                  UART_MemMapPtr uartMapPtr;
   1020          #if (gSerialMgrUseUartA_c)
   1021                  uartMapPtr = (UART_MemMapPtr)UARTA_PRPH_BASE_ADDRESS;
   1022                  if( (UART_S2_REG(uartMapPtr) & UART_S2_RXEDGIF_MASK ) == UART_S2_RXEDGIF_MASK )
   1023                  {
   1024                      status = TRUE;
   1025                  }
   1026          #endif
   1027          
   1028          #if (gSerialMgrUseUartB_c)
   1029                  uartMapPtr = (UART_MemMapPtr)UARTB_PRPH_BASE_ADDRESS;
   1030                  if( (UART_S2_REG(uartMapPtr) & UART_S2_RXEDGIF_MASK ) == UART_S2_RXEDGIF_MASK )
   1031                  {
   1032                      status = TRUE;
   1033                  }
   1034          #endif
   1035              }
   1036          #else
   1037              (void)interfaceType;
   1038          #endif
   1039              return status;
   1040          }
   1041          
   1042          
   1043          /*! *********************************************************************************
   1044          *************************************************************************************
   1045          * Private functions
   1046          *************************************************************************************
   1047          ********************************************************************************* */
   1048          #if (gSerialManagerMaxInterfaces_c)
   1049          /*! *********************************************************************************
   1050          * \brief Transmit a data buffer to the specified interface.
   1051          *
   1052          * \param[in] InterfaceId the interface number
   1053          *
   1054          * \return The status of the operation
   1055          *
   1056          ********************************************************************************** */
   1057          serialStatus_t Serial_WriteInternal( uint8_t InterfaceId )
   1058          {
   1059              serial_t *pSer = &mSerials[InterfaceId];
   1060              uint16_t idx = pSer->txCurrent;
   1061              LDD_TError status = 0;
   1062          
   1063              (void)status;
   1064          
   1065              switch ( mSerials[InterfaceId].serialType )
   1066              {
   1067          #if (gSerialMgrUseUartA_c || gSerialMgrUseUartB_c)
   1068              case gSerialMgrUart_c:
   1069                  switch(mSerials[InterfaceId].serialChannel)
   1070                  {
   1071          #if gSerialMgrUseUartA_c
   1072                      case 1:
   1073                          status = UARTA_SendBlock( pSer->serialIf,
   1074                                                    pSer->txQueue[idx].pData,
   1075                                                    pSer->txQueue[idx].dataSize );
   1076                          break;
   1077          #endif
   1078          #if gSerialMgrUseUartB_c
   1079                      case 2:
   1080                          status = UARTB_SendBlock( pSer->serialIf,
   1081                                                    pSer->txQueue[idx].pData,
   1082                                                    pSer->txQueue[idx].dataSize );
   1083                          break;
   1084          #endif
   1085                      default:
   1086                          return gSerial_InvalidInterface_c;
   1087                  }
   1088                  if ( status == ERR_OK  )
   1089                  {
   1090                      return gSerial_Success_c;
   1091                  }
   1092                  else
   1093                  {
   1094                      return gSerial_InternalError_c;
   1095                  }
   1096                  break;
   1097          #endif
   1098          
   1099          #if gSerialMgrUseUSB_c
   1100              case gSerialMgrUSB_c:
   1101                  return serialWriteUsb( pSer->txQueue[idx].pData,
   1102                                         pSer->txQueue[idx].dataSize,
   1103                                         pSer );
   1104                  break;
   1105          #endif
   1106          
   1107          #if gSerialMgrUseIIC_c
   1108              case gSerialMgrIICMaster_c:
   1109                  switch(mSerials[InterfaceId].serialChannel)
   1110                  {
   1111                  case 1:
   1112                      status = I2CDriver_MasterSendBlock( pSer->serialIf,
   1113                                                          pSer->txQueue[idx].pData,
   1114                                                          pSer->txQueue[idx].dataSize,
   1115                                                          LDD_I2C_SEND_STOP);
   1116                      break;
   1117                  default:
   1118                      return gSerial_InvalidInterface_c;
   1119                  }
   1120                  if ( status == ERR_OK  )
   1121                  {
   1122                      return gSerial_Success_c;
   1123                  }
   1124                  else
   1125                  {
   1126                      return gSerial_InternalError_c;
   1127                  }
   1128                  break;
   1129              case gSerialMgrIICSlave_c:
   1130                  switch(pSer->serialChannel)
   1131                  {
   1132                  case 1:
   1133                      status = I2CDriver_SlaveSendBlock(pSer->serialIf,
   1134                                                  pSer->txQueue[idx].pData,
   1135                                                  pSer->txQueue[idx].dataSize);
   1136                      DataAvailablePin_SetFieldBits(NULL, DAP, 1);
   1137                      break;
   1138                  default:
   1139                      return gSerial_InvalidInterface_c;
   1140                  }
   1141                  if ( status == ERR_OK  )
   1142                  {
   1143                      return gSerial_Success_c;
   1144                  }
   1145                  else
   1146                  {
   1147                      return gSerial_InternalError_c;
   1148                  }
   1149                  break;
   1150          #endif
   1151          
   1152          #if gSerialMgrUseSPI_c
   1153              case gSerialMgrSPISlave_c:
   1154                  switch(pSer->serialChannel)
   1155                  {
   1156                  case 1:
   1157                      status = SPISlave_SendBlock(pSer->serialIf,
   1158                                                  pSer->txQueue[idx].pData,
   1159                                                  pSer->txQueue[idx].dataSize);
   1160                      DataAvailablePin_SetFieldBits(NULL, DAP, 1);
   1161                      break;
   1162                  default:
   1163                      return gSerial_InvalidInterface_c;
   1164                  }
   1165                  if ( status == ERR_OK  )
   1166                  {
   1167                      return gSerial_Success_c;
   1168                  }
   1169                  else
   1170                  {
   1171                      return gSerial_InternalError_c;
   1172                  }
   1173                  break;
   1174          #endif
   1175              default:
   1176                  return gSerial_InvalidInterface_c;
   1177              }
   1178          }
   1179          
   1180          /*! *********************************************************************************
   1181          * \brief Inform the Serial Manager task that new data is available
   1182          *
   1183          * \param[in] pData The id interface
   1184          *
   1185          * \return none
   1186          *
   1187          * \remarks Called from ISR
   1188          *
   1189          ********************************************************************************** */
   1190          void SerialManager_RxNotify( LDD_TUserData *pData )
   1191          {
   1192              uint32_t i = (uint32_t)pData;
   1193          
   1194              mSerial_IncIdx_d(mSerials[i].rxIn, gSerialMgrRxBufSize_c);
   1195          
   1196              //if ( mSerials[i].rxBytes < gSerialMgrRxBufSize_c )
   1197              {
   1198                  switch( mSerials[i].serialType )
   1199                  {
   1200                  case gSerialMgrUart_c:
   1201          #if (gSerialMgrUseUartA_c || gSerialMgrUseUartB_c)
   1202                      switch( mSerials[i].serialChannel )
   1203                      {
   1204          #if gSerialMgrUseUartA_c
   1205                      case 1:
   1206                          UARTA_ReceiveBlock( mSerials[i].serialIf, &mSerials[i].rxBuffer[mSerials[i].rxIn], 1 );
   1207                          break;
   1208          #endif
   1209          #if gSerialMgrUseUartB_c
   1210                      case 2:
   1211                          UARTB_ReceiveBlock( mSerials[i].serialIf, &mSerials[i].rxBuffer[mSerials[i].rxIn], 1 );
   1212                          break;
   1213          #endif
   1214                      default:
   1215                          break;
   1216                      }
   1217                      break;
   1218          #endif
   1219                  case gSerialMgrIICSlave_c:
   1220          #if (gSerialMgrUseIIC_c)
   1221                      switch(mSerials[i].serialChannel)
   1222                      {
   1223                      case 1:
   1224                          I2CDriver_SlaveReceiveBlock(mSerials[i].serialIf, &mSerials[i].rxBuffer[mSerials[i].rxIn], 1);
   1225                          break;
   1226                      default:
   1227                          break;
   1228                      }
   1229          #endif
   1230                      break;
   1231                  case gSerialMgrIICMaster_c:
   1232          #if (gSerialMgrUseIIC_c)
   1233          
   1234          #endif
   1235                      break;
   1236                  case gSerialMgrSPISlave_c:
   1237          #if (gSerialMgrUseSPI_c)
   1238                      switch(mSerials[i].serialChannel)
   1239                      {
   1240                      case 1:
   1241                          if(DataAvailablePin_GetFieldValue(NULL, DAP) != 0) /*discard Rxed chars during slave Tx*/
   1242                          {
   1243                              if ( mSerials[i].rxIn == 0 )
   1244                              {
   1245                                  mSerials[i].rxIn = gSerialMgrRxBufSize_c - 1;
   1246                              }
   1247                              else
   1248                              {
   1249                                  mSerials[i].rxIn--;
   1250                              }
   1251                          }
   1252                          SPISlave_ReceiveBlock(mSerials[i].serialIf, &mSerials[i].rxBuffer[mSerials[i].rxIn], 1);
   1253                          break;
   1254                      default:
   1255                          break;
   1256                      }
   1257          #endif
   1258                      break;
   1259          
   1260                  }
   1261              }
   1262          
   1263          #if (gSerialMgrUseSPI_c)
   1264              if( (mSerials[i].serialType == gSerialMgrSPISlave_c) &&
   1265                  (DataAvailablePin_GetFieldValue(NULL, DAP) == 1) )
   1266              {
   1267                /*discard Rxed chars during slave Tx*/
   1268                return;
   1269              }
   1270          #endif
   1271          
   1272              mSerials[i].flags |= gSMGR_Rx_c;
   1273              osSignalSet( gSerialManagerTaskId, gSMGR_Rx_c );
   1274          }
   1275          
   1276          /*! *********************************************************************************
   1277          * \brief Inform the Serial Manager task that a transmission has finished
   1278          *
   1279          * \param[in] pData the Id interface
   1280          *
   1281          * \return none
   1282          *
   1283          * \remarks Called from ISR
   1284          *
   1285          ********************************************************************************** */
   1286          void SerialManager_TxNotify( LDD_TUserData *pData )
   1287          {
   1288              volatile serial_t *pSer = &mSerials[(uint32_t)pData];
   1289              uint32_t idx = pSer->txCurrent;
   1290          
   1291              pSer->flags |= gSMGR_TxDone_c;
   1292              pSer->txQueue[idx].dataSize = 0; //Mark as transmitted
   1293              mSerial_IncIdx_d(idx, gSerialMgrTxQueueSize_c);
   1294          
   1295              /* Transmit next block if available */
   1296              if( idx != pSer->txIn )
   1297              {
   1298                  pSer->txCurrent = idx;
   1299                  if ( gSerial_Success_c != Serial_WriteInternal( (uint32_t)pData ) )
   1300                      pSer->txCurrent = gSerialMgrInvalidIdx_c;
   1301              }
   1302              else
   1303              {
   1304                  pSer->txCurrent = gSerialMgrInvalidIdx_c;
   1305          #if (gSerialMgrUseIIC_c)
   1306                  if( pSer->serialType == gSerialMgrIICSlave_c )
   1307                  {
   1308                      DataAvailablePin_ClearFieldBits( NULL, DAP, 1 );
   1309                  }
   1310          #endif
   1311          #if (gSerialMgrUseSPI_c)
   1312                  if( pSer->serialType == gSerialMgrSPISlave_c )
   1313                  {
   1314          //pbivol
   1315          //            static uint8_t sendDummyBytes=1;
   1316          //            static uint8_t dummyData[2] = {'^', '%'};
   1317          //
   1318          //            if(sendDummyBytes == 1)
   1319          //            {
   1320          //                SPISlave_SendBlock(mSerials[i].serialIf, dummyData, 2);
   1321          //                sendDummyBytes = 0;
   1322          //                return;
   1323          //            }
   1324          //            else
   1325          //            {
   1326          //                DataAvailablePin_ClearFieldBits(NULL, DAP, 1);
   1327          //                //SPISlave_CancelBlockTransmission(mSerials[i].serialIf);
   1328          //                sendDummyBytes = 1;
   1329          //            }
   1330          //            *((uint8_t *)(mSerials[i].serialIf)+14) = &"^%";
   1331          //            *((uint8_t *)(mSerials[i].serialIf)+18) = 2;
   1332                      DataAvailablePin_ClearFieldBits( NULL, DAP, 1 );
   1333                  }
   1334          #endif
   1335              }
   1336              osSignalSet( gSerialManagerTaskId, gSMGR_TxDone_c );
   1337          }
   1338          
   1339          /*! *********************************************************************************
   1340          * \brief Inform the Serial Manager task that the IIC transmission has finished
   1341          *
   1342          * \param[in] pData the interfaceId
   1343          *
   1344          * \return none
   1345          *
   1346          * \remarks Called from ISR
   1347          *
   1348          ********************************************************************************** */
   1349          #if (gSerialMgrUseIIC_c)
   1350          void SerialManager_IICErrorNotify( LDD_TUserData *pData )
   1351          {
   1352              uint32_t i = (uint32_t)pData;
   1353          
   1354              LDD_I2C_TErrorMask errorMask;
   1355              I2CDriver_GetError( mSerials[i].serialIf, &errorMask );
   1356          
   1357              switch(errorMask)
   1358              {
   1359                  case LDD_I2C_MASTER_NACK:
   1360                      SerialManager_TxNotify( (void*)i );
   1361                      break;
   1362                  default:
   1363                      break;
   1364              }
   1365          }
   1366          #endif
   1367          
   1368          /*! *********************************************************************************
   1369          * \brief Retrieve Rx data from internal SM buffer
   1370          *
   1371          * \param[in] InterfaceId the interface number
   1372          * \param[out] pData pointer to location where to store the characters
   1373          * \param[in] dataSize the number of characters to be read
   1374          *
   1375          * \return the number of characters retrieved
   1376          *
   1377          ********************************************************************************** */
   1378          uint16_t Serial_ReadInternal( uint8_t InterfaceId,
   1379                                       uint8_t *pData,
   1380                                       uint16_t dataSize )
   1381          {
   1382              uint16_t bytes;
   1383              serial_t *pSer = &mSerials[InterfaceId];
   1384          
   1385              Serial_RxBufferByteCount(InterfaceId, &bytes);
   1386          
   1387              if( bytes > 0 )
   1388              {
   1389                  uint16_t i;
   1390          
   1391                  if( bytes > dataSize )
   1392                      bytes = dataSize;
   1393          
   1394                  /* Copy data */
   1395                  for( i=0; i<bytes; i++ )
   1396                  {
   1397                      pData[i] = pSer->rxBuffer[pSer->rxOut++];
   1398                      if ( pSer->rxOut >= gSerialMgrRxBufSize_c )
   1399                      {
   1400                          pSer->rxOut = 0;
   1401                      }
   1402                  }
   1403              }
   1404          
   1405              return bytes;
   1406          }
   1407          
   1408          /*! *********************************************************************************
   1409          * \brief   Transmit a data buffer asynchronously
   1410          *
   1411          * \param[in] InterfaceId the interface number
   1412          * \param[in] pBuf pointer to data location
   1413          * \param[in] bufLen the number of bytes to be sent
   1414          * \param[in] pSerialRxCallBack pointer to a function that will be called when
   1415          *            a new char is available
   1416          * \param[in] pTxParam pointer to a parameter to be passed to the callback function
   1417          * \param[in] extraFlags Flags to be OR'ed.
   1418          *
   1419          * \return The status of the operation
   1420          *
   1421          ********************************************************************************** */
   1422          static inline serialStatus_t Serial_WriteCommon( uint8_t id,
   1423                                             uint8_t *pBuf,
   1424                                             uint16_t bufLen,
   1425                                             pSerialCallBack_t cb,
   1426                                             void *pTxParam,
   1427                                             uint8_t extraFlags)
   1428          {
   1429              SerialMsg_t *pMsg = NULL;
   1430              serial_t *pSer = &mSerials[id];
   1431              osThreadId taskId = osThreadGetId();
   1432          
   1433          #if gSerialMgr_ParamValidation_d
   1434              if( (NULL == pBuf) || (0 == bufLen) ||
   1435                  (id >= gSerialManagerMaxInterfaces_c) ||
   1436                  (pSer->serialType == gSerialMgrNone_c) )
   1437              {
   1438                  return gSerial_InvalidParameter_c;
   1439              }
   1440          #endif
   1441          
   1442              if( taskId == gSerialManagerTaskId )
   1443                  Serial_TxQueueMaintenance(pSer);
   1444          
   1445          #if gSerialMgr_BlockSenderOnQueueFull_c
   1446              if( pSer->txQueue[pSer->txIn].flags )
   1447              {
   1448                  if( taskId != gSerialManagerTaskId )
   1449                  {
   1450                      pSer->txBlockedTasks++;
   1451                      osSemaphoreWait( pSer->txQueueSem, osWaitForever );
   1452                  }
   1453                  else
   1454                  {
   1455                      while( pSer->txQueue[pSer->txIn].flags )
   1456                          Serial_TxQueueMaintenance(pSer);
   1457                  }
   1458              }
   1459          #endif
   1460          
   1461              /* Check if slot is free */
   1462              osInterruptDisable();
   1463              if( 0 == pSer->txQueue[pSer->txIn].flags )
   1464              {
   1465                  pMsg = &pSer->txQueue[pSer->txIn];
   1466                  pMsg->flags      = gSerialMgrBufferInUse_c | extraFlags;
   1467                  pMsg->dataSize   = bufLen;
   1468                  pMsg->pData      = (void*)pBuf;
   1469                  pMsg->txCallback = cb;
   1470                  pMsg->pTxParam   = pTxParam;
   1471                  mSerial_IncIdx_d(pSer->txIn, gSerialMgrTxQueueSize_c);
   1472              }
   1473              osInterruptEnable();
   1474          
   1475              if( pMsg )
   1476              {
   1477                  /* If interface is Idle, start Tx asap */
   1478                  if( pSer->txCurrent == gSerialMgrInvalidIdx_c )
   1479                  {
   1480                      pSer->txCurrent = pSer->txOut;
   1481                      if ( gSerial_Success_c != Serial_WriteInternal( id ) )
   1482                      {
   1483                          SerialManager_TxNotify( (LDD_TUserData *)id );
   1484                      }
   1485                  }
   1486                  else
   1487                  {
   1488                      osSignalSet( gSerialManagerTaskId, gSMGR_TxNew_c );
   1489                  }
   1490                  return gSerial_Success_c;
   1491              }
   1492          
   1493              return gSerial_OutOfMemory_c;
   1494          }
   1495          
   1496          /*! *********************************************************************************
   1497          * \brief   This function will mark all finished TX queue entries as empty.
   1498          *          If a calback was provided, it will be run.
   1499          *
   1500          * \param[in] pSer pointer to the serial interface internal structure
   1501          *
   1502          ********************************************************************************** */
   1503          static void Serial_TxQueueMaintenance(serial_t *pSer)
   1504          {
   1505              while( (pSer->txQueue[pSer->txOut].flags & gSerialMgrBufferInUse_c) &&
   1506                     (pSer->txQueue[pSer->txOut].dataSize == 0) )
   1507              {
   1508                  pSer->txQueue[pSer->txOut].flags &= ~gSerialMgrBufferInUse_c;
   1509          
   1510                  /* Run Calback */
   1511                  if( pSer->txQueue[pSer->txOut].txCallback )
   1512                  {
   1513                      pSer->txQueue[pSer->txOut].txCallback( pSer->txQueue[pSer->txOut].pTxParam );
   1514                  }
   1515          
   1516                  /* If this was a SyncWrite, release the semaphore */
   1517                  if( pSer->txQueue[pSer->txOut].flags & gSerialMgrSyncTx_c )
   1518                  {
   1519                      osSemaphoreRelease( pSer->txSyncSem );
   1520                  }
   1521          
   1522                  /* Mark buffer as unused */
   1523                  pSer->txQueue[pSer->txOut].flags = 0;
   1524          
   1525                  mSerial_IncIdx_d(pSer->txOut, gSerialMgrTxQueueSize_c);
   1526          #if gSerialMgr_BlockSenderOnQueueFull_c
   1527                  if( pSer->txBlockedTasks )
   1528                  {
   1529                      pSer->txBlockedTasks--;
   1530                      osSemaphoreRelease( pSer->txQueueSem );
   1531                  }
   1532          #endif
   1533              }
   1534          }
   1535          
   1536          #endif //#if (gSerialManagerMaxInterfaces_c)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   SerialManagerTask
        40   -- Indirect call
        40   -> SerialManager_TxNotify
        40   -> Serial_TxQueueMaintenance
        40   -> Serial_WriteInternal
        40   -> osInterruptDisable
        40   -> osInterruptEnable
        40   -> osSignalWait
       8   SerialManager_Init
         8   -> FLib_MemSet
         8   -> osThreadCreate
      24   SerialManager_RxNotify
        24   -> UARTA_ReceiveBlock
        24   -> osSignalSet
      16   SerialManager_TxNotify
        16   -> Serial_WriteInternal
        16   -> osSignalSet
      32   Serial_AsyncWrite
        32   -> Serial_WriteCommon
       8   Serial_DisableLowPowerWakeup
       8   Serial_EnableLowPowerWakeup
      40   Serial_InitInterface
        40   -> UARTA_Init
        40   -> UARTA_ReceiveBlock
        40   -> osSemaphoreCreate
       4   Serial_IsWakeUpSource
      24   Serial_Print
        24   -> Serial_AsyncWrite
        24   -> Serial_SyncWrite
        24   -> strlen
      24   Serial_PrintBin
        24   -> Serial_AsyncWrite
        24   -> Serial_SyncWrite
      32   Serial_PrintDec
        32   -> Serial_SyncWrite
        32 __aeabi_uidiv
        32 __aeabi_uidivmod
      40   Serial_PrintHex
        40   -> Serial_SyncWrite
      24   Serial_Read
        24   -> Serial_ReadInternal
      24   Serial_ReadInternal
        24   -> Serial_RxBufferByteCount
      12   Serial_RxBufferByteCount
      16   Serial_SetBaudRate
        16   -> UARTA_SelectBaudRate
      12   Serial_SetRxCallBack
      40   Serial_SyncWrite
        40   -> Serial_WriteCommon
        40   -> osSemaphoreWait
        40   -> osThreadGetId
       8   Serial_TxQueueMaintenance
         8   -- Indirect call
         8   -> osSemaphoreRelease
      40   Serial_WriteCommon
        40   -> SerialManager_TxNotify
        40   -> Serial_TxQueueMaintenance
        40   -> Serial_WriteInternal
        40   -> osInterruptDisable
        40   -> osInterruptEnable
        40   -> osSemaphoreWait
        40   -> osSignalSet
        40   -> osThreadGetId
      24   Serial_WriteInternal
        24   -> UARTA_SendBlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable7
       4  ??DataTable7_1
      20  ?_0
     304  SerialManagerTask
      46  SerialManager_Init
     164  SerialManager_RxNotify
     104  SerialManager_TxNotify
      36  Serial_AsyncWrite
      40  Serial_DisableLowPowerWakeup
      48  Serial_EnableLowPowerWakeup
     344  Serial_InitInterface
      30  Serial_IsWakeUpSource
      66  Serial_Print
      60  Serial_PrintBin
      92  Serial_PrintDec
     224  Serial_PrintHex
      82  Serial_Read
     112  Serial_ReadInternal
     108  Serial_RxBufferByteCount
     208  Serial_SetBaudRate
      46  Serial_SetRxCallBack
     132  Serial_SyncWrite
     210  Serial_TxQueueMaintenance
     310  Serial_WriteCommon
     112  Serial_WriteInternal
       4  gSerialManagerTaskId
     256  mSerials
      28  osThreadLink_SerialManagerTask
      36  osThread_SerialManagerTask_signal
     700  osThread_SerialManagerTask_stack
      32  os_thread_def_SerialManagerTask

 
 1'024 bytes in section .bss
    32 bytes in section .data
    20 bytes in section .rodata
 2'926 bytes in section .text
 
 2'926 bytes of CODE  memory
    20 bytes of CONST memory
 1'056 bytes of DATA  memory

Errors: none
Warnings: 2
