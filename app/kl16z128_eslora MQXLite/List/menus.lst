###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         14/May/2020  16:51:00
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\menus.c
#    Command line      =
#        -f C:\Users\81901\AppData\Local\Temp\EW5978.tmp
#        (C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\menus.c
#        --preprocess=s
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -lcN
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -o
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\include\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\config\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\compiler\iar\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Generated_Code\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\PExSupport\Kinetis\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\OSAbstraction\MQXLite\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Common\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\Lists\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\FunctionLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\SecLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Panic\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\SerialManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\MemManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Messaging\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\Phy\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\SMAC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\ADC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\BME\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Flash\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\I2C\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LED\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LLWU\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LPTMR\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\SMC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\MCG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Reset\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List\menus.lst
#    Object file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj\menus.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\menus.c
      1          /*****************************************************************************
      2          * Menus file.
      3          *
      4          * (c) Copyright 2016, EASEL, Inc.  All rights reserved.
      5          *
      6          * No part of this document may be reproduced in any form - including copied,
      7          * transcribed, printed or by any electronic means - without specific written
      8          * permission from EASEL.
      9          *
     10          *****************************************************************************/
     11          
     12          #include <string.h>
     13          #include "Application_Interface.h"
     14          #include "flash.h"
     15          #include "usr_tasks.h"
     16          #include "menus.h"
     17          #include "mqxlite.h"
     18          
     19          
     20          /************************************************************************************
     21          *************************************************************************************
     22          * Private macros
     23          *************************************************************************************
     24          ************************************************************************************/
     25          #define MIN_CHANNEL         1
     26          #define MAX_CHANNEL_MODE1   15
     27          #define MAX_CHANNEL_MODE2   7
     28          #define MAX_CHANNEL_MODE3   5
     29          #define MIN_POWER           -4
     30          #define MAX_POWER           13
     31          
     32          #define SOFTWARE_VERSION    "VER 1.12"
     33          
     34          
     35          /************************************************************************************
     36          *************************************************************************************
     37          * Private prototypes
     38          *************************************************************************************
     39          ************************************************************************************/
     40          static uint8_t SelectMode( void );
     41          static void PrintMessage( uint8_t* const pu8Menu[] );
     42          static void CommShowModeSel( void );
     43          static void CommShowPrompt( void );
     44          
     45          static void CommExecSelectNode( int, int );
     46          static void CommExecSelectBandWidth( int, int );
     47          static void CommExecSetSpreadingFactor( int, int );
     48          static void CommExecSetChannel( int, int );
     49          static void CommExecSetPanId( int, int );
     50          static void CommExecSetSourceId( int, int );
     51          static void CommExecSetDestinationId( int, int );
     52          #ifdef _STATIC_ROUTING_
     53          static void CommExecSetHopCount( int, int );
     54          static void CommExecSetEndId( int, int );
     55          static void CommExecSetRoute1( int, int );
     56          static void CommExecSetRoute2( int, int );
     57          static void CommExecSetRoute( int, int, int );
     58          #endif
     59          static void CommExecSetAck( int, int );
     60          static void CommExecSetRetry( int, int );
     61          static void CommExecSelectTransMode( int, int );
     62          static void CommExecSelectRcvId( int, int );
     63          static void CommExecSelectRssi( int, int );
     64          static void CommExecSelectOperation( int, int );
     65          static void CommExecSelectBaudrate( int, int );
     66          static void CommExecSelectSleep( int, int );
     67          static void CommExecSetSleepTime( int, int );
     68          static void CommExecSetPower( int, int );
     69          static void CommExecSetFormat( int, int );
     70          static void CommExecSetSendTime( int, int );
     71          static void CommExecSetSendData( int, int );
     72          static void CommExecVersion( int, int );
     73          static void CommExecSaveParameter( int, int );
     74          static void CommExecLoadParameter( int, int );
     75          static void CommExecShow( int, int );
     76          static void CommExecHelp( int, int );
     77          
     78          
     79          /************************************************************************************
     80          *************************************************************************************
     81          * Private memory declarations
     82          *************************************************************************************
     83          ************************************************************************************/
     84          static uint8_t const cu8ModeSel[] = { "Select Mode [1.terminal or 2.processor]" };
     85          static uint8_t const cu8Prompt[]  = { "LORA > " };
     86          static uint8_t const cu8Version[] = { SOFTWARE_VERSION };
     87          
     88          uint8_t* const cu8Logo[] = {
     89              "\r\n",
     90              "\r\n",
     91              "\r Software Version : ",
     92              SOFTWARE_VERSION,
     93              "\r\n",
     94              NULL
     95          };
     96          
     97          uint8_t* const cu8MainMenu[] = {
     98              "\r\n\r Configuration Mode\n",
     99              "\r------------------------------------------\n",
    100          #ifdef _STATIC_ROUTING_
    101              "\r a. node        select Coordinator or EndDevice or Router\n",
    102          #else
    103              "\r a. node        select Coordinator or EndDevice\n",
    104          #endif
    105              "\r b. bw          select Band Width\n",
    106              "\r c. sf          set Spreading Factor\n",
    107              "\r d. channel     set channel\n",
    108              "\r e. panid       set PAN ID\n",
    109              "\r f. ownid       set Own Node ID\n",
    110              "\r g. dstid       set Destination ID\n",
    111          #ifdef _STATIC_ROUTING_
    112              "\r h. hopcount    set Hop Count\n",
    113              "\r i. endid       set End ID\n",
    114              "\r j. route1      set 1st Router ID\n",
    115              "\r k. route2      set 2nd Router ID\n",
    116          #endif
    117              "\r l. ack         set Acknowledge Mode\n",
    118              "\r m. retry       set send retry count\n",
    119              "\r n. transmode   select Transfer Mode\n",
    120              "\r o. rcvid       set received Node ID information\n",
    121              "\r p. rssi        set RSSI information\n",
    122              "\r q. operation   select Configuration or Operation\n",
    123              "\r r. baudrate    select UART baudrate\n",
    124              "\r s. sleep       select Sleep Mode\n",
    125              "\r t. sleeptime   set Sleep Wakeup Timer value\n",
    126              "\r u. power       set Output Power\n",
    127              "\r v. version     software version\n",
    128              "\r w. save        save parameters\n",
    129              "\r x. load        load default parameters\n",
    130              "\r y. show        show parameters\n",
    131              "\r z. start       Transite Operation\n",
    132              "\r A. format      set Data Format\n",
    133              "\r B. sendtime    set test send interval\n",
    134              "\r C. senddata    set test send data\n",
    135              "\r ?. help        help\n",
    136              "\r\n",
    137              NULL
    138          };
    139          
    140          uint8_t* const cuOnOffMenu[] = {
    141              "\r\n  1. ON",
    142              "\r\n  2. OFF",
    143              "\r\n",
    144              "\r\n  select number > ",
    145              NULL
    146          };
    147          
    148          uint8_t* const cuBaudrateMenu[] = {
    149              "\r\n  1. 9600",
    150              "\r\n  2. 19200",
    151              "\r\n  3. 38400",
    152              "\r\n  4. 57600",
    153              "\r\n  5. 115200",
    154              "\r\n  6. 230400",
    155              "\r\n",
    156              "\r\n  select number > ",
    157              NULL
    158          };
    159          
    160          uint8_t* const cuNodeMenu[] = {
    161              "\r\n  1. Coordinator",
    162              "\r\n  2. EndDevice",
    163          #ifdef _STATIC_ROUTING_
    164              "\r\n  3. Router",
    165          #endif
    166              "\r\n",
    167              "\r\n  select number > ",
    168              NULL
    169          };
    170          
    171          uint8_t* const cuOperationMenu[] = {
    172              "\r\n  1. Configuration",
    173              "\r\n  2. Operation",
    174              "\r\n",
    175              "\r\n  select number > ",
    176              NULL
    177          };
    178          
    179          uint8_t* const cuBwMenu[] = {
    180          #if 0
    181              "\r\n  1. 31.25kHz",
    182              "\r\n  2. 41.7kHz",
    183          #endif
    184              "\r\n  3. 62.5kHz",
    185              "\r\n  4. 125kHz",
    186              "\r\n  5. 250kHz",
    187              "\r\n  6. 500kHz",
    188              "\r\n",
    189              "\r\n  select number > ",
    190              NULL
    191          };
    192          
    193          uint8_t* const cuSleepMenu[] = {
    194              "\r\n  1. No Sleep",
    195              "\r\n  2. Timer Wakeup",
    196              "\r\n  3. INT Wakeup",
    197              "\r\n",
    198              "\r\n  select number > ",
    199              NULL
    200          };
    201          
    202          uint8_t* const cuTransMenu[] = {
    203              "\r\n  1. Payload",
    204              "\r\n  2. Frame",
    205              "\r\n",
    206              "\r\n  select number > ",
    207              NULL
    208          };
    209          
    210          uint8_t* const cuFormatMenu[] = {
    211              "\r\n  1. ASCII",
    212              "\r\n  2. BINARY",
    213              "\r\n",
    214              "\r\n  select number > ",
    215              NULL
    216          };
    217          
    218          struct
    219          {
    220              char    sname[4];
    221              char    name[12];
    222              void    (*func)(int, int);
    223          } const command1[] = {
    224                            { "a"     , "node"        , CommExecSelectNode         },   // 1
    225                            { "b"     , "bw"          , CommExecSelectBandWidth    },   // 2
    226                            { "c"     , "sf"          , CommExecSetSpreadingFactor },   // 3
    227                            { "d"     , "channel"     , CommExecSetChannel         },   // 4
    228                            { "e"     , "panid"       , CommExecSetPanId           },   // 5
    229                            { "f"     , "ownid"       , CommExecSetSourceId        },   // 6
    230                            { "g"     , "dstid"       , CommExecSetDestinationId   },   // 7
    231          #ifdef _STATIC_ROUTING_
    232                            { "h"     , "hopcount"    , CommExecSetHopCount        },   // 8
    233                            { "i"     , "endid"       , CommExecSetEndId           },   // 9
    234                            { "j"     , "route1"      , CommExecSetRoute1          },   // 10
    235                            { "k"     , "route2"      , CommExecSetRoute2          },   // 11
    236          #endif
    237                            { "l"     , "ack"         , CommExecSetAck             },   // 12
    238                            { "m"     , "retry"       , CommExecSetRetry           },   // 13
    239                            { "n"     , "transmode"   , CommExecSelectTransMode    },   // 14
    240                            { "o"     , "rcvid"       , CommExecSelectRcvId        },   // 15
    241                            { "p"     , "rssi"        , CommExecSelectRssi         },   // 16
    242                            { "q"     , "operation"   , CommExecSelectOperation    },   // 17
    243                            { "r"     , "baudrate"    , CommExecSelectBaudrate     },   // 18
    244                            { "s"     , "sleep"       , CommExecSelectSleep        },   // 19
    245                            { "t"     , "sleeptime"   , CommExecSetSleepTime       },   // 20
    246                            { "u"     , "power"       , CommExecSetPower           },   // 21
    247                            { "v"     , "version"     , CommExecVersion            },   // 22
    248                            { "w"     , "save"        , CommExecSaveParameter      },   // 23
    249                            { "x"     , "load"        , CommExecLoadParameter      },   // 24
    250                            { "y"     , "show"        , CommExecShow               },   // 25
    251                            { "A"     , "format"      , CommExecSetFormat          },   //
    252                            { "B"     , "sendtime"    , CommExecSetSendTime        },   //
    253                            { "C"     , "senddata"    , CommExecSetSendData        },   //
    254                            { "?"     , "help"        , CommExecHelp               },   // 26
    255                            { "\0"    , "\0"          , 0                          }
    256                        };
    257          
    258          
    259          /************************************************************************************
    260          *************************************************************************************
    261          * Interface functions
    262          *************************************************************************************
    263          ************************************************************************************/
    264          void IsChar( void )
    265          {
    266              while( !evDataFromUART )
    267              {
    268                  WDG_Refresh();
    269              }
    270              evDataFromUART = FALSE;
    271          }
    272          
    273          /***********************************************************************************
    274          * DoConfiguration
    275          *
    276          * Interface assumptions:
    277          *     None
    278          *
    279          * Return value:
    280          *     None
    281          *
    282          ************************************************************************************/
    283          void DoConfiguration( void )
    284          {
    285              int32_t i;
    286              int     ret;
    287              uint8_t mode;
    288              uint8_t tmpcmd[16];
    289          
    290          
    291              mode = SelectMode();
    292              if( TERMINAL == mode )
    293              {
    294                  PrintMessage( cu8Logo );
    295                  PrintMessage( cu8MainMenu );
    296              }
    297          
    298              tmpcmd[15] = 0;
    299          
    300              while( 1 )
    301              {
    302                  WDG_Refresh();
    303          
    304                  CommShowPrompt();
    305          
    306                  IsChar();
    307          
    308                  for( i = 0; i < 15; i++ )
    309                  {
    310                      if( ('\0' == CommDataBuffer[i]) || (' ' == CommDataBuffer[i]) )
    311                      {
    312                          tmpcmd[i] = '\0';
    313                          break;
    314                      }
    315                      else
    316                      {
    317                          tmpcmd[i] = CommDataBuffer[i];
    318                      }
    319                  }
    320          
    321                  for( i = 0; command1[i].func != 0; i++ )
    322                  {
    323                      ret = strcmp( command1[i].name, (char*)tmpcmd );
    324                      if( 0 == ret )
    325                      {
    326                          command1[i].func( i, strlen(command1[i].name) );
    327                          break;
    328                      }
    329          
    330                      ret = strcmp( command1[i].sname, (char*)tmpcmd );
    331                      if( 0 == ret )
    332                      {
    333                          command1[i].func( i, strlen(command1[i].sname) );
    334                          break;
    335                      }
    336                  }
    337          
    338                  if( 0 == strcmp( "start", (char*)CommDataBuffer ) )
    339                  {
    340                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    341                      return;
    342                  }
    343          
    344                  if( 0 == strcmp( "z", (char*)CommDataBuffer ) )
    345                  {
    346                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    347                      return;
    348                  }
    349          
    350                  if( (0 == command1[i].func) && (PROCESSOR == mTermParam.Mode) )
    351                  {
    352                      Serial_Print( mAppSer, "NG 001\r\n", gAllowToBlock_d );
    353                  }
    354              }
    355          }
    356          
    357          /***********************************************************************************
    358          * CommRxCallBack
    359          *
    360          * Interface assumptions:
    361          *     None
    362          *
    363          * Return value:
    364          *     None
    365          *
    366          ************************************************************************************/
    367          void CommRxCallBack( void* param )
    368          {
    369              uint16_t readBytes;
    370          
    371              while( gSerial_Success_c == Serial_GetByteFromRxBuffer(mAppSer, &CommDataBuffer[CommDataIndex], &readBytes) )
    372              {
    373                  if( 0 == readBytes )
    374                  {
    375                      break;
    376                  }
    377          
    378                  if( ('\r' == CommDataBuffer[CommDataIndex-1]) && ('\n' == CommDataBuffer[CommDataIndex]) )
    379                  {
    380                      CommDataBuffer[CommDataIndex-1] = '\0';
    381                      CommDataBuffer[CommDataIndex]   = '\0';
    382          
    383                      CommDataIndex = 0;
    384          
    385                      evDataFromUART = TRUE;
    386                  }
    387                  else if( '\b' == CommDataBuffer[CommDataIndex] )
    388                  {
    389                      CommDataBuffer[CommDataIndex] = '\0';
    390          
    391                      if( 0 < CommDataIndex )
    392                      {
    393                          CommDataIndex--;
    394                          CommDataBuffer[CommDataIndex] = '\0';
    395                      }
    396                  }
    397                  else
    398                  {
    399                      CommDataIndex++;
    400                      if( MAX_COMM_SIZE <= CommDataIndex )
    401                      {
    402                          CommDataIndex = 0;
    403                      }
    404                  }
    405              }
    406          }
    407          
    408          
    409          /************************************************************************************
    410          *************************************************************************************
    411          * private functions
    412          *************************************************************************************
    413          ************************************************************************************/
    414          
    415          /***********************************************************************************
    416          * SelectMode
    417          *
    418          * Interface assumptions:
    419          *     None
    420          *
    421          * Return value:
    422          *     Mode      Terminal or Processor
    423          *
    424          ************************************************************************************/
    425          static uint8_t SelectMode( void )
    426          {
    427              int     ret;
    428          
    429          
    430              CommShowModeSel();
    431          
    432              /* wait terminal or processor */
    433              while( 1 )
    434              {
    435                  IsChar();
    436          
    437                  ret = strcmp( "terminal", (char*)CommDataBuffer );
    438                  if( 0 == ret )
    439                  {
    440                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    441                      mTermParam.Mode = TERMINAL;
    442                      break;
    443                  }
    444          
    445                  ret = strcmp( "processor", (char*)CommDataBuffer );
    446                  if( 0 == ret )
    447                  {
    448                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    449                      mTermParam.Mode = PROCESSOR;
    450                      break;
    451                  }
    452          
    453                  ret = strcmp( "1", (char*)CommDataBuffer );
    454                  if( 0 == ret )
    455                  {
    456                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    457                      mTermParam.Mode = TERMINAL;
    458                      break;
    459                  }
    460          
    461                  ret = strcmp( "2", (char*)CommDataBuffer );
    462                  if( 0 == ret )
    463                  {
    464                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    465                      mTermParam.Mode = PROCESSOR;
    466                      break;
    467                  }
    468          
    469                  Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
    470              }
    471          
    472              return( mTermParam.Mode );
    473          }
    474          
    475          /***********************************************************************************
    476          * PrintMessage
    477          *
    478          * Interface assumptions:
    479          *     pu8Menu       print message
    480          *
    481          * Return value:
    482          *     None
    483          *
    484          ************************************************************************************/
    485          static void PrintMessage( uint8_t* const pu8Menu[] )
    486          {
    487              uint8_t u8Index = 0;
    488          
    489              while( pu8Menu[u8Index] )
    490              {
    491                  WDG_Refresh();
    492                  Serial_Print( mAppSer, (char*)pu8Menu[u8Index], gAllowToBlock_d );
    493                  u8Index++;
    494              }
    495          }
    496          
    497          /***********************************************************************************
    498          * CommShowModeSel
    499          *
    500          * Interface assumptions:
    501          *     None
    502          *
    503          * Return value:
    504          *     None
    505          *
    506          ************************************************************************************/
    507          static void CommShowModeSel( void )
    508          {
    509              Serial_Print( mAppSer, "\r\n", gAllowToBlock_d );
    510              Serial_Print( mAppSer, (char*)cu8ModeSel, gAllowToBlock_d );
    511              Serial_Print( mAppSer, "\r\n", gAllowToBlock_d );
    512          }
    513          
    514          /***********************************************************************************
    515          * CommShowPrompt
    516          *
    517          * Interface assumptions:
    518          *     None
    519          *
    520          * Return value:
    521          *     None
    522          *
    523          ************************************************************************************/
    524          static void CommShowPrompt( void )
    525          {
    526              uint8_t u8lineLen = 20;
    527              uint8_t u8Index;
    528          
    529          
    530              /* Erase old line */
    531              if( TERMINAL == mTermParam.Mode )
    532              {
    533                  for( u8Index = 0; u8Index < u8lineLen; u8Index++ )
    534                  {
    535                      Serial_Print( mAppSer, "\b", gAllowToBlock_d );
    536                  }
    537                  for( u8Index = 0; u8Index < u8lineLen; u8Index++ )
    538                  {
    539                      Serial_Print( mAppSer, " ", gAllowToBlock_d );
    540                  }
    541                  for( u8Index = 0; u8Index < u8lineLen; u8Index++ )
    542                  {
    543                      Serial_Print( mAppSer, "\b", gAllowToBlock_d );
    544                  }
    545          
    546                  Serial_Print( mAppSer, (char*)cu8Prompt, gAllowToBlock_d );
    547              }
    548          }
    549          
    550          /***********************************************************************************
    551          * CommExecSelectNode
    552          *
    553          * Interface assumptions:
    554          *     index         command index
    555          *     nameLen       command name length
    556          *
    557          * Return value:
    558          *     None
    559          *
    560          ************************************************************************************/
    561          static void CommExecSelectNode( int index, int nameLen )
    562          {
    563              uint8_t tmpMode = 0;
    564          
    565          
    566              /* terminal mode */
    567              if( TERMINAL == mTermParam.Mode )
    568              {
    569                  PrintMessage( cuNodeMenu );
    570          
    571                  IsChar();
    572          
    573                  if( isAsciiHex(CommDataBuffer[0]) )
    574                  {
    575                      tmpMode = AsciiToHex( CommDataBuffer[0] );
    576                  }
    577          
    578                  switch( tmpMode )
    579                  {
    580                  case COORDINATOR:
    581                      mTermParam.Node = COORDINATOR;
    582                      Serial_Print( mAppSer, "\r\n  Coordinator is selected.", gAllowToBlock_d );
    583                      break;
    584          
    585                  case END_DEVICE:
    586                      mTermParam.Node = END_DEVICE;
    587                      Serial_Print( mAppSer, "\r\n  EndDevice is selected.", gAllowToBlock_d );
    588                      break;
    589          
    590          #ifdef _STATIC_ROUTING_
    591                  case ROUTER:
    592                      mTermParam.Node = ROUTER;
    593                      Serial_Print( mAppSer, "\r\n  Router is selected.", gAllowToBlock_d );
    594                      break;
    595          #endif
    596          
    597                  default:
    598                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
    599                      break;
    600                  }
    601          
    602                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
    603              }
    604              /* processor mode */
    605              else
    606              {
    607                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
    608                  {
    609                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
    610                  }
    611          
    612          #ifdef _STATIC_ROUTING_
    613                  if( (COORDINATOR == tmpMode) || (END_DEVICE == tmpMode) || (ROUTER == tmpMode) )
    614          #else
    615                  if( (COORDINATOR == tmpMode) || (END_DEVICE == tmpMode) )
    616          #endif
    617                  {
    618                      mTermParam.Node = tmpMode;
    619          
    620                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    621                  }
    622                  else
    623                  {
    624                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
    625                  }
    626              }
    627          }
    628          
    629          /***********************************************************************************
    630          * CommExecSelectBandWidth
    631          *
    632          * Interface assumptions:
    633          *     index         command index
    634          *     nameLen       command name length
    635          *
    636          * Return value:
    637          *     None
    638          *
    639          ************************************************************************************/
    640          static void CommExecSelectBandWidth( int index, int nameLen )
    641          {
    642              uint8_t maxChannel = 0;
    643              uint8_t tmpBw = 0;
    644              uint8_t findIndex;
    645          
    646          
    647              /* terminal mode */
    648              if( TERMINAL == mTermParam.Mode )
    649              {
    650                  PrintMessage( cuBwMenu );
    651          
    652                  IsChar();
    653          
    654                  for( findIndex = 0; findIndex < 2; findIndex++ )
    655                  {
    656                      if( isAsciiDec(CommDataBuffer[findIndex]) )
    657                      {
    658                          tmpBw += AsciiToDec( CommDataBuffer[findIndex] );
    659                      }
    660                      else
    661                      {
    662                          tmpBw = 0xff;
    663                          break;
    664                      }
    665          
    666                      if( '\0' == CommDataBuffer[findIndex+1] )
    667                      {
    668                          break;
    669                      }
    670          
    671                      tmpBw *= 10;
    672                  }
    673          
    674                  switch( tmpBw )
    675                  {
    676          #if 0
    677                  case 1:
    678                      mTermParam.Bw = BANDWIDTH31_25;
    679                      maxChannel    = MAX_CHANNEL_MODE1;
    680                      Serial_Print( mAppSer, "\r\n  31.25kHz is selected.", gAllowToBlock_d );
    681                      break;
    682          
    683                  case 2:
    684                      mTermParam.Bw = BANDWIDTH41_7;
    685                      maxChannel    = MAX_CHANNEL_MODE1;
    686                      Serial_Print( mAppSer, "\r\n  41.7kHz is selected.", gAllowToBlock_d );
    687                      break;
    688          #endif
    689                  case 3:
    690                      mTermParam.Bw = BANDWIDTH62_5;
    691                      maxChannel    = MAX_CHANNEL_MODE1;
    692                      Serial_Print( mAppSer, "\r\n  62.5kHz is selected.", gAllowToBlock_d );
    693                      break;
    694          
    695                  case 4:
    696                      mTermParam.Bw = BANDWIDTH125;
    697                      maxChannel    = MAX_CHANNEL_MODE1;
    698                      Serial_Print( mAppSer, "\r\n  125kHz is selected.", gAllowToBlock_d );
    699                      break;
    700          
    701                  case 5:
    702                      mTermParam.Bw = BANDWIDTH250;
    703                      maxChannel    = MAX_CHANNEL_MODE2;
    704                      Serial_Print( mAppSer, "\r\n  250kHz is selected.", gAllowToBlock_d );
    705                      break;
    706          
    707                  case 6:
    708                      mTermParam.Bw = BANDWIDTH500;
    709                      maxChannel    = MAX_CHANNEL_MODE3;
    710                      Serial_Print( mAppSer, "\r\n  500kHz is selected.", gAllowToBlock_d );
    711                      break;
    712          
    713                  default:
    714                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
    715                      break;
    716                  }
    717          
    718                  Serial_Print( mAppSer, "  Effective Bitrate is ", gAllowToBlock_d );
    719                  Serial_PrintDec( mAppSer, gDataRate[mTermParam.Bw][mTermParam.Sf-7] );
    720                  Serial_Print( mAppSer, "bps.", gAllowToBlock_d );
    721          
    722                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
    723              }
    724              /* processor mode */
    725              else
    726              {
    727                  for( findIndex = 0; findIndex < 2; findIndex++ )
    728                  {
    729                      if( isAsciiDec(CommDataBuffer[nameLen+1+findIndex]) )
    730                      {
    731                          tmpBw += AsciiToDec( CommDataBuffer[nameLen+1+findIndex] );
    732                      }
    733                      else
    734                      {
    735                          tmpBw = 0xff;
    736                          break;
    737                      }
    738          
    739                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
    740                      {
    741                          break;
    742                      }
    743          
    744                      tmpBw *= 10;
    745                  }
    746          
    747                  switch( tmpBw )
    748                  {
    749          #if 0
    750                  case 1:
    751                  case 2:
    752          #endif
    753                  case 3:
    754                  case 4:
    755                      mTermParam.Bw = tmpBw + 3;
    756                      maxChannel    = MAX_CHANNEL_MODE1;
    757                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    758                      break;
    759          
    760                  case 5:
    761                      mTermParam.Bw = tmpBw + 3;
    762                      maxChannel    = MAX_CHANNEL_MODE2;
    763                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    764                      break;
    765          
    766                  case 6:
    767                      mTermParam.Bw = tmpBw + 3;
    768                      maxChannel    = MAX_CHANNEL_MODE3;
    769                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    770                      break;
    771          
    772                  default:
    773                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
    774                      break;
    775                  }
    776              }
    777          
    778              // adjust channel
    779              if( maxChannel < mTermParam.Channel )
    780              {
    781                  mTermParam.Channel = 1;
    782              }
    783          }
    784          
    785          /***********************************************************************************
    786          * CommExecSetSpreadingFactor
    787          *
    788          * Interface assumptions:
    789          *     index         command index
    790          *     nameLen       command name length
    791          *
    792          * Return value:
    793          *     None
    794          *
    795          ************************************************************************************/
    796          static void CommExecSetSpreadingFactor( int index, int nameLen )
    797          {
    798              uint8_t     tmpCount = 0;
    799              uint8_t     findIndex;
    800          
    801          
    802              /* terminal mode */
    803              if( TERMINAL == mTermParam.Mode )
    804              {
    805                  Serial_Print( mAppSer, "\r\n  please set Spreading Factor (7 - 12) > ", gAllowToBlock_d );
    806          
    807                  IsChar();
    808          
    809                  for( findIndex = 0; findIndex < 2; findIndex++ )
    810                  {
    811                      if( isAsciiDec(CommDataBuffer[findIndex]) )
    812                      {
    813                          tmpCount += AsciiToDec( CommDataBuffer[findIndex] );
    814                      }
    815                      else
    816                      {
    817                          tmpCount = 0xff;
    818                          break;
    819                      }
    820          
    821                      if( '\0' == CommDataBuffer[findIndex+1] )
    822                      {
    823                          break;
    824                      }
    825          
    826                      tmpCount *= 10;
    827                  }
    828          
    829                  if( (7 <= tmpCount) && (tmpCount <= 12) )
    830                  {
    831                      mTermParam.Sf = tmpCount;
    832          
    833                      Serial_Print( mAppSer, "\r\n  spreading factor is ", gAllowToBlock_d );
    834                      Serial_PrintDec( mAppSer, mTermParam.Sf );
    835                  }
    836                  else
    837                  {
    838                      Serial_Print( mAppSer, "\r\n  spreading factor is invalid.", gAllowToBlock_d );
    839                  }
    840          
    841                  Serial_Print( mAppSer, "  Effective Bitrate is ", gAllowToBlock_d );
    842                  Serial_PrintDec( mAppSer, gDataRate[mTermParam.Bw][mTermParam.Sf-7] );
    843                  Serial_Print( mAppSer, "bps.", gAllowToBlock_d );
    844          
    845                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
    846              }
    847              /* processor mode */
    848              else
    849              {
    850                  for( findIndex = 0; findIndex < 2; findIndex++ )
    851                  {
    852                      if( isAsciiDec(CommDataBuffer[nameLen+1+findIndex]) )
    853                      {
    854                          tmpCount += AsciiToDec( CommDataBuffer[nameLen+1+findIndex] );
    855                      }
    856                      else
    857                      {
    858                          tmpCount = 0xff;
    859                          break;
    860                      }
    861          
    862                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
    863                      {
    864                          break;
    865                      }
    866          
    867                      tmpCount *= 10;
    868                  }
    869          
    870                  if( (7 <= tmpCount) && (tmpCount <= 12) )
    871                  {
    872                      mTermParam.Sf = tmpCount;
    873          
    874                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    875                  }
    876                  else
    877                  {
    878                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
    879                  }
    880              }
    881          }
    882          
    883          /***********************************************************************************
    884          * CommExecSetChannel
    885          *
    886          * Interface assumptions:
    887          *     index         command index
    888          *     nameLen       command name length
    889          *
    890          * Return value:
    891          *     None
    892          *
    893          ************************************************************************************/
    894          static void CommExecSetChannel( int index, int nameLen )
    895          {
    896              uint8_t tmpChannel = 0;
    897              uint8_t maxChannel = 0;
    898              uint8_t findIndex;
    899          
    900          
    901              /* terminal mode */
    902              if( TERMINAL == mTermParam.Mode )
    903              {
    904                  if( BANDWIDTH250 == mTermParam.Bw )
    905                  {
    906                      maxChannel = MAX_CHANNEL_MODE2;
    907                      Serial_Print( mAppSer, "\r\n  please set channel (1 - 7) > ", gAllowToBlock_d );
    908                  }
    909                  else if( BANDWIDTH500 == mTermParam.Bw )
    910                  {
    911                      maxChannel = MAX_CHANNEL_MODE3;
    912                      Serial_Print( mAppSer, "\r\n  please set channel (1 - 5) > ", gAllowToBlock_d );
    913                  }
    914                  else
    915                  {
    916                      maxChannel = MAX_CHANNEL_MODE1;
    917                      Serial_Print( mAppSer, "\r\n  please set channel (1 - 15) > ", gAllowToBlock_d );
    918                  }
    919          
    920                  IsChar();
    921          
    922                  for( findIndex = 0; findIndex < 2; findIndex++ )
    923                  {
    924                      if( isAsciiDec(CommDataBuffer[findIndex]) )
    925                      {
    926                          tmpChannel += AsciiToDec( CommDataBuffer[findIndex] );
    927                      }
    928                      else
    929                      {
    930                          tmpChannel = 0;
    931                          break;
    932                      }
    933          
    934                      if( '\0' == CommDataBuffer[findIndex+1] )
    935                      {
    936                          break;
    937                      }
    938          
    939                      tmpChannel *= 10;
    940                  }
    941          
    942                  if( (0 < tmpChannel) && (tmpChannel <= maxChannel) )
    943                  {
    944                      mTermParam.Channel = tmpChannel;
    945          
    946                      Serial_Print( mAppSer, "\r\n  channel is ", gAllowToBlock_d );
    947                      Serial_PrintDec( mAppSer, mTermParam.Channel );
    948                  }
    949                  else
    950                  {
    951                      Serial_Print( mAppSer, "\r\n  channel is invalid.", gAllowToBlock_d );
    952                  }
    953          
    954                 Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
    955              }
    956              /* processor mode */
    957              else
    958              {
    959                  if( BANDWIDTH250 == mTermParam.Bw )
    960                  {
    961                      maxChannel = MAX_CHANNEL_MODE2;
    962                  }
    963                  else if( BANDWIDTH500 == mTermParam.Bw )
    964                  {
    965                      maxChannel = MAX_CHANNEL_MODE3;
    966                  }
    967                  else
    968                  {
    969                      maxChannel = MAX_CHANNEL_MODE1;
    970                  }
    971          
    972                  for( findIndex = 0; findIndex < 2; findIndex++ )
    973                  {
    974                      if( isAsciiDec(CommDataBuffer[nameLen+1+findIndex]) )
    975                      {
    976                          tmpChannel += AsciiToDec( CommDataBuffer[nameLen+1+findIndex] );
    977                      }
    978                      else
    979                      {
    980                          tmpChannel = 0;
    981                          break;
    982                      }
    983          
    984                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
    985                      {
    986                          break;
    987                      }
    988          
    989                      tmpChannel *= 10;
    990                  }
    991          
    992                  if( (0 < tmpChannel) && (tmpChannel <= maxChannel) )
    993                  {
    994                      mTermParam.Channel = tmpChannel;
    995          
    996                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
    997                  }
    998                  else
    999                  {
   1000                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1001                  }
   1002              }
   1003          }
   1004          
   1005          /***********************************************************************************
   1006          * CommExecSetPanId
   1007          *
   1008          * Interface assumptions:
   1009          *     index         command index
   1010          *     nameLen       command name length
   1011          *
   1012          * Return value:
   1013          *     None
   1014          *
   1015          ************************************************************************************/
   1016          static void CommExecSetPanId( int index, int nameLen )
   1017          {
   1018              uint16_t    tmpId = 0;
   1019              uint8_t     findIndex;
   1020          
   1021          
   1022              /* terminal mode */
   1023              if( TERMINAL == mTermParam.Mode )
   1024              {
   1025                  Serial_Print( mAppSer, "\r\n  please set PAN ID (0001 - FFFE) > ", gAllowToBlock_d );
   1026          
   1027                  IsChar();
   1028          
   1029                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1030                  {
   1031                      if( isAsciiHex(CommDataBuffer[findIndex]) )
   1032                      {
   1033                          tmpId |= AsciiToHex( CommDataBuffer[findIndex] );
   1034                      }
   1035                      else
   1036                      {
   1037                          findIndex = 4;
   1038                          break;
   1039                      }
   1040          
   1041                      if( '\0' == CommDataBuffer[findIndex+1] )
   1042                      {
   1043                          break;
   1044                      }
   1045          
   1046                      tmpId <<= 4;
   1047                  }
   1048          
   1049                  if( ((0 != tmpId) && (0xFFFF != tmpId)) && (findIndex < 4) )
   1050                  {
   1051                      mTermParam.PanId = tmpId;
   1052          
   1053                      Serial_Print( mAppSer, "\r\n  PAN ID is 0x", gAllowToBlock_d );
   1054                      Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.PanId, 2, 0 );
   1055                  }
   1056                  else
   1057                  {
   1058                      Serial_Print( mAppSer, "\r\n  PAN ID is invalid.", gAllowToBlock_d );
   1059                  }
   1060          
   1061                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1062              }
   1063              /* processor mode */
   1064              else
   1065              {
   1066                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1067                  {
   1068                      if( isAsciiHex(CommDataBuffer[nameLen+1+findIndex]) )
   1069                      {
   1070                          tmpId |= AsciiToHex( CommDataBuffer[nameLen+1+findIndex] );
   1071                      }
   1072                      else
   1073                      {
   1074                          findIndex = 4;
   1075                          break;
   1076                      }
   1077          
   1078                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   1079                      {
   1080                          break;
   1081                      }
   1082          
   1083                      tmpId <<= 4;
   1084                  }
   1085          
   1086                  if( ((0 != tmpId) && (0xFFFF != tmpId)) && (findIndex < 4) )
   1087                  {
   1088                      mTermParam.PanId = tmpId;
   1089          
   1090                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1091                  }
   1092                  else
   1093                  {
   1094                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1095                  }
   1096              }
   1097          }
   1098          
   1099          /***********************************************************************************
   1100          * CommExecSetSourceId
   1101          *
   1102          * Interface assumptions:
   1103          *     index         command index
   1104          *     nameLen       command name length
   1105          *
   1106          * Return value:
   1107          *     None
   1108          *
   1109          ************************************************************************************/
   1110          static void CommExecSetSourceId( int index, int nameLen )
   1111          {
   1112              uint16_t    tmpId = 0;
   1113              uint8_t     findIndex;
   1114          
   1115          
   1116              /* terminal mode */
   1117              if( TERMINAL == mTermParam.Mode )
   1118              {
   1119                  Serial_Print( mAppSer, "\r\n  please set Own Node ID (0000 - FFFE) > ", gAllowToBlock_d );
   1120          
   1121                  IsChar();
   1122          
   1123                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1124                  {
   1125                      if( isAsciiHex(CommDataBuffer[findIndex]) )
   1126                      {
   1127                          tmpId |= AsciiToHex( CommDataBuffer[findIndex] );
   1128                      }
   1129                      else
   1130                      {
   1131                          findIndex = 4;
   1132                          break;
   1133                      }
   1134          
   1135                      if( '\0' == CommDataBuffer[findIndex+1] )
   1136                      {
   1137                          break;
   1138                      }
   1139          
   1140                      tmpId <<= 4;
   1141                  }
   1142          
   1143                  if( (0xFFFF != tmpId) && (findIndex < 4) )
   1144                  {
   1145                      mTermParam.SrcId = tmpId;
   1146          
   1147                      Serial_Print( mAppSer, "\r\n  Own Node ID is 0x", gAllowToBlock_d );
   1148                      Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.SrcId, 2, 0 );
   1149                  }
   1150                  else
   1151                  {
   1152                      Serial_Print( mAppSer, "\r\n  Own Node ID is invalid.", gAllowToBlock_d );
   1153                  }
   1154          
   1155                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1156              }
   1157              /* processor mode */
   1158              else
   1159              {
   1160                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1161                  {
   1162                      if( isAsciiHex(CommDataBuffer[nameLen+1+findIndex]) )
   1163                      {
   1164                          tmpId |= AsciiToHex( CommDataBuffer[nameLen+1+findIndex] );
   1165                      }
   1166                      else
   1167                      {
   1168                          findIndex = 4;
   1169                          break;
   1170                      }
   1171          
   1172                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   1173                      {
   1174                          break;
   1175                      }
   1176          
   1177                      tmpId <<= 4;
   1178                  }
   1179          
   1180                  if( (0xFFFF != tmpId) && (findIndex < 4) )
   1181                  {
   1182                      mTermParam.SrcId = tmpId;
   1183          
   1184                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1185                  }
   1186                  else
   1187                  {
   1188                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1189                  }
   1190              }
   1191          }
   1192          
   1193          /***********************************************************************************
   1194          * CommExecSetDestinationId
   1195          *
   1196          * Interface assumptions:
   1197          *     index         command index
   1198          *     nameLen       command name length
   1199          *
   1200          * Return value:
   1201          *     None
   1202          *
   1203          ************************************************************************************/
   1204          static void CommExecSetDestinationId( int index, int nameLen )
   1205          {
   1206              uint16_t    tmpId = 0;
   1207              uint8_t     findIndex;
   1208          
   1209          
   1210              /* terminal mode */
   1211              if( TERMINAL == mTermParam.Mode )
   1212              {
   1213                  Serial_Print( mAppSer, "\r\n  please set Destination ID (0000 - FFFF) > ", gAllowToBlock_d );
   1214          
   1215                  IsChar();
   1216          
   1217                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1218                  {
   1219                      if( isAsciiHex(CommDataBuffer[findIndex]) )
   1220                      {
   1221                          tmpId |= AsciiToHex( CommDataBuffer[findIndex] );
   1222                      }
   1223                      else
   1224                      {
   1225                          findIndex = 4;
   1226                          break;
   1227                      }
   1228          
   1229                      if( '\0' == CommDataBuffer[findIndex+1] )
   1230                      {
   1231                          break;
   1232                      }
   1233          
   1234                      tmpId <<= 4;
   1235                  }
   1236          
   1237                  if( findIndex < 4 )
   1238                  {
   1239                      mTermParam.DstId = tmpId;
   1240          
   1241                      Serial_Print( mAppSer, "\r\n  Destination ID is 0x", gAllowToBlock_d );
   1242                      Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.DstId, 2, 0 );
   1243                  }
   1244                  else
   1245                  {
   1246                      Serial_Print( mAppSer, "\r\n  Destination ID is invalid.", gAllowToBlock_d );
   1247                  }
   1248          
   1249                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1250              }
   1251              /* processor mode */
   1252              else
   1253              {
   1254                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1255                  {
   1256                      if( isAsciiHex(CommDataBuffer[nameLen+1+findIndex]) )
   1257                      {
   1258                          tmpId |= AsciiToHex( CommDataBuffer[nameLen+1+findIndex] );
   1259                      }
   1260                      else
   1261                      {
   1262                          findIndex = 4;
   1263                          break;
   1264                      }
   1265          
   1266                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   1267                      {
   1268                          break;
   1269                      }
   1270          
   1271                      tmpId <<= 4;
   1272                  }
   1273          
   1274                  if( findIndex < 4 )
   1275                  {
   1276                      mTermParam.DstId = tmpId;
   1277          
   1278                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1279                  }
   1280                  else
   1281                  {
   1282                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1283                  }
   1284              }
   1285          }
   1286          
   1287          #ifdef _STATIC_ROUTING_
   1288          /***********************************************************************************
   1289          * CommExecSetHopCount
   1290          *
   1291          * Interface assumptions:
   1292          *     index         command index
   1293          *     nameLen       command name length
   1294          *
   1295          * Return value:
   1296          *     None
   1297          *
   1298          ************************************************************************************/
   1299          static void CommExecSetHopCount( int index, int nameLen )
   1300          {
   1301              uint8_t tmpCount = 0;
   1302          
   1303          
   1304              /* terminal mode */
   1305              if( TERMINAL == mTermParam.Mode )
   1306              {
   1307                  Serial_Print( mAppSer, "\r\n  please set hop count (1 - 3) > ", gAllowToBlock_d );
   1308          
   1309                  IsChar();
   1310          
   1311                  if( isAsciiDec(CommDataBuffer[0]) )
   1312                  {
   1313                      tmpCount = AsciiToDec( CommDataBuffer[0] );
   1314                  }
   1315          
   1316                  if( (MIN_HOP_COUNT <= tmpCount) && (tmpCount <= MAX_HOP_COUNT) )
   1317                  {
   1318                      mTermParam.HopCnt = tmpCount;
   1319          
   1320                      Serial_Print( mAppSer, "\r\n  hop count is ", gAllowToBlock_d );
   1321                      Serial_PrintDec( mAppSer, mTermParam.HopCnt );
   1322                  }
   1323                  else
   1324                  {
   1325                      Serial_Print( mAppSer, "\r\n  hop count is invalid.", gAllowToBlock_d );
   1326                  }
   1327          
   1328                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1329              }
   1330              /* processor mode */
   1331              else
   1332              {
   1333                  if( isAsciiDec(CommDataBuffer[nameLen+1]) )
   1334                  {
   1335                      tmpCount = AsciiToDec( CommDataBuffer[nameLen+1] );
   1336                  }
   1337          
   1338                  if( (MIN_HOP_COUNT <= tmpCount) && (tmpCount <= MAX_HOP_COUNT) )
   1339                  {
   1340                      mTermParam.HopCnt = tmpCount;
   1341          
   1342                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1343                  }
   1344                  else
   1345                  {
   1346                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1347                  }
   1348              }
   1349          }
   1350          
   1351          /***********************************************************************************
   1352          * CommExecSetEndId
   1353          *
   1354          * Interface assumptions:
   1355          *     index         command index
   1356          *     nameLen       command name length
   1357          *
   1358          * Return value:
   1359          *     None
   1360          *
   1361          ************************************************************************************/
   1362          static void CommExecSetEndId( int index, int nameLen )
   1363          {
   1364              uint16_t    tmpId = 0;
   1365              uint8_t     findIndex;
   1366          
   1367          
   1368              /* terminal mode */
   1369              if( TERMINAL == mTermParam.Mode )
   1370              {
   1371                  Serial_Print( mAppSer, "\r\n  please set End ID (0000 - FFFE) > ", gAllowToBlock_d );
   1372          
   1373                  IsChar();
   1374          
   1375                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1376                  {
   1377                      if( isAsciiHex(CommDataBuffer[findIndex]) )
   1378                      {
   1379                          tmpId |= AsciiToHex( CommDataBuffer[findIndex] );
   1380                      }
   1381                      else
   1382                      {
   1383                          findIndex = 4;
   1384                          break;
   1385                      }
   1386          
   1387                      if( '\0' == CommDataBuffer[findIndex+1] )
   1388                      {
   1389                          break;
   1390                      }
   1391          
   1392                      tmpId <<= 4;
   1393                  }
   1394          
   1395                  if( (0xFFFF != tmpId) && (findIndex < 4) )
   1396                  {
   1397                      mTermParam.EndId = tmpId;
   1398          
   1399                      Serial_Print( mAppSer, "\r\n  End ID is 0x", gAllowToBlock_d );
   1400                      Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.EndId, 2, 0 );
   1401                  }
   1402                  else
   1403                  {
   1404                      Serial_Print( mAppSer, "\r\n  End ID is invalid.", gAllowToBlock_d );
   1405                  }
   1406          
   1407                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1408              }
   1409              /* processor mode */
   1410              else
   1411              {
   1412                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1413                  {
   1414                      if( isAsciiHex(CommDataBuffer[nameLen+1+findIndex]) )
   1415                      {
   1416                          tmpId |= AsciiToHex( CommDataBuffer[nameLen+1+findIndex] );
   1417                      }
   1418                      else
   1419                      {
   1420                          findIndex = 4;
   1421                          break;
   1422                      }
   1423          
   1424                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   1425                      {
   1426                          break;
   1427                      }
   1428          
   1429                      tmpId <<= 4;
   1430                  }
   1431          
   1432                  if( (0xFFFF != tmpId) && (findIndex < 4) )
   1433                  {
   1434                      mTermParam.EndId = tmpId;
   1435          
   1436                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1437                  }
   1438                  else
   1439                  {
   1440                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1441                  }
   1442              }
   1443          }
   1444          
   1445          /***********************************************************************************
   1446          * CommExecSetRoute1
   1447          *
   1448          * Interface assumptions:
   1449          *     index         command index
   1450          *     nameLen       command name length
   1451          *
   1452          * Return value:
   1453          *     None
   1454          *
   1455          ************************************************************************************/
   1456          static void CommExecSetRoute1( int index, int nameLen )
   1457          {
   1458              CommExecSetRoute( index, 0, nameLen );
   1459          }
   1460          
   1461          /***********************************************************************************
   1462          * CommExecSetRoute2
   1463          *
   1464          * Interface assumptions:
   1465          *     index         command index
   1466          *     nameLen       command name length
   1467          *
   1468          * Return value:
   1469          *     None
   1470          *
   1471          ************************************************************************************/
   1472          static void CommExecSetRoute2( int index, int nameLen )
   1473          {
   1474              CommExecSetRoute( index, 1, nameLen );
   1475          }
   1476          
   1477          /***********************************************************************************
   1478          * CommExecSetRoute
   1479          *
   1480          * Interface assumptions:
   1481          *     index         command index
   1482          *     route         route index
   1483          *     nameLen       command name length
   1484          *
   1485          * Return value:
   1486          *     None
   1487          *
   1488          ************************************************************************************/
   1489          static void CommExecSetRoute( int index, int route, int nameLen )
   1490          {
   1491              uint16_t    tmpId = 0;
   1492              uint8_t     findIndex;
   1493          
   1494          
   1495              /* terminal mode */
   1496              if( TERMINAL == mTermParam.Mode )
   1497              {
   1498                  Serial_Print( mAppSer, "\r\n  please set Router", gAllowToBlock_d );
   1499                  Serial_PrintDec( mAppSer, route + 1 );
   1500                  Serial_Print( mAppSer, " ID (0001 - FFFE) > ", gAllowToBlock_d );
   1501          
   1502                  IsChar();
   1503          
   1504                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1505                  {
   1506                      if( isAsciiHex(CommDataBuffer[findIndex]) )
   1507                      {
   1508                          tmpId |= AsciiToHex( CommDataBuffer[findIndex] );
   1509                      }
   1510                      else
   1511                      {
   1512                          findIndex = 4;
   1513                          break;
   1514                      }
   1515          
   1516                      if( '\0' == CommDataBuffer[findIndex+1] )
   1517                      {
   1518                          break;
   1519                      }
   1520          
   1521                      tmpId <<= 4;
   1522                  }
   1523          
   1524                  if( ((0 != tmpId) && (0xFFFF != tmpId)) && (findIndex < 4) )
   1525                  {
   1526                      mTermParam.Route[route] = tmpId;
   1527          
   1528                      Serial_Print( mAppSer,  "\r\n  Router", gAllowToBlock_d );
   1529                      Serial_PrintDec( mAppSer,  route + 1 );
   1530                      Serial_Print( mAppSer,  " ID is 0x", gAllowToBlock_d );
   1531                      Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.Route[route], 2, 0 );
   1532                  }
   1533                  else
   1534                  {
   1535                      Serial_Print( mAppSer, "\r\n  Router", gAllowToBlock_d );
   1536                      Serial_PrintDec( mAppSer, route + 1 );
   1537                      Serial_Print( mAppSer,  " ID is invalid.", gAllowToBlock_d );
   1538                  }
   1539          
   1540                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1541              }
   1542              /* processor mode */
   1543              else
   1544              {
   1545                  for( findIndex = 0; findIndex < 4; findIndex++ )
   1546                  {
   1547                      if( isAsciiHex(CommDataBuffer[nameLen+1+findIndex]) )
   1548                      {
   1549                          tmpId |= AsciiToHex( CommDataBuffer[nameLen+1+findIndex] );
   1550                      }
   1551                      else
   1552                      {
   1553                          findIndex = 4;
   1554                          break;
   1555                      }
   1556          
   1557                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   1558                      {
   1559                          break;
   1560                      }
   1561          
   1562                      tmpId <<= 4;
   1563                  }
   1564          
   1565                  if( ((0 != tmpId) && (0xFFFF != tmpId)) && (findIndex < 4) )
   1566                  {
   1567                      mTermParam.Route[route] = tmpId;
   1568          
   1569                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1570                  }
   1571                  else
   1572                  {
   1573                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1574                  }
   1575              }
   1576          }
   1577          #endif
   1578          
   1579          /***********************************************************************************
   1580          * CommExecSetAck
   1581          *
   1582          * Interface assumptions:
   1583          *     index         command index
   1584          *     nameLen       command name length
   1585          *
   1586          * Return value:
   1587          *     None
   1588          *
   1589          ************************************************************************************/
   1590          static void CommExecSetAck( int index, int nameLen )
   1591          {
   1592              uint8_t tmpMode = 0;
   1593          
   1594          
   1595              /* terminal mode */
   1596              if( TERMINAL == mTermParam.Mode )
   1597              {
   1598                  PrintMessage( cuOnOffMenu );
   1599          
   1600                  IsChar();
   1601          
   1602                  if( isAsciiHex(CommDataBuffer[0]) )
   1603                  {
   1604                      tmpMode = AsciiToHex( CommDataBuffer[0] );
   1605                  }
   1606          
   1607                  switch( tmpMode )
   1608                  {
   1609                  case MODE_ON:
   1610                      mTermParam.Ack = MODE_ON;
   1611                      Serial_Print( mAppSer, "\r\n  Acknowledge is ON.", gAllowToBlock_d );
   1612                      break;
   1613          
   1614                  case MODE_OFF:
   1615                      mTermParam.Ack = MODE_OFF;
   1616                      Serial_Print( mAppSer, "\r\n  Acknowledge is OFF.", gAllowToBlock_d );
   1617                      break;
   1618          
   1619                  default:
   1620                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
   1621                      break;
   1622                  }
   1623          
   1624                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1625              }
   1626              /* processor mode */
   1627              else
   1628              {
   1629                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
   1630                  {
   1631                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
   1632                  }
   1633          
   1634                  if( (MODE_ON == tmpMode) || (MODE_OFF == tmpMode) )
   1635                  {
   1636                      mTermParam.Ack = tmpMode;
   1637          
   1638                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1639                  }
   1640                  else
   1641                  {
   1642                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1643                  }
   1644              }
   1645          }
   1646          
   1647          /***********************************************************************************
   1648          * CommExecSetRetry
   1649          *
   1650          * Interface assumptions:
   1651          *     index         command index
   1652          *     nameLen       command name length
   1653          *
   1654          * Return value:
   1655          *     None
   1656          *
   1657          ************************************************************************************/
   1658          static void CommExecSetRetry( int index, int nameLen )
   1659          {
   1660              uint8_t tmpCount = 0;
   1661              uint8_t findIndex;
   1662          
   1663          
   1664              /* terminal mode */
   1665              if( TERMINAL == mTermParam.Mode )
   1666              {
   1667                  Serial_Print( mAppSer, "\r\n  please set retry count (0 - 10) > ", gAllowToBlock_d );
   1668          
   1669                  IsChar();
   1670          
   1671                  for( findIndex = 0; findIndex < 2; findIndex++ )
   1672                  {
   1673                      if( isAsciiDec(CommDataBuffer[findIndex]) )
   1674                      {
   1675                          tmpCount += AsciiToDec( CommDataBuffer[findIndex] );
   1676                      }
   1677                      else
   1678                      {
   1679                          tmpCount = 0xff;
   1680                          break;
   1681                      }
   1682          
   1683                      if( '\0' == CommDataBuffer[findIndex+1] )
   1684                      {
   1685                          break;
   1686                      }
   1687          
   1688                      tmpCount *= 10;
   1689                  }
   1690          
   1691                  if( tmpCount <= MAX_RETRY_CNT )
   1692                  {
   1693                      mTermParam.Retry = tmpCount;
   1694          
   1695                      Serial_Print( mAppSer, "\r\n  retry count is ", gAllowToBlock_d );
   1696                      Serial_PrintDec( mAppSer, mTermParam.Retry );
   1697                  }
   1698                  else
   1699                  {
   1700                      Serial_Print( mAppSer, "\r\n  retry count is invalid.", gAllowToBlock_d );
   1701                  }
   1702          
   1703                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1704              }
   1705              /* processor mode */
   1706              else
   1707              {
   1708                  for( findIndex = 0; findIndex < 2; findIndex++ )
   1709                  {
   1710                      if( isAsciiDec(CommDataBuffer[nameLen+1+findIndex]) )
   1711                      {
   1712                          tmpCount += AsciiToDec( CommDataBuffer[nameLen+1+findIndex] );
   1713                      }
   1714                      else
   1715                      {
   1716                          tmpCount = 0xff;
   1717                          break;
   1718                      }
   1719          
   1720                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   1721                      {
   1722                          break;
   1723                      }
   1724          
   1725                      tmpCount *= 10;
   1726                  }
   1727          
   1728                  if( tmpCount <= MAX_RETRY_CNT )
   1729                  {
   1730                      mTermParam.Retry = tmpCount;
   1731          
   1732                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1733                  }
   1734                  else
   1735                  {
   1736                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1737                  }
   1738              }
   1739          }
   1740          
   1741          /***********************************************************************************
   1742          * CommExecSelectTransMode
   1743          *
   1744          * Interface assumptions:
   1745          *     index         command index
   1746          *     nameLen       command name length
   1747          *
   1748          * Return value:
   1749          *     None
   1750          *
   1751          ************************************************************************************/
   1752          static void CommExecSelectTransMode( int index, int nameLen )
   1753          {
   1754              uint8_t tmpMode = 0;
   1755          
   1756          
   1757              /* terminal mode */
   1758              if( TERMINAL == mTermParam.Mode )
   1759              {
   1760                  PrintMessage( cuTransMenu );
   1761          
   1762                  IsChar();
   1763          
   1764                  if( isAsciiHex(CommDataBuffer[0]) )
   1765                  {
   1766                      tmpMode = AsciiToHex( CommDataBuffer[0] );
   1767                  }
   1768          
   1769                  switch( tmpMode )
   1770                  {
   1771                  case TRANS_PAYLOAD:
   1772                      mTermParam.TransMode = TRANS_PAYLOAD;
   1773                      Serial_Print( mAppSer, "\r\n  Payload Mode is selected.", gAllowToBlock_d );
   1774                      break;
   1775          
   1776                  case TRANS_FRAME:
   1777                      mTermParam.TransMode = TRANS_FRAME;
   1778                      Serial_Print( mAppSer, "\r\n  Frame Mode is selected.", gAllowToBlock_d );
   1779                      break;
   1780          
   1781                  default:
   1782                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
   1783                      break;
   1784                  }
   1785          
   1786                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1787              }
   1788              else
   1789              {
   1790                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
   1791                  {
   1792                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
   1793                  }
   1794          
   1795                  if( (TRANS_PAYLOAD == tmpMode) || (TRANS_FRAME == tmpMode) )
   1796                  {
   1797                      mTermParam.TransMode = tmpMode;
   1798          
   1799                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1800                  }
   1801                  else
   1802                  {
   1803                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1804                  }
   1805              }
   1806          }
   1807          
   1808          /***********************************************************************************
   1809          * CommExecSelectRcvId
   1810          *
   1811          * Interface assumptions:
   1812          *     index         command index
   1813          *     nameLen       command name length
   1814          *
   1815          * Return value:
   1816          *     None
   1817          *
   1818          ************************************************************************************/
   1819          static void CommExecSelectRcvId( int index, int nameLen )
   1820          {
   1821              uint8_t tmpMode = 0;
   1822          
   1823          
   1824              /* terminal mode */
   1825              if( TERMINAL == mTermParam.Mode )
   1826              {
   1827                  PrintMessage( cuOnOffMenu );
   1828          
   1829                  IsChar();
   1830          
   1831                  if( isAsciiHex(CommDataBuffer[0]) )
   1832                  {
   1833                      tmpMode = AsciiToHex( CommDataBuffer[0] );
   1834                  }
   1835          
   1836                  switch( tmpMode )
   1837                  {
   1838                  case MODE_ON:
   1839                      mTermParam.RcvId = MODE_ON;
   1840                      Serial_Print( mAppSer, "\r\n  Receive Node ID information is ON.", gAllowToBlock_d );
   1841                      break;
   1842          
   1843                  case MODE_OFF:
   1844                      mTermParam.RcvId = MODE_OFF;
   1845                      Serial_Print( mAppSer, "\r\n  Receive Node ID information is OFF.", gAllowToBlock_d );
   1846                      break;
   1847          
   1848                  default:
   1849                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
   1850                      break;
   1851                  }
   1852          
   1853                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1854              }
   1855              /* processor mode */
   1856              else
   1857              {
   1858                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
   1859                  {
   1860                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
   1861                  }
   1862          
   1863                  if( (MODE_ON == tmpMode) || (MODE_OFF == tmpMode) )
   1864                  {
   1865                      mTermParam.RcvId = tmpMode;
   1866          
   1867                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1868                  }
   1869                  else
   1870                  {
   1871                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1872                  }
   1873              }
   1874          }
   1875          
   1876          /***********************************************************************************
   1877          * CommExecSelectRssi
   1878          *
   1879          * Interface assumptions:
   1880          *     index         command index
   1881          *     nameLen       command name length
   1882          *
   1883          * Return value:
   1884          *     None
   1885          *
   1886          ************************************************************************************/
   1887          static void CommExecSelectRssi( int index, int nameLen )
   1888          {
   1889              uint8_t tmpMode = 0;
   1890          
   1891          
   1892              /* terminal mode */
   1893              if( TERMINAL == mTermParam.Mode )
   1894              {
   1895                  PrintMessage( cuOnOffMenu );
   1896          
   1897                  IsChar();
   1898          
   1899                  if( isAsciiHex(CommDataBuffer[0]) )
   1900                  {
   1901                      tmpMode = AsciiToHex( CommDataBuffer[0] );
   1902                  }
   1903          
   1904                  switch( tmpMode )
   1905                  {
   1906                  case MODE_ON:
   1907                      mTermParam.Rssi = MODE_ON;
   1908                      Serial_Print( mAppSer, "\r\n  RSSI information is ON.", gAllowToBlock_d );
   1909                      break;
   1910          
   1911                  case MODE_OFF:
   1912                      mTermParam.Rssi = MODE_OFF;
   1913                      Serial_Print( mAppSer, "\r\n  RSSI information is OFF.", gAllowToBlock_d );
   1914                      break;
   1915          
   1916                  default:
   1917                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
   1918                      break;
   1919                  }
   1920          
   1921                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1922              }
   1923              /* processor mode */
   1924              else
   1925              {
   1926                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
   1927                  {
   1928                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
   1929                  }
   1930          
   1931                  if( (MODE_ON == tmpMode) || (MODE_OFF == tmpMode) )
   1932                  {
   1933                      mTermParam.Rssi = tmpMode;
   1934          
   1935                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   1936                  }
   1937                  else
   1938                  {
   1939                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   1940                  }
   1941              }
   1942          }
   1943          
   1944          /***********************************************************************************
   1945          * CommExecSelectOperation
   1946          *
   1947          * Interface assumptions:
   1948          *     index         command index
   1949          *     nameLen       command name length
   1950          *
   1951          * Return value:
   1952          *     None
   1953          *
   1954          ************************************************************************************/
   1955          static void CommExecSelectOperation( int index, int nameLen )
   1956          {
   1957              uint8_t tmpMode = 0;
   1958          
   1959          
   1960              /* terminal mode */
   1961              if( TERMINAL == mTermParam.Mode )
   1962              {
   1963                  PrintMessage( cuOperationMenu );
   1964          
   1965                  IsChar();
   1966          
   1967                  if( isAsciiHex(CommDataBuffer[0]) )
   1968                  {
   1969                      tmpMode = AsciiToHex( CommDataBuffer[0] );
   1970                  }
   1971          
   1972                  switch( tmpMode )
   1973                  {
   1974                  case CONFIG:
   1975                      mTermParam.Operation = CONFIG;
   1976                      Serial_Print( mAppSer, "\r\n  Configuration is selected.", gAllowToBlock_d );
   1977                      break;
   1978          
   1979                  case OPERATION:
   1980                      mTermParam.Operation = OPERATION;
   1981                      Serial_Print( mAppSer, "\r\n  Operation is selected.", gAllowToBlock_d );
   1982                      break;
   1983          
   1984                  default:
   1985                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
   1986                      break;
   1987                  }
   1988          
   1989                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   1990              }
   1991              /* processor mode */
   1992              else
   1993              {
   1994                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
   1995                  {
   1996                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
   1997                  }
   1998          
   1999                  if( (CONFIG == tmpMode) || (OPERATION == tmpMode) )
   2000                  {
   2001                      mTermParam.Operation = tmpMode;
   2002          
   2003                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2004                  }
   2005                  else
   2006                  {
   2007                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   2008                  }
   2009              }
   2010          }
   2011          
   2012          /***********************************************************************************
   2013          * CommExecSelectBaudrate
   2014          *
   2015          * Interface assumptions:
   2016          *     index         command index
   2017          *     nameLen       command name length
   2018          *
   2019          * Return value:
   2020          *     None
   2021          *
   2022          ************************************************************************************/
   2023          static void CommExecSelectBaudrate( int index, int nameLen )
   2024          {
   2025              uint8_t tmpMode = 0;
   2026          
   2027          
   2028              /* terminal mode */
   2029              if( TERMINAL == mTermParam.Mode )
   2030              {
   2031                  PrintMessage( cuBaudrateMenu );
   2032          
   2033                  IsChar();
   2034          
   2035                  if( isAsciiHex(CommDataBuffer[0]) )
   2036                  {
   2037                      tmpMode = AsciiToHex( CommDataBuffer[0] );
   2038                  }
   2039          
   2040                  switch( tmpMode )
   2041                  {
   2042                  case 1:
   2043                      mTermParam.Baudrate = gUARTBaudRate9600_c;
   2044                      Serial_Print( mAppSer, "\r\n  9600 baud is selected.", gAllowToBlock_d );
   2045                      break;
   2046          
   2047                  case 2:
   2048                      mTermParam.Baudrate = gUARTBaudRate19200_c;
   2049                      Serial_Print( mAppSer, "\r\n  19200 baud is selected.", gAllowToBlock_d );
   2050                      break;
   2051          
   2052                  case 3:
   2053                      mTermParam.Baudrate = gUARTBaudRate38400_c;
   2054                      Serial_Print( mAppSer, "\r\n  38400 baud is selected.", gAllowToBlock_d );
   2055                      break;
   2056          
   2057                  case 4:
   2058                      mTermParam.Baudrate = gUARTBaudRate57600_c;
   2059                      Serial_Print( mAppSer, "\r\n  57600 baud is selected.", gAllowToBlock_d );
   2060                      break;
   2061          
   2062                  case 5:
   2063                      mTermParam.Baudrate = gUARTBaudRate115200_c;
   2064                      Serial_Print( mAppSer, "\r\n  115200 baud is selected.", gAllowToBlock_d );
   2065                      break;
   2066          
   2067                  case 6:
   2068                      mTermParam.Baudrate = gUARTBaudRate230400_c;
   2069                      Serial_Print( mAppSer, "\r\n  230400 baud is selected.", gAllowToBlock_d );
   2070                      break;
   2071          
   2072                  default:
   2073                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
   2074                      break;
   2075                  }
   2076          
   2077                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   2078              }
   2079              /* processor mode */
   2080              else
   2081              {
   2082                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
   2083                  {
   2084                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
   2085                  }
   2086          
   2087                  switch( tmpMode )
   2088                  {
   2089                  case 1:
   2090                      mTermParam.Baudrate = gUARTBaudRate9600_c;
   2091                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2092                      break;
   2093          
   2094                  case 2:
   2095                      mTermParam.Baudrate = gUARTBaudRate19200_c;
   2096                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2097                      break;
   2098          
   2099                  case 3:
   2100                      mTermParam.Baudrate = gUARTBaudRate38400_c;
   2101                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2102                      break;
   2103          
   2104                  case 4:
   2105                      mTermParam.Baudrate = gUARTBaudRate57600_c;
   2106                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2107                      break;
   2108          
   2109                  case 5:
   2110                      mTermParam.Baudrate = gUARTBaudRate115200_c;
   2111                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2112                      break;
   2113          
   2114                  case 6:
   2115                      mTermParam.Baudrate = gUARTBaudRate230400_c;
   2116                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2117                      break;
   2118          
   2119                  default:
   2120                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   2121                      break;
   2122                  }
   2123              }
   2124          
   2125              Serial_SetBaudRate( mAppSer, mTermParam.Baudrate );
   2126          }
   2127          
   2128          /***********************************************************************************
   2129          * CommExecSelectSleep
   2130          *
   2131          * Interface assumptions:
   2132          *     index         command index
   2133          *     nameLen       command name length
   2134          *
   2135          * Return value:
   2136          *     None
   2137          *
   2138          ************************************************************************************/
   2139          static void CommExecSelectSleep( int index, int nameLen )
   2140          {
   2141              uint8_t tmpMode = 0;
   2142          
   2143          
   2144              /* terminal mode */
   2145              if( TERMINAL == mTermParam.Mode )
   2146              {
   2147                  PrintMessage( cuSleepMenu );
   2148          
   2149                  IsChar();
   2150          
   2151                  if( isAsciiHex(CommDataBuffer[0]) )
   2152                  {
   2153                      tmpMode = AsciiToHex( CommDataBuffer[0] );
   2154                  }
   2155          
   2156                  switch( tmpMode )
   2157                  {
   2158                  case NO_SLEEP:
   2159                      mTermParam.Sleep = NO_SLEEP;
   2160                      Serial_Print( mAppSer, "\r\n  No Sleep Mode is selected.", gAllowToBlock_d );
   2161                      break;
   2162          
   2163                  case TIMER_WAKEUP:
   2164                      mTermParam.Sleep = TIMER_WAKEUP;
   2165                      Serial_Print( mAppSer, "\r\n  Timer Wakeup Mode is selected.", gAllowToBlock_d );
   2166                      break;
   2167          
   2168                  case INT_WAKEUP:
   2169                      mTermParam.Sleep = INT_WAKEUP;
   2170                      Serial_Print( mAppSer, "\r\n  INT Wakeup Mode is selected.", gAllowToBlock_d );
   2171                      break;
   2172          
   2173                  default:
   2174                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
   2175                      break;
   2176                  }
   2177          
   2178                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   2179              }
   2180              else
   2181              {
   2182                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
   2183                  {
   2184                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
   2185                  }
   2186          
   2187                  if( (NO_SLEEP == tmpMode) || (TIMER_WAKEUP == tmpMode) || (INT_WAKEUP == tmpMode) )
   2188                  {
   2189                      mTermParam.Sleep = tmpMode;
   2190          
   2191                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2192                  }
   2193                  else
   2194                  {
   2195                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   2196                  }
   2197              }
   2198          }
   2199          
   2200          /***********************************************************************************
   2201          * CommExecSetSleepTime
   2202          *
   2203          * Interface assumptions:
   2204          *     index         command index
   2205          *     nameLen       command name length
   2206          *
   2207          * Return value:
   2208          *     None
   2209          *
   2210          ************************************************************************************/
   2211          static void CommExecSetSleepTime( int index, int nameLen )
   2212          {
   2213              uint32_t tmpValue = 0;
   2214              uint8_t findIndex;
   2215          
   2216          
   2217              /* terminal mode */
   2218              if( TERMINAL == mTermParam.Mode )
   2219              {
   2220                  Serial_Print( mAppSer, "\r\n  please set sleep time (1 - 864000) > ", gAllowToBlock_d );
   2221          
   2222                  IsChar();
   2223          
   2224                  for( findIndex = 0; findIndex < 6; findIndex++ )
   2225                  {
   2226                      if( isAsciiDec(CommDataBuffer[findIndex]) )
   2227                      {
   2228                          tmpValue += AsciiToDec( CommDataBuffer[findIndex] );
   2229                      }
   2230                      else
   2231                      {
   2232                          tmpValue = 0;
   2233                          break;
   2234                      }
   2235          
   2236                      if( '\0' == CommDataBuffer[findIndex+1] )
   2237                      {
   2238                          break;
   2239                      }
   2240          
   2241                      tmpValue *= 10;
   2242                  }
   2243          
   2244                  if( (0 < tmpValue) && (tmpValue <= MAX_SLEEP_TIME) )
   2245                  {
   2246                      mTermParam.SleepTime = tmpValue;
   2247          
   2248                      Serial_Print( mAppSer, "\r\n  sleep time is ", gAllowToBlock_d );
   2249                      Serial_PrintDec( mAppSer, mTermParam.SleepTime );
   2250                  }
   2251                  else
   2252                  {
   2253                      Serial_Print( mAppSer, "\r\n  sleep time is invalid.", gAllowToBlock_d );
   2254                  }
   2255          
   2256                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   2257              }
   2258              /* processor mode */
   2259              else
   2260              {
   2261                  for( findIndex = 0; findIndex < 6; findIndex++ )
   2262                  {
   2263                      if( isAsciiDec(CommDataBuffer[nameLen+1+findIndex]) )
   2264                      {
   2265                          tmpValue += AsciiToDec( CommDataBuffer[nameLen+1+findIndex] );
   2266                      }
   2267                      else
   2268                      {
   2269                          tmpValue = 0;
   2270                          break;
   2271                      }
   2272          
   2273                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   2274                      {
   2275                          break;
   2276                      }
   2277          
   2278                      tmpValue *= 10;
   2279                  }
   2280          
   2281                  if( (0 < tmpValue) && (tmpValue <= MAX_SLEEP_TIME) )
   2282                  {
   2283                      mTermParam.SleepTime = tmpValue;
   2284          
   2285                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2286                  }
   2287                  else
   2288                  {
   2289                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   2290                  }
   2291              }
   2292          }
   2293          
   2294          /***********************************************************************************
   2295          * CommExecSetPower
   2296          *
   2297          * Interface assumptions:
   2298          *     index         command index
   2299          *     nameLen       command name length
   2300          *
   2301          * Return value:
   2302          *     None
   2303          *
   2304          ************************************************************************************/
   2305          static void CommExecSetPower( int index, int nameLen )
   2306          {
   2307              int32_t tmpValue = 0;
   2308              uint8_t findIndex;
   2309              bool_t  isMinus = FALSE;
   2310          
   2311          
   2312              /* terminal mode */
   2313              if( TERMINAL == mTermParam.Mode )
   2314              {
   2315                  Serial_Print( mAppSer, "\r\n  please set output power (-4 - 13) > ", gAllowToBlock_d );
   2316          
   2317                  IsChar();
   2318          
   2319                  for( findIndex = 0; findIndex < 3; findIndex++ )
   2320                  {
   2321                      if( (0 == findIndex) && ('-' == CommDataBuffer[0]) )
   2322                      {
   2323                          isMinus = TRUE;
   2324                          continue;
   2325                      }
   2326          
   2327                      if( isAsciiDec(CommDataBuffer[findIndex]) )
   2328                      {
   2329                          tmpValue += AsciiToDec( CommDataBuffer[findIndex] );
   2330                      }
   2331                      else
   2332                      {
   2333                          tmpValue = 0xff;
   2334                          break;
   2335                      }
   2336          
   2337                      if( '\0' == CommDataBuffer[findIndex+1] )
   2338                      {
   2339                          break;
   2340                      }
   2341          
   2342                      tmpValue *= 10;
   2343                  }
   2344          
   2345                  if( TRUE == isMinus )
   2346                  {
   2347                      tmpValue = -tmpValue;
   2348                  }
   2349          
   2350                  if( (MIN_POWER <= tmpValue) && (tmpValue <= MAX_POWER) )
   2351                  {
   2352                      mTermParam.Power = tmpValue;
   2353          
   2354                      Serial_Print( mAppSer, "\r\n  output power is ", gAllowToBlock_d );
   2355                      if( TRUE == isMinus )
   2356                      {
   2357                          Serial_Print( mAppSer, "-", gAllowToBlock_d );
   2358                          Serial_PrintDec( mAppSer, -mTermParam.Power );
   2359                      }
   2360                      else
   2361                      {
   2362                          Serial_PrintDec( mAppSer, mTermParam.Power );
   2363                      }
   2364                  }
   2365                  else
   2366                  {
   2367                      Serial_Print( mAppSer, "\r\n  output power is invalid.", gAllowToBlock_d );
   2368                  }
   2369          
   2370                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   2371              }
   2372              /* processor mode */
   2373              else
   2374              {
   2375                  for( findIndex = 0; findIndex < 3; findIndex++ )
   2376                  {
   2377                      if( (0 == findIndex) && ('-' == CommDataBuffer[nameLen+1]) )
   2378                      {
   2379                          isMinus = TRUE;
   2380                          continue;
   2381                      }
   2382          
   2383                      if( isAsciiDec(CommDataBuffer[nameLen+1+findIndex]) )
   2384                      {
   2385                          tmpValue += AsciiToDec( CommDataBuffer[nameLen+1+findIndex] );
   2386                      }
   2387                      else
   2388                      {
   2389                          tmpValue = 0xff;
   2390                          break;
   2391                      }
   2392          
   2393                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   2394                      {
   2395                          break;
   2396                      }
   2397          
   2398                      tmpValue *= 10;
   2399                  }
   2400          
   2401                  if( TRUE == isMinus )
   2402                  {
   2403                      tmpValue = -tmpValue;
   2404                  }
   2405          
   2406                  if( (MIN_POWER <= tmpValue) && (tmpValue <= MAX_POWER) )
   2407                  {
   2408                      mTermParam.Power = tmpValue;
   2409          
   2410                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2411                  }
   2412                  else
   2413                  {
   2414                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   2415                  }
   2416              }
   2417          }
   2418          
   2419          /***********************************************************************************
   2420          * CommExecSetFormat
   2421          *
   2422          * Interface assumptions:
   2423          *     index         command index
   2424          *     nameLen       command name length
   2425          *
   2426          * Return value:
   2427          *     None
   2428          *
   2429          ************************************************************************************/
   2430          static void CommExecSetFormat( int index, int nameLen )
   2431          {
   2432              uint8_t tmpMode = 0;
   2433          
   2434          
   2435              /* terminal mode */
   2436              if( TERMINAL == mTermParam.Mode )
   2437              {
   2438                  PrintMessage( cuFormatMenu );
   2439          
   2440                  IsChar();
   2441          
   2442                  if( isAsciiHex(CommDataBuffer[0]) )
   2443                  {
   2444                      tmpMode = AsciiToHex( CommDataBuffer[0] );
   2445                  }
   2446          
   2447                  switch( tmpMode )
   2448                  {
   2449                  case FMT_ASCII:
   2450                      mTermParam.Format = FMT_ASCII;
   2451                      Serial_Print( mAppSer, "\r\n  ASCII format is selected.", gAllowToBlock_d );
   2452                      break;
   2453          
   2454                  case FMT_BINARY:
   2455                      mTermParam.Format = FMT_BINARY;
   2456                      Serial_Print( mAppSer, "\r\n  BINARY format is selected.", gAllowToBlock_d );
   2457                      break;
   2458          
   2459                  default:
   2460                      Serial_Print( mAppSer, "\r\n  selected number is invalid.", gAllowToBlock_d );
   2461                      break;
   2462                  }
   2463          
   2464                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   2465              }
   2466              /* processor mode */
   2467              else
   2468              {
   2469                  if( isAsciiHex(CommDataBuffer[nameLen+1]) )
   2470                  {
   2471                      tmpMode = AsciiToHex( CommDataBuffer[nameLen+1] );
   2472                  }
   2473          
   2474                  if( (FMT_ASCII == tmpMode) || (FMT_BINARY == tmpMode) )
   2475                  {
   2476                      mTermParam.Format = tmpMode;
   2477          
   2478                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2479                  }
   2480                  else
   2481                  {
   2482                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   2483                  }
   2484              }
   2485          }
   2486          
   2487          /***********************************************************************************
   2488          * CommExecSetSendTime
   2489          *
   2490          * Interface assumptions:
   2491          *     index         command index
   2492          *     nameLen       command name length
   2493          *
   2494          * Return value:
   2495          *     None
   2496          *
   2497          ************************************************************************************/
   2498          static void CommExecSetSendTime( int index, int nameLen )
   2499          {
   2500              uint32_t tmpValue = 0;
   2501              uint8_t findIndex;
   2502          
   2503          
   2504              /* terminal mode */
   2505              if( TERMINAL == mTermParam.Mode )
   2506              {
   2507                  Serial_Print( mAppSer, "\r\n  please set send time (0 - 86400) > ", gAllowToBlock_d );
   2508          
   2509                  IsChar();
   2510          
   2511                  for( findIndex = 0; findIndex < 5; findIndex++ )
   2512                  {
   2513                      if( isAsciiDec(CommDataBuffer[findIndex]) )
   2514                      {
   2515                          tmpValue += AsciiToDec( CommDataBuffer[findIndex] );
   2516                      }
   2517                      else
   2518                      {
   2519                          tmpValue = 0xFFFFFFFF;
   2520                          break;
   2521                      }
   2522          
   2523                      if( '\0' == CommDataBuffer[findIndex+1] )
   2524                      {
   2525                          break;
   2526                      }
   2527          
   2528                      tmpValue *= 10;
   2529                  }
   2530          
   2531                  if( tmpValue <= MAX_SEND_TIME )
   2532                  {
   2533                      mTermParam.SendTime = tmpValue;
   2534          
   2535                      Serial_Print( mAppSer, "\r\n  send time is ", gAllowToBlock_d );
   2536                      Serial_PrintDec( mAppSer, mTermParam.SendTime );
   2537                  }
   2538                  else
   2539                  {
   2540                      Serial_Print( mAppSer, "\r\n  send time is invalid.", gAllowToBlock_d );
   2541                  }
   2542          
   2543                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   2544              }
   2545              /* processor mode */
   2546              else
   2547              {
   2548                  for( findIndex = 0; findIndex < 5; findIndex++ )
   2549                  {
   2550                      if( isAsciiDec(CommDataBuffer[nameLen+1+findIndex]) )
   2551                      {
   2552                          tmpValue += AsciiToDec( CommDataBuffer[nameLen+1+findIndex] );
   2553                      }
   2554                      else
   2555                      {
   2556                          tmpValue = 0xFFFFFFFF;
   2557                          break;
   2558                      }
   2559          
   2560                      if( '\0' == CommDataBuffer[nameLen+1+findIndex+1] )
   2561                      {
   2562                          break;
   2563                      }
   2564          
   2565                      tmpValue *= 10;
   2566                  }
   2567          
   2568                  if( tmpValue <= MAX_SEND_TIME )
   2569                  {
   2570                      mTermParam.SendTime = tmpValue;
   2571          
   2572                      Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2573                  }
   2574                  else
   2575                  {
   2576                      Serial_Print( mAppSer, "NG 002\r\n", gAllowToBlock_d );
   2577                  }
   2578              }
   2579          }
   2580          
   2581          /***********************************************************************************
   2582          * CommExecSetSendData
   2583          *
   2584          * Interface assumptions:
   2585          *     index         command index
   2586          *     nameLen       command name length
   2587          *
   2588          * Return value:
   2589          *     None
   2590          *
   2591          ************************************************************************************/
   2592          static void CommExecSetSendData( int index, int nameLen )
   2593          {
   2594              /* terminal mode */
   2595              if( TERMINAL == mTermParam.Mode )
   2596              {
   2597                  Serial_Print( mAppSer, "\r\n  please set send data > ", gAllowToBlock_d );
   2598          
   2599                  IsChar();
   2600          
   2601                  FLib_MemCpy( mTermParam.SendData, CommDataBuffer, 50 );
   2602                  mTermParam.SendData[50] = '\0';
   2603          
   2604          
   2605                  Serial_Print( mAppSer, "\r\n  send data is ", gAllowToBlock_d );
   2606                  Serial_Print( mAppSer, (char*)mTermParam.SendData, gAllowToBlock_d );
   2607                  Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   2608              }
   2609              /* processor mode */
   2610              else
   2611              {
   2612                  FLib_MemCpy( mTermParam.SendData, &CommDataBuffer[nameLen+1], 50 );
   2613                  mTermParam.SendData[50] = '\0';
   2614                  Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2615              }
   2616          }
   2617          
   2618          /***********************************************************************************
   2619          * CommExecVersion
   2620          *
   2621          * Interface assumptions:
   2622          *     index         command index
   2623          *     nameLen       command name length
   2624          *
   2625          * Return value:
   2626          *     None
   2627          *
   2628          ************************************************************************************/
   2629          static void CommExecVersion( int index, int nameLen )
   2630          {
   2631              if( TERMINAL == mTermParam.Mode )
   2632              {
   2633                  Serial_Print( mAppSer, "\r\n", gAllowToBlock_d );
   2634              }
   2635          
   2636              Serial_Print( mAppSer, (char*)cu8Version, gAllowToBlock_d );
   2637              Serial_Print( mAppSer, "\r\n", gAllowToBlock_d );
   2638          
   2639              if( TERMINAL == mTermParam.Mode )
   2640              {
   2641                  Serial_Print( mAppSer, "\r\n", gAllowToBlock_d );
   2642              }
   2643          }
   2644          
   2645          /***********************************************************************************
   2646          * CommExecSaveParameter
   2647          *
   2648          * Interface assumptions:
   2649          *     index         command index
   2650          *     nameLen       command name length
   2651          *
   2652          * Return value:
   2653          *     None
   2654          *
   2655          ************************************************************************************/
   2656          static void CommExecSaveParameter( int index, int nameLen )
   2657          {
   2658              uint32_t    length;
   2659              uint32_t    ret;
   2660          
   2661          
   2662              if( TERMINAL == mTermParam.Mode )
   2663              {
   2664                  Serial_Print( mAppSer, "\r\nsave parameter ...", gAllowToBlock_d );
   2665              }
   2666          
   2667              _int_disable();
   2668          
   2669              ret = FLASH_EraseSector( FLASH_PARAM_TOP );
   2670              if( 0 != ret )
   2671              {
   2672                  if( TERMINAL == mTermParam.Mode )
   2673                  {
   2674                      Serial_Print( mAppSer, " FlashROM erase error\r\n\r\n", gAllowToBlock_d );
   2675                  }
   2676                  else
   2677                  {
   2678                      Serial_Print( mAppSer, "NG 003\r\n", gAllowToBlock_d );
   2679                  }
   2680          
   2681                  _int_enable();
   2682          
   2683                  return;
   2684              }
   2685          
   2686              length = sizeof(mTermParam) + ((sizeof(mTermParam) % 4) ? (4 - sizeof(mTermParam) % 4) : 0);
   2687          
   2688              ret = FLASH_ProgramSectionByLongs( FLASH_PARAM_TOP, (uint32_t*)&mTermParam, (length / sizeof(uint32_t)) );
   2689              if( 0 != ret )
   2690              {
   2691                  if( TERMINAL == mTermParam.Mode )
   2692                  {
   2693                      Serial_Print( mAppSer, " FlashROM write error\r\n\r\n", gAllowToBlock_d );
   2694                  }
   2695                  else
   2696                  {
   2697                      Serial_Print( mAppSer, "NG 004\r\n", gAllowToBlock_d );
   2698                  }
   2699          
   2700                  _int_enable();
   2701          
   2702                  return;
   2703              }
   2704          
   2705              _int_enable();
   2706          
   2707              if( TERMINAL == mTermParam.Mode )
   2708              {
   2709                  Serial_Print( mAppSer, " Done\r\n\r\n", gAllowToBlock_d );
   2710              }
   2711              else
   2712              {
   2713                  Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2714              }
   2715          }
   2716          
   2717          /***********************************************************************************
   2718          * CommExecLoadParameter
   2719          *
   2720          * Interface assumptions:
   2721          *     index         command index
   2722          *     nameLen       command name length
   2723          *
   2724          * Return value:
   2725          *     None
   2726          *
   2727          ************************************************************************************/
   2728          static void CommExecLoadParameter( int index, int nameLen )
   2729          {
   2730              SettingDefaultValue();
   2731          
   2732              if( PROCESSOR == mTermParam.Mode )
   2733              {
   2734                  Serial_Print( mAppSer, "OK\r\n", gAllowToBlock_d );
   2735              }
   2736          
   2737              Serial_SetBaudRate( mAppSer, mTermParam.Baudrate );
   2738          }
   2739          
   2740          /***********************************************************************************
   2741          * CommExecShow
   2742          *
   2743          * Interface assumptions:
   2744          *     index         command index
   2745          *     nameLen       command name length
   2746          *
   2747          * Return value:
   2748          *     None
   2749          *
   2750          ************************************************************************************/
   2751          static void CommExecShow( int index, int nameLen )
   2752          {
   2753              Serial_Print( mAppSer, "\r\n  configuration setting is below.", gAllowToBlock_d );
   2754              Serial_Print( mAppSer, "\r\n  -------------------------------------", gAllowToBlock_d );
   2755          
   2756              Serial_Print( mAppSer, "\r\n  Node                        : ", gAllowToBlock_d );
   2757              if( COORDINATOR == mTermParam.Node )
   2758              {
   2759                  Serial_Print( mAppSer, "Coordinator", gAllowToBlock_d );
   2760              }
   2761              else if( END_DEVICE == mTermParam.Node )
   2762              {
   2763                  Serial_Print( mAppSer, "EndDevice", gAllowToBlock_d );
   2764              }
   2765          #ifdef _STATIC_ROUTING_
   2766              else
   2767              {
   2768                  Serial_Print( mAppSer, "Router", gAllowToBlock_d );
   2769              }
   2770          #endif
   2771          
   2772              WDG_Refresh();
   2773          
   2774              Serial_Print( mAppSer, "\r\n  Band Width                  : ", gAllowToBlock_d );
   2775              if( BANDWIDTH31_25 == mTermParam.Bw )
   2776              {
   2777                  Serial_Print( mAppSer, "31.25kHz", gAllowToBlock_d );
   2778              }
   2779              else if( BANDWIDTH41_7 == mTermParam.Bw )
   2780              {
   2781                  Serial_Print( mAppSer, "41.7kHz", gAllowToBlock_d );
   2782              }
   2783              else if( BANDWIDTH62_5 == mTermParam.Bw )
   2784              {
   2785                  Serial_Print( mAppSer, "62.5kHz", gAllowToBlock_d );
   2786              }
   2787              else if( BANDWIDTH125 == mTermParam.Bw )
   2788              {
   2789                  Serial_Print( mAppSer, "125kHz", gAllowToBlock_d );
   2790              }
   2791              else if( BANDWIDTH250 == mTermParam.Bw )
   2792              {
   2793                  Serial_Print( mAppSer, "250kHz", gAllowToBlock_d );
   2794              }
   2795              else
   2796              {
   2797                  Serial_Print( mAppSer, "500kHz", gAllowToBlock_d );
   2798              }
   2799          
   2800              Serial_Print( mAppSer, "\r\n  Spreading Factor            : ", gAllowToBlock_d );
   2801              Serial_PrintDec( mAppSer, mTermParam.Sf );
   2802          
   2803              Serial_Print( mAppSer, "\r\n  Effective Bitrate           : ", gAllowToBlock_d );
   2804              Serial_PrintDec( mAppSer, gDataRate[mTermParam.Bw][mTermParam.Sf-7] );
   2805              Serial_Print( mAppSer, "bps", gAllowToBlock_d );
   2806          
   2807              Serial_Print( mAppSer, "\r\n  Channel                     : ", gAllowToBlock_d );
   2808              Serial_PrintDec( mAppSer, mTermParam.Channel );
   2809          
   2810              Serial_Print( mAppSer, "\r\n  PAN ID                      : ", gAllowToBlock_d );
   2811              Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.PanId, 2, 0 );
   2812          
   2813              Serial_Print( mAppSer, "\r\n  Own Node ID                 : ", gAllowToBlock_d );
   2814              Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.SrcId, 2, 0 );
   2815          
   2816              Serial_Print( mAppSer, "\r\n  Destination ID              : ", gAllowToBlock_d );
   2817              Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.DstId, 2, 0 );
   2818          
   2819          #ifdef _STATIC_ROUTING_
   2820              WDG_Refresh();
   2821          
   2822              Serial_Print( mAppSer, "\r\n  Hop Count                   : ", gAllowToBlock_d );
   2823              Serial_PrintDec( mAppSer, mTermParam.HopCnt );
   2824          
   2825              Serial_Print( mAppSer, "\r\n  End ID                      : ", gAllowToBlock_d );
   2826              Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.EndId, 2, 0 );
   2827          
   2828              Serial_Print( mAppSer, "\r\n  1st Route ID                : ", gAllowToBlock_d );
   2829              Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.Route[0], 2, 0 );
   2830          
   2831              Serial_Print( mAppSer, "\r\n  2nd Route ID                : ", gAllowToBlock_d );
   2832              Serial_PrintHex( mAppSer, (uint8_t*)&mTermParam.Route[1], 2, 0 );
   2833          #endif
   2834          
   2835              WDG_Refresh();
   2836          
   2837              Serial_Print( mAppSer, "\r\n  Acknowledge                 : ", gAllowToBlock_d );
   2838              if( MODE_ON == mTermParam.Ack )
   2839              {
   2840                  Serial_Print( mAppSer, "ON", gAllowToBlock_d );
   2841              }
   2842              else
   2843              {
   2844                  Serial_Print( mAppSer, "OFF", gAllowToBlock_d );
   2845              }
   2846          
   2847              Serial_Print( mAppSer, "\r\n  Retry count                 : ", gAllowToBlock_d );
   2848              Serial_PrintDec( mAppSer, mTermParam.Retry );
   2849          
   2850              Serial_Print( mAppSer, "\r\n  Transfer Mode               : ", gAllowToBlock_d );
   2851              if( TRANS_PAYLOAD == mTermParam.TransMode )
   2852              {
   2853                  Serial_Print( mAppSer, "Payload", gAllowToBlock_d );
   2854              }
   2855              else
   2856              {
   2857                  Serial_Print( mAppSer, "Frame", gAllowToBlock_d );
   2858              }
   2859          
   2860              WDG_Refresh();
   2861          
   2862              Serial_Print( mAppSer, "\r\n  Receive Node ID information : ", gAllowToBlock_d );
   2863              if( MODE_ON == mTermParam.RcvId )
   2864              {
   2865                  Serial_Print( mAppSer, "ON", gAllowToBlock_d );
   2866              }
   2867              else
   2868              {
   2869                  Serial_Print( mAppSer, "OFF", gAllowToBlock_d );
   2870              }
   2871          
   2872              Serial_Print( mAppSer, "\r\n  RSSI information            : ", gAllowToBlock_d );
   2873              if( MODE_ON == mTermParam.Rssi )
   2874              {
   2875                  Serial_Print( mAppSer, "ON", gAllowToBlock_d );
   2876              }
   2877              else
   2878              {
   2879                  Serial_Print( mAppSer, "OFF", gAllowToBlock_d );
   2880              }
   2881          
   2882              Serial_Print( mAppSer, "\r\n  Config/Operation            : ", gAllowToBlock_d );
   2883              if( CONFIG == mTermParam.Operation )
   2884              {
   2885                  Serial_Print( mAppSer, "Configuration", gAllowToBlock_d );
   2886              }
   2887              else
   2888              {
   2889                  Serial_Print( mAppSer, "Operation", gAllowToBlock_d );
   2890              }
   2891          
   2892              Serial_Print( mAppSer, "\r\n  UART baudrate               : ", gAllowToBlock_d );
   2893              Serial_PrintDec( mAppSer, mTermParam.Baudrate );
   2894          
   2895              WDG_Refresh();
   2896          
   2897              Serial_Print( mAppSer, "\r\n  Sleep Mode                  : ", gAllowToBlock_d );
   2898              if( NO_SLEEP == mTermParam.Sleep )
   2899              {
   2900                  Serial_Print( mAppSer, "No Sleep", gAllowToBlock_d );
   2901              }
   2902              else if( TIMER_WAKEUP == mTermParam.Sleep )
   2903              {
   2904                  Serial_Print( mAppSer, "Timer Wakeup", gAllowToBlock_d );
   2905              }
   2906              else
   2907              {
   2908                  Serial_Print( mAppSer, "INT Wakeup", gAllowToBlock_d );
   2909              }
   2910          
   2911              Serial_Print( mAppSer, "\r\n  Sleep Time                  : ", gAllowToBlock_d );
   2912              Serial_PrintDec( mAppSer, mTermParam.SleepTime );
   2913          
   2914              Serial_Print( mAppSer, "\r\n  Output Power                : ", gAllowToBlock_d );
   2915              if( mTermParam.Power < 0 )
   2916              {
   2917                  Serial_Print( mAppSer, "-", gAllowToBlock_d );
   2918                  Serial_PrintDec( mAppSer, -mTermParam.Power );
   2919              }
   2920              else
   2921              {
   2922                  Serial_PrintDec( mAppSer, mTermParam.Power );
   2923              }
   2924              Serial_Print( mAppSer, "dBm", gAllowToBlock_d );
   2925          
   2926              WDG_Refresh();
   2927          
   2928              Serial_Print( mAppSer, "\r\n  Format                      : ", gAllowToBlock_d );
   2929              if( FMT_ASCII == mTermParam.Format )
   2930              {
   2931                  Serial_Print( mAppSer, "ASCII", gAllowToBlock_d );
   2932              }
   2933              else
   2934              {
   2935                  Serial_Print( mAppSer, "BINARY", gAllowToBlock_d );
   2936              }
   2937          
   2938              Serial_Print( mAppSer, "\r\n  Send Time                   : ", gAllowToBlock_d );
   2939              Serial_PrintDec( mAppSer, mTermParam.SendTime );
   2940          
   2941              WDG_Refresh();
   2942          
   2943              Serial_Print( mAppSer, "\r\n  Send Data                   : ", gAllowToBlock_d );
   2944              Serial_Print( mAppSer, (char*)mTermParam.SendData, gAllowToBlock_d );
   2945          
   2946              Serial_Print( mAppSer, "\r\n\r\n", gAllowToBlock_d );
   2947          }
   2948          
   2949          /***********************************************************************************
   2950          * CommExecHelp
   2951          *
   2952          * Interface assumptions:
   2953          *     index         command index
   2954          *     nameLen       command name length
   2955          *
   2956          * Return value:
   2957          *     None
   2958          *
   2959          ************************************************************************************/
   2960          static void CommExecHelp( int index, int nameLen )
   2961          {
   2962              PrintMessage( cu8MainMenu );
   2963          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CommExecHelp
        16   -> PrintMessage
      16   CommExecLoadParameter
        16   -> Serial_Print
        16   -> Serial_SetBaudRate
        16   -> SettingDefaultValue
      32   CommExecSaveParameter
        32   -> FLASH_EraseSector
        32   -> FLASH_ProgramSectionByLongs
        32   -> Serial_Print
        32   -> _int_disable
        32   -> _int_enable
      32   CommExecSelectBandWidth
        32   -> IsChar
        32   -> PrintMessage
        32   -> Serial_Print
        32   -> Serial_PrintDec
      24   CommExecSelectBaudrate
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
        24   -> Serial_SetBaudRate
      24   CommExecSelectNode
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
      24   CommExecSelectOperation
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
      24   CommExecSelectRcvId
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
      24   CommExecSelectRssi
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
      24   CommExecSelectSleep
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
      24   CommExecSelectTransMode
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
      24   CommExecSetAck
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
      32   CommExecSetChannel
        32   -> IsChar
        32   -> Serial_Print
        32   -> Serial_PrintDec
      24   CommExecSetDestinationId
        24   -> IsChar
        24   -> Serial_Print
        24   -> Serial_PrintHex
      24   CommExecSetFormat
        24   -> IsChar
        24   -> PrintMessage
        24   -> Serial_Print
      24   CommExecSetPanId
        24   -> IsChar
        24   -> Serial_Print
        24   -> Serial_PrintHex
      32   CommExecSetPower
        32   -> IsChar
        32   -> Serial_Print
        32   -> Serial_PrintDec
      24   CommExecSetRetry
        24   -> IsChar
        24   -> Serial_Print
        24   -> Serial_PrintDec
      24   CommExecSetSendData
        24   -> FLib_MemCpy
        24   -> IsChar
        24   -> Serial_Print
      24   CommExecSetSendTime
        24   -> IsChar
        24   -> Serial_Print
        24   -> Serial_PrintDec
      32   CommExecSetSleepTime
        32   -> IsChar
        32   -> Serial_Print
        32   -> Serial_PrintDec
      24   CommExecSetSourceId
        24   -> IsChar
        24   -> Serial_Print
        24   -> Serial_PrintHex
      32   CommExecSetSpreadingFactor
        32   -> IsChar
        32   -> Serial_Print
        32   -> Serial_PrintDec
      32   CommExecShow
        32   -> Serial_Print
        32   -> Serial_PrintDec
        32   -> Serial_PrintHex
      24   CommExecVersion
        24   -> Serial_Print
      24   CommRxCallBack
        24   -> Serial_Read
      16   CommShowModeSel
        16   -> Serial_Print
      24   CommShowPrompt
        24   -> Serial_Print
      40   DoConfiguration
        40   -- Indirect call
        40   -> CommShowPrompt
        40   -> IsChar
        40   -> PrintMessage
        40   -> SelectMode
        40   -> Serial_Print
        40   -> strcmp
        40   -> strlen
       4   IsChar
      16   PrintMessage
        16   -> Serial_Print
      16   SelectMode
        16   -> CommShowModeSel
        16   -> IsChar
        16   -> Serial_Print
        16   -> strcmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_17
       4  ??DataTable29_18
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
       4  ??DataTable3
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_14
       4  ??DataTable31_15
       4  ??DataTable31_16
       4  ??DataTable31_17
       4  ??DataTable31_18
       4  ??DataTable31_19
       4  ??DataTable31_2
       4  ??DataTable31_20
       4  ??DataTable31_21
       4  ??DataTable31_22
       4  ??DataTable31_23
       4  ??DataTable31_24
       4  ??DataTable31_25
       4  ??DataTable31_26
       4  ??DataTable31_27
       4  ??DataTable31_28
       4  ??DataTable31_29
       4  ??DataTable31_3
       4  ??DataTable31_30
       4  ??DataTable31_31
       4  ??DataTable31_32
       4  ??DataTable31_33
       4  ??DataTable31_34
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       4  ?_0
      24  ?_1
      36  ?_10
      40  ?_100
      40  ?_101
      28  ?_102
      32  ?_103
      32  ?_104
      28  ?_105
      28  ?_106
      28  ?_107
      28  ?_108
      28  ?_109
      40  ?_11
      32  ?_110
      32  ?_111
      32  ?_112
      36  ?_113
      36  ?_114
      44  ?_115
      20  ?_116
      28  ?_117
      44  ?_118
      24  ?_119
      40  ?_12
       2  ?_120
      32  ?_121
      32  ?_122
      32  ?_123
      40  ?_124
      20  ?_125
      28  ?_126
      28  ?_127
      20  ?_128
      24  ?_129
      40  ?_13
      28  ?_130
      12  ?_131
      28  ?_132
      12  ?_133
      12  ?_134
      36  ?_135
      44  ?_136
      36  ?_137
      12  ?_138
      12  ?_139
      40  ?_14
      36  ?_140
      12  ?_141
       8  ?_142
       8  ?_143
       8  ?_144
       8  ?_145
       8  ?_146
      36  ?_147
      36  ?_148
       4  ?_149
      52  ?_15
      36  ?_150
      36  ?_151
      36  ?_152
      36  ?_153
      36  ?_154
       4  ?_155
       4  ?_156
      36  ?_157
      36  ?_158
       8  ?_159
      40  ?_16
       8  ?_160
      36  ?_161
      36  ?_162
      36  ?_163
      16  ?_164
      12  ?_165
      36  ?_166
      36  ?_167
      12  ?_168
      16  ?_169
      52  ?_17
      12  ?_170
      36  ?_171
      36  ?_172
       4  ?_173
      36  ?_174
       8  ?_175
       8  ?_176
      36  ?_177
      36  ?_178
      40  ?_18
      36  ?_19
      12  ?_2
      48  ?_20
      36  ?_21
      36  ?_22
      36  ?_23
      44  ?_24
      36  ?_25
      40  ?_26
      36  ?_27
      44  ?_28
      40  ?_29
      24  ?_3
      24  ?_30
      12  ?_31
      12  ?_32
      24  ?_33
      12  ?_34
      16  ?_35
      16  ?_36
      16  ?_37
      16  ?_38
      16  ?_39
      48  ?_4
      20  ?_40
      20  ?_41
      24  ?_42
      20  ?_43
      16  ?_44
      16  ?_45
      16  ?_46
      16  ?_47
      16  ?_48
      20  ?_49
      52  ?_5
      20  ?_50
      16  ?_51
      16  ?_52
      16  ?_53
      16  ?_54
       8  ?_55
       8  ?_56
       2  ?_57
      12  ?_58
      12  ?_59
      36  ?_6
      12  ?_60
       2  ?_61
       2  ?_62
      12  ?_63
       2  ?_64
       2  ?_65
      32  ?_66
      28  ?_67
      32  ?_68
       8  ?_69
      40  ?_7
      28  ?_70
      24  ?_71
      24  ?_72
      24  ?_73
      24  ?_74
       8  ?_75
      44  ?_76
      28  ?_77
      36  ?_78
      36  ?_79
      32  ?_8
      36  ?_80
      36  ?_81
      16  ?_82
      24  ?_83
      40  ?_84
      20  ?_85
      24  ?_86
      44  ?_87
      24  ?_88
      28  ?_89
      32  ?_9
      48  ?_90
      28  ?_91
      32  ?_92
      24  ?_93
      24  ?_94
      40  ?_95
      20  ?_96
      28  ?_97
      32  ?_98
      28  ?_99
      14  CommExecHelp
      44  CommExecLoadParameter
     184  CommExecSaveParameter
     544  CommExecSelectBandWidth
     528  CommExecSelectBaudrate
     314  CommExecSelectNode
     314  CommExecSelectOperation
     314  CommExecSelectRcvId
     314  CommExecSelectRssi
     346  CommExecSelectSleep
     314  CommExecSelectTransMode
     314  CommExecSetAck
     410  CommExecSetChannel
     490  CommExecSetDestinationId
     314  CommExecSetFormat
     526  CommExecSetPanId
     410  CommExecSetPower
     298  CommExecSetRetry
     116  CommExecSetSendData
     286  CommExecSetSendTime
     298  CommExecSetSleepTime
     510  CommExecSetSourceId
     366  CommExecSetSpreadingFactor
     884  CommExecShow
      66  CommExecVersion
     138  CommRxCallBack
      38  CommShowModeSel
     116  CommShowPrompt
     300  DoConfiguration
      28  IsChar
      56  PrintMessage
     170  SelectMode
     520  command1
      24  cu8Logo
     120  cu8MainMenu
      40  cu8ModeSel
       8  cu8Prompt
      12  cu8Version
      36  cuBaudrateMenu
      28  cuBwMenu
      20  cuFormatMenu
      20  cuNodeMenu
      20  cuOnOffMenu
      20  cuOperationMenu
      24  cuSleepMenu
      20  cuTransMenu

 
  5'524 bytes in section .rodata
 10'360 bytes in section .text
 
 10'360 bytes of CODE  memory
  5'524 bytes of CONST memory

Errors: none
Warnings: none
