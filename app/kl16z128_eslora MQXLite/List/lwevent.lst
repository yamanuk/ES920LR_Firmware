###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         14/May/2020  16:50:59
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\lwevent.c
#    Command line      =
#        -f C:\Users\81901\AppData\Local\Temp\EW570F.tmp
#        (C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\lwevent.c
#        --preprocess=s
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -lcN
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -o
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\include\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\config\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\compiler\iar\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Generated_Code\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\PExSupport\Kinetis\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\OSAbstraction\MQXLite\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Common\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\Lists\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\FunctionLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\SecLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Panic\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\SerialManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\MemManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Messaging\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\Phy\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\SMAC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\ADC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\BME\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Flash\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\I2C\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LED\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LLWU\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LPTMR\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\SMC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\MCG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Reset\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List\lwevent.lst
#    Object file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj\lwevent.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\lwevent.c
      1          /*HEADER**********************************************************************
      2           *
      3           * Copyright (c) 2008 Freescale Semiconductor;
      4           * All Rights Reserved
      5           *
      6           * Copyright (c) 2004-2008 Embedded Access Inc.;
      7           * All Rights Reserved
      8           *
      9           * Copyright (c) 1989-2008 ARC International;
     10           * All Rights Reserved
     11           *
     12           *****************************************************************************
     13           *
     14           * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
     15           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     16           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     17           * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     18           * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     19           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     20           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     21           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     22           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     23           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     24           * THE POSSIBILITY OF SUCH DAMAGE.
     25           *
     26           *****************************************************************************
     27           *
     28           * $FileName: lwevent.c$
     29           * $Version : 3.8.0.4$
     30           * $Date    : Mar-22-2012$
     31           *
     32           * Comments:
     33           *  This file contains the functions for lwevent object.
     34           *
     35           *END************************************************************************/
     36          
     37          #include "mqx_inc.h"
     38          
     39          #if MQX_USE_LWEVENTS
     40          #include "lwevent.h"
     41          #include "lwevent_prv.h"
     42          
     43          /*!
     44           * \private
     45           *
     46           * \brief Used by a task to create an instance of a lightweight event.
     47           *
     48           * \param[in] event_ptr Pointer representing location of the event.
     49           * \param[in] flags     Flags for the light weight event.
     50           * \param[in] user      User mode
     51           *
     52           * \return MQX_OK
     53           * \return MQX_EINVAL
     54           * \return MQX_LWEVENT_INVALID
     55           *
     56           * \see _lwevent_create
     57           * \see LWEVENT_STRUCT
     58           */
     59          _mqx_uint _lwevent_create_internal
     60          (
     61              LWEVENT_STRUCT_PTR  event_ptr,
     62              _mqx_uint           flags,
     63              boolean             user
     64          )
     65          {
     66              KERNEL_DATA_STRUCT_PTR  kernel_data;
     67              LWEVENT_STRUCT_PTR      event_chk_ptr;
     68          
     69          #if MQX_ENABLE_USER_MODE
     70              if (user && !_psp_mem_check_access_mask((uint_32)event_ptr,
     71                                                       sizeof(LWEVENT_STRUCT),
     72                                                       MPU_UM_R, MPU_UM_RW) )
     73              {
     74                  return MQX_LWEVENT_INVALID;
     75              }
     76          #endif
     77          
     78              _GET_KERNEL_DATA(kernel_data);
     79          
     80              _KLOGE2(KLOG_lwevent_create, event_ptr);
     81          
     82              _QUEUE_INIT(&event_ptr->WAITING_TASKS, 0);
     83              event_ptr->VALUE = 0;
     84              event_ptr->FLAGS = flags;
     85          
     86              if (flags & LWEVENT_AUTO_CLEAR)
     87                  event_ptr->AUTO = ~0;
     88              else
     89                  event_ptr->AUTO = 0;
     90          
     91              _int_disable();
     92          
     93          #if MQX_ENABLE_USER_MODE
     94              if (user)
     95              {
     96                  if (kernel_data->USR_LWEVENTS.NEXT == NULL)
     97                  {
     98                      /* Initialize the light weight event queue */
     99                      _QUEUE_INIT(&kernel_data->USR_LWEVENTS, 0);
    100                  }
    101              }
    102              else
    103          #endif
    104              {
    105                  if (kernel_data->LWEVENTS.NEXT == NULL)
    106                  {
    107                      /* Initialize the light weight event queue */
    108                      _QUEUE_INIT(&kernel_data->LWEVENTS, 0);
    109                  }
    110              }
    111          
    112              event_ptr->VALID = LWEVENT_VALID;
    113          
    114          #if MQX_CHECK_ERRORS
    115              /* Check if lwevent is already initialized */
    116          #if MQX_ENABLE_USER_MODE
    117              if (user)
    118              {
    119                  event_chk_ptr = (LWEVENT_STRUCT_PTR)((pointer)kernel_data->USR_LWEVENTS.NEXT);
    120                  while (event_chk_ptr != (LWEVENT_STRUCT_PTR)((pointer)&kernel_data->USR_LWEVENTS))
    121                  {
    122                      if (event_chk_ptr == event_ptr)
    123                      {
    124                          _int_enable();
    125                          _KLOGX2(KLOG_lwevent_create, MQX_EINVAL);
    126                          return(MQX_EINVAL);
    127                      }
    128                      event_chk_ptr = (LWEVENT_STRUCT_PTR)((pointer)event_chk_ptr->LINK.NEXT);
    129                  }
    130              }
    131              else
    132          #endif
    133              {
    134                  event_chk_ptr = (LWEVENT_STRUCT_PTR) ((pointer) kernel_data->LWEVENTS.NEXT);
    135                  while (event_chk_ptr != (LWEVENT_STRUCT_PTR) ((pointer) &kernel_data->LWEVENTS))
    136                  {
    137                      if (event_chk_ptr == event_ptr)
    138                      {
    139                          _int_enable();
    140                          _KLOGX2(KLOG_lwevent_create, MQX_EINVAL);
    141                          return (MQX_EINVAL);
    142                      }
    143                      event_chk_ptr = (LWEVENT_STRUCT_PTR) ((pointer) event_chk_ptr->LINK.NEXT);
    144                  }
    145              }
    146          #endif
    147          
    148          #if MQX_ENABLE_USER_MODE
    149              if (user)
    150              {
    151                  _QUEUE_ENQUEUE(&kernel_data->USR_LWEVENTS, &event_ptr->LINK);
    152              }
    153              else
    154          #endif
    155              {
    156                  _QUEUE_ENQUEUE(&kernel_data->LWEVENTS, &event_ptr->LINK);
    157              }
    158          
    159              _int_enable();
    160          
    161              _KLOGX2(KLOG_lwevent_create, MQX_OK);
    162              return (MQX_OK);
    163          }
    164          
    165          
    166          /*!
    167           * \brief Used by a task to create an instance of a lightweight event.
    168           *
    169           * \param[in] event_ptr Pointer to the lightweight event to initialize.
    170           * \param[in] flags     Creation flag; one of the following:
    171           * \n - LWEVENT_AUTO_CLEAR - all bits in the lightweight event are made autoclearing.
    172           * \n - 0 - lightweight event bits are not set as autoclearing by default.
    173           * \n Note: The autoclearing bits can be changed any time later by calling
    174           * _lwevent_set_auto_clear.
    175           *
    176           * \return MQX_OK
    177           * \return MQX_EINVAL
    178           * \return MQX_LWEVENT_INVALID
    179           *
    180           * \warning Disables and enables interrupts.
    181           *
    182           * \see _lwevent_destroy
    183           * \see _lwevent_set
    184           * \see _lwevent_set_auto_clear
    185           * \see _lwevent_clear
    186           * \see _lwevent_test
    187           * \see _lwevent_wait_for
    188           * \see _lwevent_wait_ticks
    189           * \see _lwevent_wait_until
    190           * \see _lwevent_get_signalled
    191           * \see LWEVENT_STRUCT
    192           */
    193          _mqx_uint _lwevent_create
    194          (
    195              LWEVENT_STRUCT_PTR  event_ptr,
    196              _mqx_uint           flags
    197          )
    198          {
    199          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
    200              if (MQX_RUN_IN_USER_MODE)
    201              {
    202                  return _usr_lwevent_create(event_ptr, flags);
    203              }
    204          #endif
    205          
    206              return _lwevent_create_internal(event_ptr, flags, FALSE);
    207          }
    208          
    209          
    210          #if MQX_ENABLE_USER_MODE
    211          /*!
    212           * \brief Used by a task to create an instance of a lightweight event.
    213           *
    214           * This function is an equivalent to the _lwevent_create() API call but it can be
    215           * executed from within the User task or other code running in the CPU User mode.
    216           * Parameters passed to this function by pointer required to meet the memory
    217           * protection requirements as described in the parameter list below
    218           *
    219           * \param[in] event_ptr Read only. Pointer to the lightweight event to initialize.
    220           * \param[in] flags     Creation flag; one of the following:
    221           * \n - LWEVENT_AUTO_CLEAR - all bits in the lightweight event are made autoclearing.
    222           * \n - 0 - lightweight event bits are not set as autoclearing by default.
    223           * \n Note: The autoclearing bits can be changed any time later by calling
    224           * _usr_lwevent_set_auto_clear.
    225           *
    226           * \return MQX_OK
    227           * \return MQX_EINVAL
    228           * \return MQX_LWEVENT_INVALID
    229           *
    230           * \warning Disables and enables interrupts.
    231           *
    232           * \see _lwevent_create
    233           * \see _usr_lwevent_destroy
    234           * \see _usr_lwevent_set
    235           * \see _usr_lwevent_set_auto_clear
    236           * \see _usr_lwevent_clear
    237           * \see _usr_lwevent_wait_for
    238           * \see _usr_lwevent_wait_ticks
    239           * \see _usr_lwevent_wait_until
    240           * \see _usr_lwevent_get_signalled
    241           * \see LWEVENT_STRUCT
    242           */
    243          _mqx_uint _usr_lwevent_create
    244          (
    245              LWEVENT_STRUCT_PTR  event_ptr,
    246              _mqx_uint           flags
    247          )
    248          {
    249              MQX_API_CALL_PARAMS params = {  (uint_32)event_ptr,
    250                                              (uint_32)flags, 0, 0, 0};
    251          
    252              return _mqx_api_call(MQX_API_LWEVENT_CREATE, &params);
    253          }
    254          
    255          #endif /* MQX_ENABLE_USER_MODE */
    256          
    257          /*!
    258           * \private
    259           *
    260           * \brief Used by a task to destroy an instance of a lightweight event.
    261           *
    262           * \param[in] event_ptr Pointer to the lightweight event to be deinitialized.
    263           * \param[in] user      User mode
    264           *
    265           * \return MQX_OK
    266           * \return MQX_LWEVENT_INVALID (Lightweight event was not valid.)
    267           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
    268           *
    269           * \see _lwevent_destroy
    270           * \see LWEVENT_STRUCT
    271           */
    272          _mqx_uint _lwevent_destroy_internal
    273          (
    274              LWEVENT_STRUCT_PTR  event_ptr,
    275              boolean             user
    276          )
    277          {
    278              KERNEL_DATA_STRUCT_PTR kernel_data;
    279          #if MQX_COMPONENT_DESTRUCTION
    280              TD_STRUCT_PTR td_ptr;
    281          #endif
    282          
    283          #if MQX_ENABLE_USER_MODE
    284              if (user && !_psp_mem_check_access_mask((uint_32)event_ptr,
    285                                                      sizeof(LWEVENT_STRUCT),
    286                                                      MPU_UM_R, MPU_UM_RW))
    287              {
    288                  return MQX_LWEVENT_INVALID;
    289              }
    290          #endif
    291          
    292              _GET_KERNEL_DATA(kernel_data);
    293          
    294              _KLOGE2(KLOG_lwevent_destroy, event_ptr);
    295          
    296          #if MQX_COMPONENT_DESTRUCTION
    297          
    298          #if MQX_CHECK_ERRORS
    299              if (kernel_data->IN_ISR)
    300              {
    301                  _KLOGX2(KLOG_lwevent_destroy, MQX_CANNOT_CALL_FUNCTION_FROM_ISR);
    302                  return (MQX_CANNOT_CALL_FUNCTION_FROM_ISR);
    303              } /* Endif */
    304          #endif
    305          
    306              _int_disable();
    307          #if MQX_CHECK_VALIDITY
    308              if (event_ptr->VALID != LWEVENT_VALID)
    309              {
    310                  _int_enable();
    311                  _KLOGX2(KLOG_lwevent_destroy, MQX_LWEVENT_INVALID);
    312                  return (MQX_LWEVENT_INVALID);
    313              } /* Endif */
    314          #endif
    315          
    316              /* Effectively stop all access to the event */
    317              event_ptr->VALID = 0;
    318              while (_QUEUE_GET_SIZE(&event_ptr->WAITING_TASKS))
    319              {
    320                  _QUEUE_DEQUEUE(&event_ptr->WAITING_TASKS, td_ptr);
    321                  _BACKUP_POINTER(td_ptr, TD_STRUCT, AUX_QUEUE);
    322                  _TIME_DEQUEUE(td_ptr, kernel_data);
    323                  _TASK_READY(td_ptr, kernel_data);
    324              } /* Endwhile */
    325          
    326              /* remove event from kernel LWEVENTS queue */
    327          #if MQX_ENABLE_USER_MODE
    328              if (user)
    329              {
    330                  _QUEUE_REMOVE(&kernel_data->USR_LWEVENTS, event_ptr);
    331              }
    332              else
    333          #endif
    334              {
    335                  _QUEUE_REMOVE(&kernel_data->LWEVENTS, event_ptr);
    336              }
    337          
    338              _int_enable();
    339          
    340              /* May need to let higher priority task run */
    341              _CHECK_RUN_SCHEDULER();
    342          #endif
    343          
    344              _KLOGX2(KLOG_lwevent_destroy, MQX_OK);
    345              return (MQX_OK);
    346          
    347          }
    348          
    349          /*!
    350           * \brief Used by a task to destroy an instance of a lightweight event.
    351           *
    352           * To reuse the lightweight event, a task must reinitialize it.
    353           *
    354           * \param[in] event_ptr Pointer to the event to be deinitialized.
    355           *
    356           * \return MQX_OK
    357           * \return MQX_LWEVENT_INVALID (Lightweight event was not valid.)
    358           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
    359           *
    360           * \warning Cannot be called from an ISR.
    361           *
    362           * \see _lwevent_create
    363           * \see _lwevent_set
    364           * \see _lwevent_set_auto_clear
    365           * \see _lwevent_clear
    366           * \see _lwevent_test
    367           * \see _lwevent_wait_for
    368           * \see _lwevent_wait_ticks
    369           * \see _lwevent_wait_until
    370           * \see _lwevent_get_signalled
    371           * \see LWEVENT_STRUCT
    372           */
    373          _mqx_uint _lwevent_destroy
    374          (
    375              LWEVENT_STRUCT_PTR  event_ptr
    376          )
    377          {
    378          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
    379              if (MQX_RUN_IN_USER_MODE)
    380              {
    381                  return _usr_lwevent_destroy(event_ptr);
    382              }
    383          #endif
    384          
    385              return _lwevent_destroy_internal(event_ptr, FALSE);
    386          }
    387          
    388          #if MQX_ENABLE_USER_MODE
    389          /*!
    390           * \brief Used by a task to destroy an instance of a lightweight event.
    391           *
    392           * This function is an equivalent to the _lwevent_destroy() API call but it can be
    393           * executed from within the User task or other code running in the CPU User mode.
    394           * Parameters passed to this function by pointer are required to meet the memory
    395           * protection requirements as described in the parameter list below.
    396           *
    397           * \param[in] event_ptr Read only. Pointer to the event to be deinitialized.
    398           *
    399           * \return MQX_OK
    400           * \return MQX_LWEVENT_INVALID (Lightweight event was not valid.)
    401           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
    402           *
    403           * \warning Cannot be called from an ISR.
    404           *
    405           * \see _lwevent_destroy
    406           * \see _usr_lwevent_create
    407           * \see _usr_lwevent_set
    408           * \see _usr_lwevent_set_auto_clear
    409           * \see _usr_lwevent_clear
    410           * \see _usr_lwevent_wait_for
    411           * \see _usr_lwevent_wait_ticks
    412           * \see _usr_lwevent_wait_until
    413           * \see _usr_lwevent_get_signalled
    414           * \see LWEVENT_STRUCT
    415           */
    416          _mqx_uint _usr_lwevent_destroy
    417          (
    418              LWEVENT_STRUCT_PTR  event_ptr
    419          )
    420          {
    421              MQX_API_CALL_PARAMS params = {(uint_32)event_ptr, 0, 0, 0, 0};
    422          
    423              return _mqx_api_call(MQX_API_LWEVENT_DESTROY, &params);
    424          }
    425          
    426          #endif /* MQX_ENABLE_USER_MODE */
    427          
    428          /*!
    429           * \brief Used by a task to clear the specified event bits in the ligtweight event.
    430           *
    431           * \param[in] event_ptr Pointer to the event.
    432           * \param[in] bit_mask  Bit mask. Each bit represents an event bit to clear.
    433           *
    434           * \return MQX_OK
    435           * \return MQX_LWEVENT_INVALID (Lightweight event is not valid.)
    436           *
    437           * \see _lwevent_create
    438           * \see _lwevent_destroy
    439           * \see _lwevent_set
    440           * \see _lwevent_set_auto_clear
    441           * \see _lwevent_test
    442           * \see _lwevent_wait_for
    443           * \see _lwevent_wait_ticks
    444           * \see _lwevent_wait_until
    445           * \see _lwevent_get_signalled
    446           * \see LWEVENT_STRUCT
    447           */
    448          _mqx_uint _lwevent_clear
    449          (
    450              LWEVENT_STRUCT_PTR  event_ptr,
    451              _mqx_uint           bit_mask
    452          )
    453          {
    454              KERNEL_DATA_STRUCT_PTR kernel_data;
    455          
    456          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
    457              if (MQX_RUN_IN_USER_MODE)
    458              {
    459                  return _usr_lwevent_clear(event_ptr, bit_mask);
    460              }
    461          #endif
    462          
    463              _GET_KERNEL_DATA(kernel_data);
    464              _KLOGE3(KLOG_lwevent_clear, event_ptr, bit_mask);
    465          
    466              _INT_DISABLE();
    467          #if MQX_CHECK_VALIDITY
    468              if (event_ptr->VALID != LWEVENT_VALID)
    469              {
    470                  _int_enable();
    471                  _KLOGX2(KLOG_lwevent_clear, MQX_LWEVENT_INVALID);
    472                  return (MQX_LWEVENT_INVALID);
    473              } /* Endif */
    474          #endif
    475          
    476              event_ptr->VALUE &= ~bit_mask;
    477              _INT_ENABLE();
    478          
    479              _KLOGX2(KLOG_lwevent_clear, MQX_OK);
    480              return (MQX_OK);
    481          }
    482          
    483          #if MQX_ENABLE_USER_MODE
    484          /*!
    485           * \brief Used by a task to clear the specified event bits in the ligtweight event.
    486           *
    487           * This function is an equivalent to the _lwevent_clear() API call but it can be
    488           * executed from within the User task or other code running in the CPU User mode.
    489           * Parameters passed to this function by pointer are required to meet the memory
    490           * protection requirements as described in the parameter list below.
    491           *
    492           * \param[in] event_ptr Read only. Pointer to the event.
    493           * \param[in] bit_mask   Bit mask. Each bit represents an event bit to clear.
    494           *
    495           * \return MQX_OK
    496           * \return MQX_LWEVENT_INVALID (Lightweight event is not valid.)
    497           *
    498           * \see _lwevent_clear
    499           * \see _usr_lwevent_create
    500           * \see _usr_lwevent_destroy
    501           * \see _usr_lwevent_set
    502           * \see _usr_lwevent_set_auto_clear
    503           * \see _usr_lwevent_wait_for
    504           * \see _usr_lwevent_wait_ticks
    505           * \see _usr_lwevent_wait_until
    506           * \see _usr_lwevent_get_signalled
    507           * \see LWEVENT_STRUCT
    508           */
    509          _mqx_uint _usr_lwevent_clear
    510          (
    511              LWEVENT_STRUCT_PTR  event_ptr,
    512              _mqx_uint           bit_mask
    513          )
    514          {
    515              MQX_API_CALL_PARAMS params = {  (uint_32)event_ptr,
    516                                              (uint_32)bit_mask, 0, 0, 0};
    517          
    518              return _mqx_api_call(MQX_API_LWEVENT_CLEAR, &params);
    519          }
    520          
    521          #endif /* MQX_ENABLE_USER_MODE */
    522          
    523          /*!
    524           * \brief Gets which particular bit(s) in the lwevent unblocked recent wait command.
    525           *
    526           * If _lwevent_wait_xxx(...) was recently called in a task, following call of
    527           * _lwevent_get_signalled returns the mask of bit(s) that unblocked the command.
    528           * User can expect valid data only when the recent _lwevent_wait_xxx(...) operation
    529           * did not return LWEVENT_WAIT_TIMEOUT or an error value. This is useful primarily
    530           * for events that are cleared automatically and thus corresponding LWEVENT_STRUCT
    531           * was automatically reset and holds new value.
    532           *
    533           * \return bit_mask Lwevent mask from last task's lwevent_wait_xxx call that
    534           * unblocked the task.
    535           *
    536           * \see _lwevent_create
    537           * \see _lwevent_destroy
    538           * \see _lwevent_set
    539           * \see _lwevent_set_auto_clear
    540           * \see _lwevent_clear
    541           * \see _lwevent_test
    542           * \see _lwevent_wait_for
    543           * \see _lwevent_wait_ticks
    544           * \see _lwevent_wait_until
    545           */
    546          _mqx_uint _lwevent_get_signalled(void)
    547          {
    548              KERNEL_DATA_STRUCT_PTR kernel_data;
    549              _mqx_uint value;
    550          
    551          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
    552              if (MQX_RUN_IN_USER_MODE)
    553              {
    554                  return _usr_lwevent_get_signalled();
    555              }
    556          #endif
    557          
    558              _GET_KERNEL_DATA(kernel_data);
    559          
    560              _KLOGE1(KLOG_lwevent_get_signalled);
    561          
    562              value = kernel_data->ACTIVE_PTR->LWEVENT_BITS;
    563          
    564              _KLOGX2(KLOG_lwevent_get_signalled, value);
    565              return (value);
    566          }
    567          
    568          #if MQX_ENABLE_USER_MODE
    569          /*!
    570           * \brief Gets which particular bit(s) in the lwevent unblocked recent wait command.
    571           *
    572           * This function is an equivalent to the _lwevent_get_signalled() API call but it
    573           * can be executed from within the User task or other code running in the CPU User
    574           * mode. Parameters passed to this function by pointer are required to meet the
    575           * memory protection requirements as described in the parameter list below.
    576           *
    577           * \return bit_mask Lwevent mask from last task's lwevent_wait_xxx call that
    578           * unblocked the task.
    579           *
    580           * \see _lwevent_get_signalled
    581           * \see _usr_lwevent_create
    582           * \see _usr_lwevent_destroy
    583           * \see _usr_lwevent_set
    584           * \see _usr_lwevent_set_auto_clear
    585           * \see _usr_lwevent_clear
    586           * \see _usr_lwevent_wait_for
    587           * \see _usr_lwevent_wait_ticks
    588           * \see _usr_lwevent_wait_until
    589           */
    590          _mqx_uint _usr_lwevent_get_signalled(void)
    591          {
    592              MQX_API_CALL_PARAMS params = {0, 0, 0, 0, 0};
    593          
    594              return _mqx_api_call(MQX_API_LWEVENT_GET_SIGNALLED, &params);
    595          }
    596          
    597          #endif /* MQX_ENABLE_USER_MODE */
    598          
    599          /*!
    600           * \brief Sets autoclearing behavior of event bits in the lightweight event.
    601           *
    602           * Used by a task to set functionality of the specified bits in an event to
    603           * automatic or manual (1 = automatic, 0 = manual).
    604           *
    605           * \param[in] event_ptr Pointer to the lightweight event to set bits in.
    606           * \param[in] auto_mask Mask of events, that is set auto-clear (if corresponding
    607           * bit of mask is set) or manual-clear (if corresponding bit of mask is clear).
    608           *
    609           * \return MQX_OK
    610           * \return MQX_LWEVENT_INVALID (Lightweight event was invalid.)
    611           *
    612           * \warning Disables and enables interrupts.
    613           *
    614           * \see _lwevent_create
    615           * \see _lwevent_destroy
    616           * \see _lwevent_set
    617           * \see _lwevent_clear
    618           * \see _lwevent_test
    619           * \see _lwevent_wait_for
    620           * \see _lwevent_wait_ticks
    621           * \see _lwevent_wait_until
    622           * \see _lwevent_get_signalled
    623           * \see LWEVENT_STRUCT
    624           */
    625          _mqx_uint _lwevent_set_auto_clear
    626          (
    627              LWEVENT_STRUCT_PTR  event_ptr,
    628          
    629              _mqx_uint           auto_mask
    630          )
    631          {
    632              KERNEL_DATA_STRUCT_PTR kernel_data;
    633          
    634          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
    635              if (MQX_RUN_IN_USER_MODE)
    636              {
    637                  return _usr_lwevent_set_auto_clear(event_ptr, auto_mask);
    638              }
    639          #endif
    640          
    641              _GET_KERNEL_DATA(kernel_data);
    642          
    643              _KLOGE3(KLOG_lwevent_set_auto_clear, event_ptr, auto_mask);
    644          
    645              _INT_DISABLE();
    646          #if MQX_CHECK_VALIDITY
    647              if (event_ptr->VALID != LWEVENT_VALID)
    648              {
    649                  _int_enable();
    650                  _KLOGX2(KLOG_lwevent_set, MQX_LWEVENT_INVALID);
    651                  return (MQX_LWEVENT_INVALID);
    652              } /* Endif */
    653          #endif
    654          
    655              event_ptr->AUTO = auto_mask;
    656          
    657              _INT_ENABLE();
    658          
    659              _KLOGX2(KLOG_lwevent_set_auto_clear, MQX_OK);
    660              return (MQX_OK);
    661          
    662          }
    663          
    664          #if MQX_ENABLE_USER_MODE
    665          /*!
    666           * \brief Sets autoclearing behavior of event bits in the lightweight event.
    667           *
    668           * This function is an equivalent to the _lwevent_set_auto_clear() API call but it
    669           * can be executed from within the User task or other code running in the CPU User
    670           * mode. Parameters passed to this function by pointer are required to meet the
    671           * memory protection requirements as described in the parameter list below.
    672           *
    673           * \param[in] event_ptr Read only. Pointer to the lightweight event to set bits in.
    674           * \param[in] auto_mask Mask of events, that is set auto-clear (if corresponding
    675           * bit of mask is set) or manual-clear (if corresponding bit of mask is clear).
    676           *
    677           * \return MQX_OK
    678           * \return MQX_LWEVENT_INVALID (Lightweight event was invalid.)
    679           *
    680           * \warning Disables and enables interrupts.
    681           *
    682           * \see _lwevent_set_auto_clear
    683           * \see _usr_lwevent_create
    684           * \see _usr_lwevent_destroy
    685           * \see _usr_lwevent_set
    686           * \see _usr_lwevent_clear
    687           * \see _usr_lwevent_wait_for
    688           * \see _usr_lwevent_wait_ticks
    689           * \see _usr_lwevent_wait_until
    690           * \see _usr_lwevent_get_signalled
    691           * \see LWEVENT_STRUCT
    692           */
    693          _mqx_uint _usr_lwevent_set_auto_clear
    694          (
    695              LWEVENT_STRUCT_PTR  event_ptr,
    696              _mqx_uint           auto_mask
    697          )
    698          {
    699              MQX_API_CALL_PARAMS params = {  (uint_32)event_ptr,
    700                                              (uint_32)auto_mask, 0, 0, 0};
    701          
    702              return _mqx_api_call(MQX_API_LWEVENT_SET_AUTO_CLEAR, &params);
    703          }
    704          
    705          #endif /* MQX_ENABLE_USER_MODE */
    706          
    707          /*!
    708           * \brief Used by a task to set the specified event bits in an event.
    709           *
    710           * \param[in] event_ptr Pointer to the lightweight event to set bits in.
    711           * \param[in] bit_mask  Bit mask. Each bit represents an event bit to be set.
    712           *
    713           * \return MQX_OK
    714           * \return MQX_LWEVENT_INVALID (Lightweight event was invalid.)
    715           *
    716           * \warning Disables and enables interrupts.
    717           *
    718           * \see _lwevent_create
    719           * \see _lwevent_destroy
    720           * \see _lwevent_set_auto_clear
    721           * \see _lwevent_clear
    722           * \see _lwevent_test
    723           * \see _lwevent_wait_for
    724           * \see _lwevent_wait_ticks
    725           * \see _lwevent_wait_until
    726           * \see _lwevent_get_signalled
    727           * \see LWEVENT_STRUCT
    728           */
    729          _mqx_uint _lwevent_set
    730          (
    731              LWEVENT_STRUCT_PTR  event_ptr,
    732              _mqx_uint           bit_mask
    733          )
    734          {
    735              KERNEL_DATA_STRUCT_PTR kernel_data;
    736              QUEUE_ELEMENT_STRUCT_PTR q_ptr;
    737              QUEUE_ELEMENT_STRUCT_PTR next_q_ptr;
    738              TD_STRUCT_PTR td_ptr;
    739              _mqx_uint set_bits;
    740          
    741          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
    742              if (MQX_RUN_IN_USER_MODE)
    743              {
    744                  return _usr_lwevent_set(event_ptr, bit_mask);
    745              }
    746          #endif
    747          
    748              _GET_KERNEL_DATA(kernel_data);
    749          
    750              _KLOGE3(KLOG_lwevent_set, event_ptr, bit_mask);
    751          
    752              _INT_DISABLE();
    753          #if MQX_CHECK_VALIDITY
    754              if (event_ptr->VALID != LWEVENT_VALID)
    755              {
    756                  _int_enable();
    757                  _KLOGX2(KLOG_lwevent_set, MQX_LWEVENT_INVALID);
    758                  return (MQX_LWEVENT_INVALID);
    759              } /* Endif */
    760          #endif
    761          
    762              set_bits = event_ptr->VALUE | bit_mask;
    763          
    764              if (_QUEUE_GET_SIZE(&event_ptr->WAITING_TASKS))
    765              {
    766                  /* Schedule waiting task(s) to run if bits ok */
    767          
    768                  q_ptr = event_ptr->WAITING_TASKS.NEXT;
    769                  while (q_ptr != (QUEUE_ELEMENT_STRUCT_PTR) ((pointer) &event_ptr->WAITING_TASKS))
    770                  {
    771                      td_ptr = (pointer) q_ptr;
    772                      _BACKUP_POINTER(td_ptr, TD_STRUCT, AUX_QUEUE);
    773                      next_q_ptr = q_ptr->NEXT;
    774                      if (((td_ptr->FLAGS & TASK_LWEVENT_ALL_BITS_WANTED) && ((td_ptr->LWEVENT_BITS & set_bits)
    775                                      == td_ptr->LWEVENT_BITS)) || ((!(td_ptr->FLAGS & TASK_LWEVENT_ALL_BITS_WANTED))
    776                                      && (td_ptr->LWEVENT_BITS & set_bits)))
    777                      {
    778                          _QUEUE_REMOVE(&event_ptr->WAITING_TASKS, q_ptr);
    779                          _TIME_DEQUEUE(td_ptr, kernel_data);
    780                          td_ptr->INFO = 0;
    781                          _TASK_READY(td_ptr, kernel_data);
    782          
    783                          /* store information about which bits caused task to be unblocked */
    784                          td_ptr->LWEVENT_BITS &= set_bits;
    785                          set_bits &= ~(event_ptr->AUTO & td_ptr->LWEVENT_BITS);
    786          
    787                      } /* Endif */
    788                      q_ptr = next_q_ptr;
    789                  } /* Endwhile */
    790              } /* Endif */
    791          
    792              event_ptr->VALUE = set_bits;
    793              _INT_ENABLE();
    794          
    795              /* May need to let higher priority task run */
    796              _CHECK_RUN_SCHEDULER();
    797          
    798              _KLOGX2(KLOG_lwevent_set, MQX_OK);
    799              return (MQX_OK);
    800          
    801          }
    802          
    803          #if MQX_ENABLE_USER_MODE
    804          /*!
    805           * \brief Used by a task to set the specified event bits in an event.
    806           *
    807           * This function is an equivalent to the _lwevent_set() API call but it can be
    808           * executed from within the User task or other code running in the CPU User mode.
    809           * Parameters passed to this function by pointer are required to meet the memory
    810           * protection requirements as described in the parameter list below.
    811           *
    812           * \param[in] event_ptr Read only. Pointer to the lightweight event to set bits in.
    813           * \param[in] bit_mask  Bit mask. Each bit represents an event bit to be set.
    814           *
    815           * \return MQX_OK
    816           * \return MQX_LWEVENT_INVALID (Lightweight event was invalid.)
    817           *
    818           * \warning Disables and enables interrupts.
    819           *
    820           * \see _lwevent_set
    821           * \see _usr_lwevent_create
    822           * \see _usr_lwevent_destroy
    823           * \see _usr_lwevent_set_auto_clear
    824           * \see _usr_lwevent_clear
    825           * \see _usr_lwevent_wait_for
    826           * \see _usr_lwevent_wait_ticks
    827           * \see _usr_lwevent_wait_until
    828           * \see _usr_lwevent_get_signalled
    829           * \see LWEVENT_STRUCT
    830           */
    831          _mqx_uint _usr_lwevent_set
    832          (
    833              LWEVENT_STRUCT_PTR  event_ptr,
    834              _mqx_uint           bit_mask
    835          )
    836          {
    837              MQX_API_CALL_PARAMS params = {  (uint_32)event_ptr,
    838                                              (uint_32)bit_mask, 0, 0, 0};
    839          
    840              return _mqx_api_call(MQX_API_LWEVENT_SET, &params);
    841          }
    842          
    843          #endif /* MQX_ENABLE_USER_MODE */
    844          
    845          /*!
    846           * \brief Tests the event component for validity and consistency.
    847           *
    848           * \param[out] event_error_ptr Pointer to the lightweight event that has an
    849           * error if MQX found an error in the lightweight event component (NULL if no error
    850           * is found).
    851           * \param[out] td_error_ptr    TD on the lightweight event in error (NULL if no
    852           * error is found).
    853           *
    854           * \return MQX_OK
    855           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
    856           * \return MQX_LWEVENT_INVALID (A lightweight event was invalid.)
    857           * \return code from _queue_test() (Waiting queue for a lightweight event has an error.)
    858           *
    859           * \warning Cannot be called from an ISR.
    860           *
    861           * \see _lwevent_create
    862           * \see _lwevent_destroy
    863           * \see _lwevent_set
    864           * \see _lwevent_set_auto_clear
    865           * \see _lwevent_clear
    866           * \see _lwevent_wait_for
    867           * \see _lwevent_wait_ticks
    868           * \see _lwevent_wait_until
    869           * \see _lwevent_get_signalled
    870           */
    871          _mqx_uint _lwevent_test
    872          (
    873              pointer _PTR_   event_error_ptr,
    874              pointer _PTR_   td_error_ptr
    875          )
    876          {
    877              KERNEL_DATA_STRUCT_PTR  kernel_data;
    878              LWEVENT_STRUCT_PTR      event_ptr;
    879              _mqx_uint               result;
    880              _mqx_uint               queue_size;
    881          
    882              _GET_KERNEL_DATA(kernel_data);
    883          
    884              _KLOGE2(KLOG_lwevent_test, event_error_ptr);
    885          
    886              *td_error_ptr = NULL;
    887              *event_error_ptr = NULL;
    888          
    889          #if MQX_CHECK_ERRORS
    890              if (kernel_data->IN_ISR)
    891              {
    892                  _KLOGX2(KLOG_lwevent_test, MQX_CANNOT_CALL_FUNCTION_FROM_ISR);
    893                  return (MQX_CANNOT_CALL_FUNCTION_FROM_ISR);
    894              }/* Endif */
    895          #endif
    896          
    897              /*
    898               * It is not considered an error if the lwevent component has not been
    899               * created yet
    900               */
    901              if (kernel_data->LWEVENTS.NEXT == NULL)
    902              {
    903                  return (MQX_OK);
    904              } /* Endif */
    905          
    906              result = _queue_test((QUEUE_STRUCT_PTR) &kernel_data->LWEVENTS, event_error_ptr);
    907              if (result != MQX_OK)
    908              {
    909                  _KLOGX3(KLOG_lwevent_test, result, *event_error_ptr);
    910                  return (result);
    911              } /* Endif */
    912          
    913              event_ptr = (LWEVENT_STRUCT_PTR) ((pointer) kernel_data->LWEVENTS.NEXT);
    914              queue_size = _QUEUE_GET_SIZE(&kernel_data->LWEVENTS);
    915              while (queue_size--)
    916              {
    917                  if (event_ptr->VALID != LWEVENT_VALID)
    918                  {
    919                      result = MQX_LWEVENT_INVALID;
    920                      break;
    921                  } /* Endif */
    922                  result = _queue_test(&event_ptr->WAITING_TASKS, td_error_ptr);
    923                  if (result != MQX_OK)
    924                  {
    925                      break;
    926                  } /* Endif */
    927                  event_ptr = (LWEVENT_STRUCT_PTR) (pointer) event_ptr->LINK.NEXT;
    928              } /* Endwhile */
    929          
    930              _int_enable();
    931          
    932              if (result != MQX_OK)
    933              {
    934                  *event_error_ptr = (pointer) event_ptr;
    935              } /* Endif */
    936              _KLOGX4(KLOG_lwevent_test, result, *event_error_ptr, *td_error_ptr);
    937              return (result);
    938          
    939          }
    940          
    941          #if MQX_ENABLE_USER_MODE
    942          /*!
    943           * \brief Checks whether the specified pointer corresponds with a valid lwevent.
    944           *
    945           * \param[in] tst_event_ptr Pointer to the lwevent.
    946           *
    947           * \return MQX_OK (Valid lwevent.)
    948           * \return MQX_LWEVENT_INVALID (Specified lwevent is not valid.)
    949           *
    950           * \see LWEVENT_STRUCT
    951           */
    952          _mqx_uint _lwevent_usr_check
    953          (
    954              LWEVENT_STRUCT_PTR  tst_event_ptr
    955          )
    956          {
    957              KERNEL_DATA_STRUCT_PTR  kernel_data;
    958              LWEVENT_STRUCT_PTR      event_ptr;
    959              _mqx_uint               result = MQX_LWEVENT_INVALID;
    960              _mqx_uint               queue_size;
    961          
    962              _GET_KERNEL_DATA(kernel_data);
    963          
    964              event_ptr = (LWEVENT_STRUCT_PTR)((pointer)kernel_data->USR_LWEVENTS.NEXT);
    965              queue_size = _QUEUE_GET_SIZE(&kernel_data->USR_LWEVENTS);
    966          
    967              while (queue_size--)
    968              {
    969                  if (event_ptr->VALID != LWEVENT_VALID)
    970                  {
    971                      break;
    972                  }
    973          
    974                  if (tst_event_ptr == event_ptr)
    975                  {
    976                      result = MQX_OK;
    977                      break;
    978                  }
    979          
    980                  event_ptr = (LWEVENT_STRUCT_PTR)(pointer)event_ptr->LINK.NEXT;
    981              }
    982          
    983              return result;
    984          }
    985          
    986          #endif /* MQX_ENABLE_USER_MODE */
    987          
    988          /*!
    989           * \brief Used by a task to wait for the number of ticks (in tick time).
    990           *
    991           * \param[in] event_ptr Pointer to the lightweight event.
    992           * \param[in] bit_mask  Bit mask. Each set bit represents an event bit to wait for.
    993           * \param[in] all       TRUE (wait for all bits in bit_mask to be set), FALSE
    994           * (wait for any bit in bit_mask to be set).
    995           * \param[in] tick_ptr  Pointer to the maximum number of ticks to wait for the
    996           * events to be set. If the value is NULL, then the timeout will be infinite.
    997           *
    998           * \return MQX_OK
    999           * \return LWEVENT_WAIT_TIMEOUT (The time elapsed before an event signalled.)
   1000           * \return MQX_LWEVENT_INVALID (Lightweight event is no longer valid or was never
   1001           * valid.)
   1002           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
   1003           *
   1004           * \warning Blocks until the event combination is set or until the timeout expires.
   1005           * Cannot be called from an ISR.
   1006           *
   1007           * \see _lwevent_create
   1008           * \see _lwevent_destroy
   1009           * \see _lwevent_set
   1010           * \see _lwevent_set_auto_clear
   1011           * \see _lwevent_clear
   1012           * \see _lwevent_wait_ticks
   1013           * \see _lwevent_wait_until
   1014           * \see _lwevent_get_signalled
   1015           * \see LWEVENT_STRUCT
   1016           * \see MQX_TICK_STRUCT
   1017           */
   1018          _mqx_uint _lwevent_wait_for
   1019          (
   1020              LWEVENT_STRUCT_PTR  event_ptr,
   1021              _mqx_uint           bit_mask,
   1022              boolean             all,
   1023              MQX_TICK_STRUCT_PTR tick_ptr
   1024          )
   1025          {
   1026              _KLOGM(KERNEL_DATA_STRUCT_PTR kernel_data;)
   1027              _mqx_uint result;
   1028          
   1029          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
   1030              if (MQX_RUN_IN_USER_MODE)
   1031              {
   1032                  return _usr_lwevent_wait_for(event_ptr, bit_mask, all, tick_ptr);
   1033              }
   1034          #endif
   1035          
   1036              _KLOGM(_GET_KERNEL_DATA(kernel_data);)
   1037          
   1038              _KLOGE5(KLOG_lwevent_wait_for, event_ptr, bit_mask, all, tick_ptr);
   1039          
   1040              result = _lwevent_wait_internal(event_ptr, bit_mask, all, tick_ptr, FALSE);
   1041          
   1042              _KLOGX2(KLOG_lwevent_wait_for, result);
   1043              return (result);
   1044          
   1045          }
   1046          
   1047          #if MQX_ENABLE_USER_MODE
   1048          /*!
   1049           * \brief Used by a task to wait for the number of ticks (in tick time).
   1050           *
   1051           * This function is an equivalent to the _lwevent_wait_for() API call but it can
   1052           * be executed from within the User task or other code running in the CPU User
   1053           * mode. Parameters passed to this function by pointer are required to meet the
   1054           * memory protection requirements as described in the parameter list below.
   1055           *
   1056           * \param[in] event_ptr Read only. Pointer to the lightweight event.
   1057           * \param[in] bit_mask  Bit mask. Each set bit represents an event bit to wait for.
   1058           * \param[in] all       TRUE (wait for all bits in bit_mask to be set), FALSE
   1059           * (wait for any bit in bit_mask to be set).
   1060           * \param[in] tick_ptr  Pointer to the maximum number of ticks to wait for the
   1061           * events to be set. If the value is NULL, then the timeout will be infinite.
   1062           *
   1063           * \return MQX_OK
   1064           * \return LWEVENT_WAIT_TIMEOUT (The time elapsed before an event signalled.)
   1065           * \return MQX_LWEVENT_INVALID (Lightweight event is no longer valid or was never
   1066           * valid.)
   1067           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
   1068           *
   1069           * \warning Blocks until the event combination is set or until the timeout expires.
   1070           * Cannot be called from an ISR.
   1071           *
   1072           * \see _lwevent_wait_for
   1073           * \see _usr_lwevent_create
   1074           * \see _usr_lwevent_destroy
   1075           * \see _usr_lwevent_set
   1076           * \see _usr_lwevent_set_auto_clear
   1077           * \see _usr_lwevent_clear
   1078           * \see _usr_lwevent_wait_ticks
   1079           * \see _usr_lwevent_wait_until
   1080           * \see _usr_lwevent_get_signalled
   1081           * \see LWEVENT_STRUCT
   1082           * \see MQX_TICK_STRUCT
   1083           */
   1084          _mqx_uint _usr_lwevent_wait_for
   1085          (
   1086              LWEVENT_STRUCT_PTR  event_ptr,
   1087              _mqx_uint           bit_mask,
   1088              boolean             all,
   1089              MQX_TICK_STRUCT_PTR tick_ptr
   1090          )
   1091          {
   1092              MQX_API_CALL_PARAMS params = {  (uint_32)event_ptr, (uint_32)bit_mask,
   1093                                              (uint_32)all,       (uint_32)tick_ptr, 0};
   1094          
   1095              return _mqx_api_call(MQX_API_LWEVENT_WAIT_FOR, &params);
   1096          }
   1097          
   1098          #endif /* MQX_ENABLE_USER_MODE */
   1099          
   1100          /*!
   1101           * \private
   1102           *
   1103           * \brief This is internal function used by a task to wait for a specified event.
   1104           *
   1105           * \param[in] event_ptr          Read only. Pointer to the lightweight event.
   1106           * \param[in] bit_mask           Bit mask. Each set bit represents an event bit
   1107           * to wait for.
   1108           * \param[in] all                TRUE (wait for all bits in bit_mask to be set),
   1109           * FALSE (wait for any bit in bit_mask to be set).
   1110           * \param[in] tick_ptr           Pointer to the maximum number of ticks to wait
   1111           * for the events to be set. If the value is NULL, then the timeout will be infinite.
   1112           * \param[in] ticks_are_absolute TRUE (ticks represents absolute time), FALSE
   1113           * (ticks represents relative time).
   1114           *
   1115           * \return MQX_OK
   1116           * \return LWEVENT_WAIT_TIMEOUT (The time elapsed before an event signalled.)
   1117           * \return MQX_LWEVENT_INVALID (Lightweight event is no longer valid or was never valid.)
   1118           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
   1119           *
   1120           * \see _lwevent_wait_for
   1121           * \see _usr_lwevent_wait_for
   1122           * \see _lwevent_wait_until
   1123           * \see _usr_lwevent_wait_until
   1124           * \see _lwevent_wait_ticks
   1125           * \see _usr_lwevent_wait_ticks
   1126           * \see LWEVENT_STRUCT
   1127           * \see MQX_TICK_STRUCT
   1128           */
   1129          _mqx_uint _lwevent_wait_internal
   1130          (
   1131              LWEVENT_STRUCT_PTR  event_ptr,
   1132              _mqx_uint           bit_mask,
   1133              boolean             all,
   1134              MQX_TICK_STRUCT_PTR tick_ptr,
   1135              boolean             ticks_are_absolute
   1136          )
   1137          {
   1138              KERNEL_DATA_STRUCT_PTR  kernel_data;
   1139              TD_STRUCT_PTR           td_ptr;
   1140              _mqx_uint               result;
   1141          
   1142              _GET_KERNEL_DATA(kernel_data);
   1143          
   1144          #if MQX_CHECK_ERRORS
   1145              if (kernel_data->IN_ISR)
   1146              {
   1147                  return (MQX_CANNOT_CALL_FUNCTION_FROM_ISR);
   1148              } /* Endif */
   1149          #endif
   1150          
   1151              result = MQX_OK;
   1152              td_ptr = kernel_data->ACTIVE_PTR;
   1153              _INT_DISABLE();
   1154          
   1155          #if MQX_CHECK_VALIDITY
   1156              if (event_ptr->VALID != LWEVENT_VALID)
   1157              {
   1158                  _int_enable();
   1159                  return (MQX_LWEVENT_INVALID);
   1160              } /* Endif */
   1161          #endif
   1162          
   1163              if (    (all &&  (event_ptr->VALUE & bit_mask) == bit_mask)
   1164                   || (!all && (event_ptr->VALUE & bit_mask)))
   1165              {
   1166                  /* store information about which bits caused task to be unblocked */
   1167                  td_ptr->LWEVENT_BITS = event_ptr->VALUE & bit_mask;
   1168                  /* clear used automatic events */
   1169                  event_ptr->VALUE &= ~(event_ptr->AUTO & bit_mask);
   1170          
   1171                  _INT_ENABLE();
   1172                  return (result);
   1173              } /* Endif */
   1174          
   1175              /* Must wait for a event to become available */
   1176          
   1177              td_ptr->LWEVENT_BITS = bit_mask;
   1178              if (all)
   1179              {
   1180                  td_ptr->FLAGS |= TASK_LWEVENT_ALL_BITS_WANTED;
   1181              }
   1182              else
   1183              {
   1184                  td_ptr->FLAGS &= ~TASK_LWEVENT_ALL_BITS_WANTED;
   1185              } /* Endif */
   1186          
   1187              /* Enqueue at end */
   1188              _QUEUE_ENQUEUE(&event_ptr->WAITING_TASKS, &td_ptr->AUX_QUEUE);
   1189          
   1190              /* Now put the task to sleep */
   1191              td_ptr->STATE = LWEVENT_BLOCKED;
   1192              td_ptr->INFO = (_mqx_uint) &event_ptr->WAITING_TASKS;
   1193              if (tick_ptr)
   1194              {
   1195                  if (ticks_are_absolute)
   1196                  {
   1197                      _time_delay_until(tick_ptr);
   1198                  }
   1199                  else
   1200                  {
   1201                      _time_delay_for(tick_ptr);
   1202                  } /* Endif */
   1203                  if (td_ptr->INFO)
   1204                  {
   1205                      /* Must have timed out */
   1206                      /*_QUEUE_REMOVE(&event_ptr->WAITING_TASKS, &td_ptr->AUX_QUEUE);*/
   1207                      result = LWEVENT_WAIT_TIMEOUT;
   1208                  } /* Endif */
   1209              }
   1210              else
   1211              {
   1212                  _task_block();
   1213              } /* Endif */
   1214          
   1215          #if MQX_COMPONENT_DESTRUCTION
   1216              if (event_ptr->VALID == 0)
   1217              { /* We've been deleted */
   1218                  result = MQX_LWEVENT_INVALID;
   1219              } /* Endif */
   1220          #endif
   1221          
   1222              _INT_ENABLE();
   1223              return (result);
   1224          
   1225          }
   1226          
   1227          /*!
   1228           * \brief Used by a task to wait until the specified time (in tick time).
   1229           *
   1230           * \param[in] event_ptr Pointer to the lightweight event.
   1231           * \param[in] bit_mask  Bit mask. Each set bit represents an event bit to wait for.
   1232           * \param[in] all       TRUE (wait for all bits in bit_mask to be set), FALSE
   1233           * (wait for any bit in bit_mask to be set).
   1234           * \param[in] tick_ptr  Pointer to the maximum number of ticks to wait for the
   1235           * events to be set. If the value is NULL, then the timeout will be infinite.
   1236           *
   1237           * \return MQX_OK
   1238           * \return LWEVENT_WAIT_TIMEOUT (The time elapsed before an event signalled.)
   1239           * \return MQX_LWEVENT_INVALID (Lightweight event is no longer valid or was never
   1240           * valid.)
   1241           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
   1242           *
   1243           * \warning Blocks until the event combination is set or until the timeout expires.
   1244           * Cannot be called from an ISR.
   1245           *
   1246           * \see _lwevent_create
   1247           * \see _lwevent_destroy
   1248           * \see _lwevent_set
   1249           * \see _lwevent_set_auto_clear
   1250           * \see _lwevent_clear
   1251           * \see _lwevent_wait_for
   1252           * \see _lwevent_wait_ticks
   1253           * \see _lwevent_get_signalled
   1254           * \see LWEVENT_STRUCT
   1255           * \see MQX_TICK_STRUCT
   1256           */
   1257          _mqx_uint _lwevent_wait_until
   1258          (
   1259              LWEVENT_STRUCT_PTR  event_ptr,
   1260              _mqx_uint           bit_mask,
   1261              boolean             all,
   1262              MQX_TICK_STRUCT_PTR tick_ptr
   1263          )
   1264          {
   1265              _KLOGM(KERNEL_DATA_STRUCT_PTR kernel_data;)
   1266              _mqx_uint result;
   1267          
   1268          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
   1269              if (MQX_RUN_IN_USER_MODE)
   1270              {
   1271                  return _usr_lwevent_wait_until(event_ptr, bit_mask, all, tick_ptr);
   1272              }
   1273          #endif
   1274          
   1275              _KLOGM(_GET_KERNEL_DATA(kernel_data);)
   1276          
   1277              _KLOGE5(KLOG_lwevent_wait_until, event_ptr, bit_mask, all, tick_ptr);
   1278          
   1279              result = _lwevent_wait_internal(event_ptr, bit_mask, all, tick_ptr, TRUE);
   1280          
   1281              _KLOGX2(KLOG_lwevent_wait_until, result);
   1282              return (result);
   1283          }
   1284          
   1285          #if MQX_ENABLE_USER_MODE
   1286          /*!
   1287           * \brief Used by a task to wait until the specified time (in tick time).
   1288           *
   1289           * This function is an equivalent to the _lwevent_wait_until() API call but it can
   1290           * be executed from within the User task or other code running in the CPU User mode.
   1291           * Parameters passed to this function by pointer are required to meet the memory
   1292           * protection requirements as described in the parameter list below.
   1293           *
   1294           * \param[in] event_ptr Read only. Pointer to the lightweight event.
   1295           * \param[in] bit_mask  Bit mask. Each set bit represents an event bit to wait for.
   1296           * \param[in] all       TRUE (wait for all bits in bit_mask to be set), FALSE
   1297           * (wait for any bit in bit_mask to be set).
   1298           * \param[in] tick_ptr  Pointer to the maximum number of ticks to wait for the
   1299           * events to be set. If the value is NULL, then the timeout will be infinite.
   1300           *
   1301           * \return MQX_OK
   1302           * \return LWEVENT_WAIT_TIMEOUT (The time elapsed before an event signalled.)
   1303           * \return MQX_LWEVENT_INVALID (Lightweight event is no longer valid or was never
   1304           * valid.)
   1305           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
   1306           *
   1307           * \warning Blocks until the event combination is set or until the timeout expires.
   1308           * Cannot be called from an ISR.
   1309           *
   1310           * \see _lwevent_wait_until
   1311           * \see _usr_lwevent_create
   1312           * \see _usr_lwevent_destroy
   1313           * \see _usr_lwevent_set
   1314           * \see _usr_lwevent_set_auto_clear
   1315           * \see _usr_lwevent_clear
   1316           * \see _usr_lwevent_wait_for
   1317           * \see _usr_lwevent_wait_ticks
   1318           * \see _usr_lwevent_get_signalled
   1319           * \see LWEVENT_STRUCT
   1320           * \see MQX_TICK_STRUCT
   1321           */
   1322          _mqx_uint _usr_lwevent_wait_until
   1323          (
   1324              LWEVENT_STRUCT_PTR  event_ptr,
   1325              _mqx_uint           bit_mask,
   1326              boolean             all,
   1327              MQX_TICK_STRUCT_PTR tick_ptr
   1328          )
   1329          {
   1330              MQX_API_CALL_PARAMS params = {  (uint_32)event_ptr, (uint_32)bit_mask,
   1331                                              (uint_32)all,       (uint_32)tick_ptr, 0};
   1332          
   1333              return _mqx_api_call(MQX_API_LWEVENT_WAIT_UNTIL, &params);
   1334          }
   1335          
   1336          #endif /* MQX_ENABLE_USER_MODE */
   1337          
   1338          /*!
   1339           * \brief Used by a task to wait for the number of ticks.
   1340           *
   1341           * \param[in] event_ptr        Pointer to the lightweight event.
   1342           * \param[in] bit_mask         Bit mask. Each set bit represents an event bit to wait for.
   1343           * \param[in] all              TRUE (wait for all bits in bit_mask to be set),
   1344           * FALSE (wait for any bit in bit_mask to be set).
   1345           * \param[in] timeout_in_ticks The maximum number of ticks to wait for the events
   1346           * to be set. If the value is NULL, then the timeout will be infinite.
   1347           *
   1348           * \return MQX_OK
   1349           * \return LWEVENT_WAIT_TIMEOUT (The time elapsed before an event signalled.)
   1350           * \return MQX_LWEVENT_INVALID (Lightweight event is no longer valid or was never
   1351           * valid.)
   1352           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
   1353           *
   1354           * \warning Blocks until the event combination is set or until the timeout expires.
   1355           * Cannot be called from an ISR.
   1356           *
   1357           * \see _lwevent_create
   1358           * \see _lwevent_destroy
   1359           * \see _lwevent_set
   1360           * \see _lwevent_set_auto_clear
   1361           * \see _lwevent_clear
   1362           * \see _lwevent_wait_for
   1363           * \see _lwevent_wait_until
   1364           * \see _lwevent_get_signalled
   1365           * \see LWEVENT_STRUCT
   1366           */
   1367          _mqx_uint _lwevent_wait_ticks
   1368          (
   1369              LWEVENT_STRUCT_PTR  event_ptr,
   1370              _mqx_uint           bit_mask,
   1371              boolean             all,
   1372              _mqx_uint           timeout_in_ticks
   1373          )
   1374          {
   1375              MQX_TICK_STRUCT ticks;
   1376              _KLOGM(KERNEL_DATA_STRUCT_PTR kernel_data;)
   1377              _mqx_uint result;
   1378          
   1379          #if MQX_ENABLE_USER_MODE && MQX_ENABLE_USER_STDAPI
   1380              if (MQX_RUN_IN_USER_MODE)
   1381              {
   1382                  return _usr_lwevent_wait_ticks(event_ptr, bit_mask, all, timeout_in_ticks);
   1383              }
   1384          #endif
   1385          
   1386              _KLOGM(_GET_KERNEL_DATA(kernel_data);)
   1387          
   1388              _KLOGE5(KLOG_lwevent_wait_ticks, event_ptr, bit_mask, all,
   1389                              timeout_in_ticks);
   1390          
   1391              if (timeout_in_ticks)
   1392              {
   1393                  ticks = _mqx_zero_tick_struct;
   1394          
   1395                  PSP_ADD_TICKS_TO_TICK_STRUCT(&ticks, timeout_in_ticks, &ticks);
   1396                  result = _lwevent_wait_internal(event_ptr, bit_mask, all, &ticks, FALSE);
   1397              }
   1398              else
   1399              {
   1400                  result = _lwevent_wait_internal(event_ptr, bit_mask, all, NULL, FALSE);
   1401              } /* Endif */
   1402          
   1403              _KLOGX2(KLOG_lwevent_wait_ticks, result);
   1404              return (result);
   1405          
   1406          }
   1407          
   1408          #if MQX_ENABLE_USER_MODE
   1409          /*!
   1410           * \brief Used by a task to wait for the number of ticks.
   1411           *
   1412           * This function is an equivalent to the _lwevent_wait_ticks() API call but it can be\
   1413           * executed from within the User task or other code running in the CPU User mode.
   1414           * Parameters passed to this function by pointer are required to meet the memory
   1415           * protection requirements as described in the parameter list below.
   1416           *
   1417           * \param[in] event_ptr        Read only. Pointer to the lightweight event.
   1418           * \param[in] bit_mask         Bit mask. Each set bit represents an event bit to wait for.
   1419           * \param[in] all              TRUE (wait for all bits in bit_mask to be set),
   1420           * FALSE (wait for any bit in bit_mask to be set).
   1421           * \param[in] timeout_in_ticks The maximum number of ticks to wait for the events
   1422           * to be set. If the value is NULL, then the timeout will be infinite.
   1423           *
   1424           * \return MQX_OK
   1425           * \return LWEVENT_WAIT_TIMEOUT (The time elapsed before an event signalled.)
   1426           * \return MQX_LWEVENT_INVALID (Lightweight event is no longer valid or was never
   1427           * valid.)
   1428           * \return MQX_CANNOT_CALL_FUNCTION_FROM_ISR (Function cannot be called from an ISR.)
   1429           *
   1430           * \warning Blocks until the event combination is set or until the timeout expires.
   1431           * Cannot be called from an ISR.
   1432           *
   1433           * \see _lwevent_wait_ticks
   1434           * \see _usr_lwevent_create
   1435           * \see _usr_lwevent_destroy
   1436           * \see _usr_lwevent_set
   1437           * \see _usr_lwevent_set_auto_clear
   1438           * \see _usr_lwevent_clear
   1439           * \see _usr_lwevent_wait_for
   1440           * \see _usr_lwevent_wait_until
   1441           * \see _usr_lwevent_get_signalled
   1442           * \see LWEVENT_STRUCT
   1443           */
   1444          _mqx_uint _usr_lwevent_wait_ticks
   1445          (
   1446              LWEVENT_STRUCT_PTR  event_ptr,
   1447              _mqx_uint           bit_mask,
   1448              boolean             all,
   1449              _mqx_uint           timeout_in_ticks
   1450          )
   1451          {
   1452              MQX_API_CALL_PARAMS params = {  (uint_32)event_ptr,
   1453                                              (uint_32)bit_mask,
   1454                                              (uint_32)all,
   1455                                              (uint_32)timeout_in_ticks, 0};
   1456          
   1457              return _mqx_api_call(MQX_API_LWEVENT_WAIT_FOR_TICKS, &params);
   1458          }
   1459          
   1460          #endif /* MQX_ENABLE_USER_MODE */
   1461          
   1462          #endif /* MQX_USE_LWEVENTS */
   1463          
   1464          /* EOF */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _lwevent_clear
        16   -> _int_enable
      16   _lwevent_create
        16   -> _lwevent_create_internal
      24   _lwevent_create_internal
        24   -> _int_disable
        24   -> _int_enable
       8   _lwevent_destroy
         8   -> _lwevent_destroy_internal
      24   _lwevent_destroy_internal
        24   -> _int_disable
        24   -> _int_enable
        24   -> _sched_check_scheduler_internal
       0   _lwevent_get_signalled
      32   _lwevent_set
        32   -> _int_enable
        32   -> _sched_check_scheduler_internal
      16   _lwevent_set_auto_clear
        16   -> _int_enable
      32   _lwevent_test
        32   -> _int_enable
        32   -> _queue_test
      24   _lwevent_wait_for
        24   -> _lwevent_wait_internal
      32   _lwevent_wait_internal
        32   -> _int_enable
        32   -> _task_block
        32   -> _time_delay_for
        32   -> _time_delay_until
      40   _lwevent_wait_ticks
        40   -> _lwevent_wait_internal
      24   _lwevent_wait_until
        24   -> _lwevent_wait_internal


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
      94  _lwevent_clear
      18  _lwevent_create
     188  _lwevent_create_internal
      14  _lwevent_destroy
     188  _lwevent_destroy_internal
      10  _lwevent_get_signalled
     292  _lwevent_set
      90  _lwevent_set_auto_clear
     134  _lwevent_test
      28  _lwevent_wait_for
     318  _lwevent_wait_internal
      90  _lwevent_wait_ticks
      28  _lwevent_wait_until

 
 1'536 bytes in section .text
 
 1'536 bytes of CODE memory

Errors: none
Warnings: none
