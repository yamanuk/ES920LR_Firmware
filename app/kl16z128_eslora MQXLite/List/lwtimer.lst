###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         14/May/2020  16:51:00
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\lwtimer.c
#    Command line      =
#        -f C:\Users\81901\AppData\Local\Temp\EW588A.tmp
#        (C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\lwtimer.c
#        --preprocess=s
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -lcN
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -o
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\include\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\config\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\compiler\iar\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Generated_Code\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\PExSupport\Kinetis\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\OSAbstraction\MQXLite\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Common\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\Lists\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\FunctionLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\SecLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Panic\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\SerialManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\MemManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Messaging\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\Phy\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\SMAC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\ADC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\BME\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Flash\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\I2C\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LED\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LLWU\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LPTMR\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\SMC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\MCG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Reset\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List\lwtimer.lst
#    Object file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj\lwtimer.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\MQXLITE\kernel\lwtimer.c
      1          /*HEADER********************************************************************
      2           *
      3           * Copyright (c) 2008 Freescale Semiconductor;
      4           * All Rights Reserved
      5           *
      6           * Copyright (c) 2004-2008 Embedded Access Inc.;
      7           * All Rights Reserved
      8           *
      9           * Copyright (c) 1989-2008 ARC International;
     10           * All Rights Reserved
     11           *
     12           ***************************************************************************
     13           *
     14           * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
     15           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     16           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     17           * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     18           * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     19           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     20           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     21           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     22           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     23           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     24           * THE POSSIBILITY OF SUCH DAMAGE.
     25           *
     26           **************************************************************************
     27           *
     28           * $FileName: lwtimer.c$
     29           * $Version : 3.8.5.1$
     30           * $Date    : Feb-20-2012$
     31           *
     32           * Comments:
     33           *
     34           *   This file contains functions of the LWTimer component.
     35           *
     36           *END************************************************************************/
     37          
     38          #include "mqx_inc.h"
     39          
     40          #if MQX_USE_LWTIMER
     41          #include "lwtimer.h"
     42          #include "lwtimer_prv.h"
     43          
     44          /*!
     45           * \brief Creates the periodic timer queue.
     46           *
     47           * \param[in] period_ptr The location of the data structure defining the timing cycle.
     48           * \param[in] period     The cycle length of this timer in ticks.
     49           * \param[in] wait_ticks The number of ticks to wait before starting this queue.
     50           *
     51           * \warning Disables and enables interrupts.
     52           *
     53           * \return MQX_OK
     54           *
     55           * \see _lwtimer_add_timer_to_queue
     56           * \see _lwtimer_cancel_period
     57           * \see _lwtimer_cancel_timer
     58           * \see _lwtimer_create_periodic_queue
     59           * \see LWTIMER_PERIOD_STRUCT
     60           */
     61          _mqx_uint _lwtimer_create_periodic_queue
     62          (
     63              LWTIMER_PERIOD_STRUCT_PTR period_ptr,
     64              _mqx_uint                 period,
     65              _mqx_uint                 wait_ticks
     66          )
     67          { /* Body */
     68              KERNEL_DATA_STRUCT_PTR kernel_data;
     69          
     70              _GET_KERNEL_DATA(kernel_data);
     71          
     72              _KLOGE4(KLOG_lwtimer_create_periodic_queue, period_ptr, period, wait_ticks);
     73          
     74              period_ptr->PERIOD = period;
     75              period_ptr->EXPIRY = 0;
     76              period_ptr->WAIT   = wait_ticks;
     77              _QUEUE_INIT(&period_ptr->TIMERS,0);
     78              period_ptr->TIMER_PTR = (pointer) &period_ptr->TIMERS;
     79          
     80              _int_disable();
     81              if (kernel_data->LWTIMERS.NEXT == NULL)
     82              {
     83                  /* Initialize the light weight timer queue */
     84                  _QUEUE_INIT(&kernel_data->LWTIMERS, 0);
     85                  kernel_data->LWTIMER_ISR = _lwtimer_isr_internal;
     86              } /* Endif */
     87              period_ptr->VALID = LWTIMER_VALID;
     88              _QUEUE_ENQUEUE(&kernel_data->LWTIMERS, &period_ptr->LINK);
     89              _int_enable();
     90          
     91              _KLOGX2(KLOG_lwtimer_create_periodic_queue, MQX_OK);
     92              return (MQX_OK);
     93          
     94          } /* Endbody */
     95          
     96          /*!
     97           * \brief Adds the lightweight timer to the periodic queue.
     98           *
     99           * The function inserts the timer in the queue in order of increasing offset
    100           * from the queue's start time.
    101           *
    102           * \param[in] period_ptr Pointer to the periodic queue.
    103           * \param[in] timer_ptr  Pointer to the lightweight timer to add to the queue,
    104           * must be smaller than queue.
    105           * \param[in] ticks      Tick offset from the timers period to expire at.
    106           * \param[in] func       Function to call when the timer expires.
    107           * \param[in] parameter  Parameter to pass to the function.
    108           *
    109           * \return MQX_OK
    110           * \return MQX_LWTIMER_INVALID (Period_ptr points to an invalid periodic queue.)
    111           * \return MQX_INVALID_PARAMETER (Ticks is greater than or equal to the
    112           * periodic queue's period.)
    113           *
    114           * \warning Disables and enables interrupts.
    115           *
    116           * \see _lwtimer_cancel_period
    117           * \see _lwtimer_cancel_timer
    118           * \see _lwtimer_create_periodic_queue
    119           * \see LWTIMER_PERIOD_STRUCT
    120           * \see LWTIMER_STRUCT
    121           */
    122           _mqx_uint _lwtimer_add_timer_to_queue
    123          (
    124              LWTIMER_PERIOD_STRUCT_PTR period_ptr,
    125              LWTIMER_STRUCT_PTR        timer_ptr,
    126              _mqx_uint                 ticks,
    127              LWTIMER_ISR_FPTR          func,
    128              pointer                   parameter
    129          )
    130          { /* Body */
    131              KERNEL_DATA_STRUCT_PTR kernel_data;
    132              LWTIMER_STRUCT_PTR     qe_ptr;
    133              _mqx_uint              i;
    134          
    135              _GET_KERNEL_DATA(kernel_data);
    136          
    137              _KLOGE4(KLOG_lwtimer_add_timer_to_queue, period_ptr, timer_ptr, ticks);
    138          
    139          #if MQX_CHECK_ERRORS
    140              if (period_ptr->VALID != LWTIMER_VALID)
    141              {
    142                  _KLOGX2(KLOG_lwtimer_add_timer_to_queue, MQX_LWTIMER_INVALID);
    143                  return (MQX_LWTIMER_INVALID);
    144              } /* Endif */
    145              if (ticks >= period_ptr->PERIOD)
    146              {
    147                  _KLOGX2(KLOG_lwtimer_add_timer_to_queue, MQX_INVALID_PARAMETER);
    148                  return (MQX_INVALID_PARAMETER);
    149              } /* Endif */
    150          #endif
    151          
    152              timer_ptr->TIMER_FUNCTION = func;
    153              timer_ptr->PARAMETER      = parameter;
    154              timer_ptr->PERIOD_PTR     = period_ptr;
    155              timer_ptr->RELATIVE_TICKS = ticks;
    156              _int_disable();
    157              /* Insert into queue in order of increasing offset from start time */
    158              qe_ptr = (pointer) &period_ptr->TIMERS.NEXT;
    159              i = _QUEUE_GET_SIZE(&period_ptr->TIMERS) + 1;
    160              while (--i)
    161              {
    162                  qe_ptr = (pointer) qe_ptr->LINK.NEXT;
    163                  if (qe_ptr->RELATIVE_TICKS >= ticks)
    164                  {
    165                      qe_ptr = (pointer) qe_ptr->LINK.PREV;
    166                      break;
    167                  } /* Endif */
    168              } /* Endwhile */
    169              timer_ptr->VALID = LWTIMER_VALID;
    170              _QUEUE_INSERT(&period_ptr->TIMERS, qe_ptr, &timer_ptr->LINK);
    171              _int_enable();
    172          
    173              _KLOGX2(KLOG_lwtimer_add_timer_to_queue, MQX_OK);
    174              return (MQX_OK);
    175          
    176          } /* Endbody */
    177          
    178          /*!
    179           * \private
    180           *
    181           * \brief This function checks the lwtimer queues, and if a timer is ready,
    182           *  calls an application function.
    183           */
    184          void _lwtimer_isr_internal(void)
    185          { /* Body */
    186              KERNEL_DATA_STRUCT_PTR    kernel_data;
    187              LWTIMER_PERIOD_STRUCT_PTR period_ptr;
    188              LWTIMER_STRUCT_PTR        timer_ptr;
    189          
    190              _GET_KERNEL_DATA(kernel_data);
    191          
    192              period_ptr = (pointer) kernel_data->LWTIMERS.NEXT;
    193              while ((pointer) period_ptr != (pointer) &kernel_data->LWTIMERS)
    194              {
    195                  if (period_ptr->WAIT)
    196                  {
    197                      --period_ptr->WAIT;
    198                  }
    199                  else
    200                  {
    201                      timer_ptr = (pointer) period_ptr->TIMER_PTR->LINK.NEXT;
    202                      for (; timer_ptr != (pointer) &period_ptr->TIMERS; timer_ptr = (LWTIMER_STRUCT_PTR) (pointer) timer_ptr->LINK.NEXT)
    203                      {
    204                          if (timer_ptr->RELATIVE_TICKS > period_ptr->EXPIRY)
    205                          {
    206                              break;
    207                          } /* Endif */
    208                          /* Save the last timer processed */
    209                          period_ptr->TIMER_PTR = timer_ptr;
    210                          (*timer_ptr->TIMER_FUNCTION)(timer_ptr->PARAMETER);
    211                      } /* Endwhile */
    212                      if (++period_ptr->EXPIRY == period_ptr->PERIOD)
    213                      {
    214                          period_ptr->EXPIRY = 0;
    215                          period_ptr->TIMER_PTR = (pointer) &period_ptr->TIMERS;
    216                      } /* Endif */
    217                  } /* Endif */
    218                  period_ptr = (LWTIMER_PERIOD_STRUCT_PTR) (pointer) period_ptr->LINK.NEXT;
    219              } /* Endwhile */
    220          
    221          } /* Endbody */
    222          
    223          /*!
    224           * \brief Cancels an outstanding timer request.
    225           *
    226           * \param[in] timer_ptr Pointer to the lightweight timer to cancel.
    227           *
    228           * \return MQX_OK
    229           * \return MQX_LWTIMER_INVALID (Timer_ptr points to either an invalid timer or
    230           * to a timer with a periodic queue.)
    231           *
    232           * \warning Disables and enables interrupts.
    233           *
    234           * \see _lwtimer_add_timer_to_queue
    235           * \see _lwtimer_cancel_period
    236           * \see _lwtimer_create_periodic_queue
    237           * \see LWTIMER_STRUCT
    238           */
    239          _mqx_uint _lwtimer_cancel_timer
    240          (
    241              LWTIMER_STRUCT_PTR timer_ptr
    242          )
    243          { /* Body */
    244              KERNEL_DATA_STRUCT_PTR    kernel_data;
    245              LWTIMER_PERIOD_STRUCT_PTR period_ptr;
    246          
    247              _GET_KERNEL_DATA(kernel_data);
    248              _KLOGE2(KLOG_lwtimer_cancel_timer, timer_ptr);
    249          
    250          #if MQX_CHECK_VALIDITY
    251              if (timer_ptr->VALID != LWTIMER_VALID)
    252              {
    253                  _KLOGX2(KLOG_lwtimer_cancel_timer, MQX_LWTIMER_INVALID);
    254                  return MQX_LWTIMER_INVALID;
    255              } /* Endif */
    256          #endif
    257          
    258              period_ptr = timer_ptr->PERIOD_PTR;
    259              _int_disable();
    260          #if MQX_CHECK_VALIDITY
    261              if (period_ptr->VALID != LWTIMER_VALID)
    262              {
    263                  _int_enable();
    264                  _KLOGX2(KLOG_lwtimer_cancel_timer, MQX_LWTIMER_INVALID);
    265                  return MQX_LWTIMER_INVALID;
    266              } /* Endif */
    267          #endif
    268              timer_ptr->VALID = 0;
    269              if (timer_ptr == period_ptr->TIMER_PTR)
    270              {
    271                  period_ptr->TIMER_PTR = (pointer) timer_ptr->LINK.PREV;
    272              } /* Endif */
    273              _QUEUE_REMOVE(&period_ptr->TIMERS, timer_ptr);
    274              _int_enable();
    275          
    276              _KLOGX2(KLOG_lwtimer_cancel_timer, MQX_OK);
    277              return (MQX_OK);
    278          
    279          } /* Endbody */
    280          
    281          /*!
    282           * \brief Cancels all the lightweight timers in the periodic queue.
    283           *
    284           * \param[in] period_ptr Pointer to the periodic queue to cancel.
    285           *
    286           * \return MQX_OK
    287           * \return MQX_LWTIMER_INVALID (Period_ptr points to an invalid periodic queue.)
    288           *
    289           * \warning Disables and enables interrupts.
    290           *
    291           * \see _lwtimer_add_timer_to_queue
    292           * \see _lwtimer_cancel_timer
    293           * \see _lwtimer_create_periodic_queue
    294           * \see LWTIMER_PERIOD_STRUCT
    295           */
    296          _mqx_uint _lwtimer_cancel_period
    297          (
    298              LWTIMER_PERIOD_STRUCT_PTR period_ptr
    299          )
    300          { /* Body */
    301              KERNEL_DATA_STRUCT_PTR kernel_data;
    302          
    303              _GET_KERNEL_DATA(kernel_data);
    304              _KLOGE2(KLOG_lwtimer_cancel_period, period_ptr);
    305          
    306          #if MQX_CHECK_VALIDITY
    307              if (period_ptr->VALID != LWTIMER_VALID)
    308              {
    309                  _KLOGX2(KLOG_lwtimer_cancel_period, MQX_LWTIMER_INVALID);
    310                  return MQX_LWTIMER_INVALID;
    311              } /* Endif */
    312          #endif
    313          
    314              _int_disable();
    315              period_ptr->VALID = 0;
    316              _QUEUE_REMOVE(&kernel_data->LWTIMERS, period_ptr);
    317              _int_enable();
    318          
    319              _KLOGX2(KLOG_lwtimer_cancel_period, MQX_OK);
    320              return (MQX_OK);
    321          
    322          } /* Endbody */
    323          
    324          /*!
    325           * \brief Tests all the periodic queues and their lightweight timers for
    326           * validity and consistency.
    327           *
    328           * \param[out] period_error_ptr Pointer to the first periodic queue that has
    329           * an error (NULL if no error is found).
    330           * \param[out] timer_error_ptr  Pointer to the first timer that has an error
    331           * (NULL if no error is found).
    332           *
    333           * \return MQX_OK (No periodic queues have been created or no errors found
    334           * in any periodic queues or timers.)
    335           * \return MQX_LWTIMER_INVALID (Period_ptr points to an invalid periodic queue.)
    336           * \return Error from _queue_test() (A periodic queue or its queue was in error.)
    337           *
    338           * \warning Disables and enables interrupts.
    339           *
    340           * \see _lwtimer_add_timer_to_queue
    341           * \see _lwtimer_cancel_period
    342           * \see _lwtimer_cancel_timer
    343           * \see _lwtimer_create_periodic_queue
    344           */
    345           _mqx_uint _lwtimer_test
    346          (
    347              pointer _PTR_ period_error_ptr,
    348              pointer _PTR_ timer_error_ptr
    349          )
    350          { /* Body */
    351              KERNEL_DATA_STRUCT_PTR    kernel_data;
    352              LWTIMER_STRUCT_PTR        timer_ptr;
    353              LWTIMER_PERIOD_STRUCT_PTR period_ptr;
    354              _mqx_uint                 result;
    355          
    356              _GET_KERNEL_DATA(kernel_data);
    357          
    358              _KLOGE3(KLOG_lwtimer_test, period_error_ptr, timer_error_ptr);
    359          
    360              *period_error_ptr = NULL;
    361              *timer_error_ptr = NULL;
    362          
    363              /*
    364               * It is not considered an error if the lwtimer component has not been
    365               * created yet
    366               */
    367              if (kernel_data->LWTIMERS.NEXT == NULL)
    368              {
    369                  return (MQX_OK);
    370              } /* Endif */
    371          
    372              result = _queue_test(&kernel_data->LWTIMERS, period_error_ptr);
    373              if (result != MQX_OK)
    374              {
    375                  _KLOGX3(KLOG_lwtimer_test, result, *period_error_ptr);
    376                  return (result);
    377              } /* Endif */
    378          
    379              _int_disable();
    380              period_ptr = (pointer) kernel_data->LWTIMERS.NEXT;
    381              while ((pointer) period_ptr != (pointer) &kernel_data->LWTIMERS)
    382              {
    383                  if (period_ptr->VALID != LWTIMER_VALID)
    384                  {
    385                      _int_enable();
    386                      *period_error_ptr = period_ptr;
    387                      _KLOGX3(KLOG_lwtimer_test, MQX_LWTIMER_INVALID, period_ptr);
    388                      return (MQX_LWTIMER_INVALID);
    389                  } /* Endif */
    390                  result = _queue_test(&period_ptr->TIMERS, timer_error_ptr);
    391                  if (result != MQX_OK)
    392                  {
    393                      _int_enable();
    394                      *period_error_ptr = period_ptr;
    395                      _KLOGX4(KLOG_lwtimer_test, result, *period_error_ptr, *timer_error_ptr);
    396                      return (result);
    397                  } /* Endif */
    398                  timer_ptr = (pointer) period_ptr->TIMERS.NEXT;
    399                  while (timer_ptr != (pointer) &period_ptr->TIMERS)
    400                  {
    401                      if (timer_ptr->VALID != LWTIMER_VALID)
    402                      {
    403                          *period_error_ptr = period_ptr;
    404                          *timer_error_ptr = timer_ptr;
    405                          _KLOGX4(KLOG_lwtimer_test, MQX_LWTIMER_INVALID, period_ptr,
    406                                          timer_ptr);
    407                          return (MQX_LWTIMER_INVALID);
    408                      } /* Endif */
    409                      timer_ptr = (pointer) timer_ptr->LINK.NEXT;
    410                  } /* Endwhile */
    411                  period_ptr = (pointer) period_ptr->LINK.NEXT;
    412              } /* Endwhile */
    413          
    414              _int_enable();
    415              _KLOGX2(KLOG_lwtimer_test, MQX_OK);
    416              return (MQX_OK);
    417          
    418          } /* Endbody */
    419          
    420          #endif /* MQX_USE_LWTIMER */
    421          
    422          /* EOF */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   _lwtimer_add_timer_to_queue
        40   -> _int_disable
        40   -> _int_enable
      16   _lwtimer_cancel_period
        16   -> _int_disable
        16   -> _int_enable
      24   _lwtimer_cancel_timer
        24   -> _int_disable
        24   -> _int_enable
      24   _lwtimer_create_periodic_queue
        24   -> _int_disable
        24   -> _int_enable
      16   _lwtimer_isr_internal
        16   -- Indirect call
      32   _lwtimer_test
        32   -> _int_disable
        32   -> _int_enable
        32   -> _queue_test


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
     126  _lwtimer_add_timer_to_queue
      58  _lwtimer_cancel_period
      76  _lwtimer_cancel_timer
     158  _lwtimer_create_periodic_queue
     100  _lwtimer_isr_internal
     178  _lwtimer_test

 
 712 bytes in section .text
 
 712 bytes of CODE memory

Errors: none
Warnings: 2
