###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         14/May/2020  16:50:58
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\Utils\FunctionLib\FunctionLib.c
#    Command line      =
#        -f C:\Users\81901\AppData\Local\Temp\EW523A.tmp
#        (C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\Utils\FunctionLib\FunctionLib.c
#        --preprocess=s
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -lcN
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List" -o
#        "C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\Sources\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\include\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\config\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\MQXLITE\psp\cortex_m\compiler\iar\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Generated_Code\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\PExSupport\Kinetis\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\OSAbstraction\MQXLite\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Common\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\Lists\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\FunctionLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Utils\SecLib\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\FSCI\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Panic\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\SerialManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\MemManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\TimersManager\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\Messaging\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\framework\RNG\Source\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\Phy\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\ieee_802_15_4\SMAC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\ADC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\BME\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Flash\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\I2C\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LED\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LLWU\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\LPTMR\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\SMC\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\MCG\Interface\
#        -I
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\..\drv\Portable\Reset\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\List\FunctionLib.lst
#    Object file       =
#        C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\app\kl16z128_eslora
#        MQXLite\Obj\FunctionLib.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\81901\Desktop\job\es920lr\SDK\src\Application\KL16_SMAC_MQXLite\framework\Utils\FunctionLib\FunctionLib.c
      1          /*!
      2          * Copyright (c) 2014, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file FunctionLib.c
      6          * This module contains various common functions like copy and compare routines.
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          #include "FunctionLib.h"
     35          
     36          #if gUseToolchainMemFunc_d
     37          #include <String.h>
     38          #endif
     39          
     40          /************************************************************************************
     41          *************************************************************************************
     42          * Private macros
     43          *************************************************************************************
     44          ************************************************************************************/
     45          
     46          /************************************************************************************
     47          *************************************************************************************
     48          * Private prototypes
     49          *************************************************************************************
     50          ************************************************************************************/
     51          
     52          /************************************************************************************
     53          *************************************************************************************
     54          * Private type definitions
     55          *************************************************************************************
     56          ************************************************************************************/
     57          
     58          /************************************************************************************
     59          *************************************************************************************
     60          * Public memory declarations
     61          *************************************************************************************
     62          ************************************************************************************/
     63          
     64          /************************************************************************************
     65          *************************************************************************************
     66          * Private memory declarations
     67          *************************************************************************************
     68          ************************************************************************************/
     69          
     70          /************************************************************************************
     71          *************************************************************************************
     72          * Public functions
     73          *************************************************************************************
     74          ************************************************************************************/
     75          
     76          /*! *********************************************************************************
     77          * \brief  This function copies up to 256 bytes from one buffer to another.
     78          *         The buffers should not overlap.
     79          *
     80          * \param[in, out]  pDst Pointer to the destination buffer.
     81          *
     82          * \param[in]  pSrc Pointer to the source buffer.
     83          *
     84          * \param[in]  cBytes Number of bytes to copy.
     85          *
     86          * \post  The source and destination buffers must not overlap.
     87          *
     88          * \remarks
     89          *
     90          ********************************************************************************** */
     91          void FLib_MemCpy (void* pDst,
     92                            void* pSrc,
     93                            uint32_t cBytes)
     94          {
     95          #if gUseToolchainMemFunc_d
     96              memcpy(pDst, pSrc, cBytes);
     97          #else
     98              while (cBytes)
     99              {
    100                  *((uint8_t*)pDst) = *((uint8_t*)pSrc);
    101                  pDst = ((uint8_t*)pDst)+1;
    102                  pSrc = ((uint8_t*)pSrc)+1;
    103                  cBytes--;
    104              }
    105          #endif
    106          }
    107          
    108          /*! *********************************************************************************
    109          * \brief  This function copies the specified number of bytes from the
    110          *         source address to the destination address.  No attempt is made
    111          *         to handle overlapping copies to prevent loss of data.
    112          *         The copying is optimized to avoid alignment problems, and attempts
    113          *         to copy 32bit numbers optimally.
    114          *
    115          * \param[in]  from_ptr Pointer to the source buffer.
    116          *
    117          * \param[in, out]  to_ptr Pointer to the destination buffer.
    118          *
    119          * \param[in]  number_of_bytes  Number of bytes to copy (32 bit value).
    120          *
    121          * \post
    122          *
    123          * \remarks
    124          *
    125          ********************************************************************************** */
    126          
    127          void FLib_MemCpyAligned32bit (void* from_ptr,
    128                                        void* to_ptr,
    129                                        register uint32_t number_of_bytes)
    130          {
    131              uint8_t*    from8_ptr = (uint8_t*)from_ptr;
    132              uint8_t*    to8_ptr = (uint8_t*)to_ptr;
    133              uint16_t*   from16_ptr = (uint16_t*)from_ptr;
    134              uint16_t*   to16_ptr = (uint16_t*)to_ptr;
    135              register    uint32_t* from32_ptr = (uint32_t*)from_ptr;
    136              register    uint32_t* to32_ptr = (uint32_t*)to_ptr;
    137          
    138              register    uint32_t loops;
    139          
    140              if (number_of_bytes > 3)
    141              {
    142                  /* Try to align source on word */
    143                  if ((uint32_t)from_ptr & 1)
    144                  {
    145                      from8_ptr = (uint8_t*)from_ptr;
    146                      to8_ptr = (uint8_t*)to_ptr;
    147          
    148                      *to8_ptr++ = *from8_ptr++;
    149          
    150                      from_ptr = from8_ptr;
    151                      to_ptr = to8_ptr;
    152                      --number_of_bytes;
    153                  }
    154          
    155                  /* Try to align source on longword */
    156                  if ((uint32_t)from_ptr & 2)
    157                  {
    158                      from16_ptr = (uint16_t*)from_ptr;
    159                      to16_ptr = (uint16_t*)to_ptr;
    160          
    161                      *to16_ptr++ = *from16_ptr++;
    162          
    163                      from_ptr = from16_ptr;
    164                      to_ptr = to16_ptr;
    165                      number_of_bytes -= 2;
    166                  }
    167          
    168                  from32_ptr = (uint32_t*)from_ptr;
    169                  to32_ptr = (uint32_t*)to_ptr;
    170          
    171                  for (loops = number_of_bytes >> 2; loops != 0; loops--)
    172                  {
    173                      *to32_ptr++ = *from32_ptr++;
    174                  }
    175          
    176                  from_ptr = from32_ptr;
    177                  to_ptr = to32_ptr;
    178              }
    179          
    180              /* Copy all remaining bytes */
    181              if (number_of_bytes & 2)
    182              {
    183                  from16_ptr = (uint16_t*)from_ptr;
    184                  to16_ptr = (uint16_t*)to_ptr;
    185          
    186                  *to16_ptr++ = *from16_ptr++;
    187          
    188                  from_ptr = from16_ptr;
    189                  to_ptr = to16_ptr;
    190              }
    191          
    192              if (number_of_bytes & 1)
    193              {
    194                  *(uint8_t*)to_ptr = *(uint8_t*)from_ptr;
    195              }
    196          }
    197          
    198          
    199          /*! *********************************************************************************
    200          * \brief  Copy bytes from one buffer to another. The buffers should not overlap.
    201          *         The function can copy in either direction. If 'dir' is TRUE, then the function
    202          *         works like FLib_MemCpy(). If FALSE, the function swaps the buffer pointers
    203          *         before copying.
    204          *
    205          * \param[in, out]  pBuf1 Pointer to the destination/source buffer.
    206          *
    207          * \param[in, out]  pBuf2 Pointer to the source/destination buffer.
    208          *
    209          * \param[in]  dir Direction to copy: pBuf2->pBuf1 if TRUE, pBuf1->pBuf2 if FALSE
    210          *
    211          * \param[in]  n Number of bytes to copy.
    212          *
    213          * \post  The source and destination buffers must not overlap.
    214          *
    215          * \remarks
    216          *
    217          ********************************************************************************** */
    218          
    219          void FLib_MemCpyDir (void* pBuf1,
    220                               void* pBuf2,
    221                               bool_t dir,
    222                               uint32_t n)
    223          {
    224              if (dir)
    225              {
    226                  FLib_MemCpy (pBuf1, pBuf2, n);
    227              }
    228              else
    229              {
    230                  FLib_MemCpy (pBuf2, pBuf1, n);
    231              }
    232          }
    233          
    234          
    235          /*! *********************************************************************************
    236          * \brief  The byte at index i from the source buffer is copied to index ((n-1) - i)
    237          *         in the destination buffer (and vice versa).
    238          *
    239          * \param[in, out]  pDst Pointer to the destination buffer.
    240          *
    241          * \param[in]  pSrc Pointer to the source buffer.
    242          *
    243          * \param[in]  cBytes Number of bytes to copy.
    244          *
    245          * \post
    246          *
    247          * \remarks
    248          *
    249          ********************************************************************************** */
    250          
    251          void FLib_MemCpyReverseOrder (void* pDst,
    252                                        void* pSrc,
    253                                        uint32_t cBytes)
    254          {
    255              if(cBytes == 0)
    256              {
    257                  return;
    258              }
    259              pDst = (uint8_t*)pDst + (uint32_t)(cBytes-1);
    260              while (cBytes)
    261              {
    262                  *((uint8_t*)pDst) = *((uint8_t*)pSrc);
    263                  pDst = (uint8_t*)pDst-1;
    264                  pSrc = (uint8_t*)pSrc+1;
    265                  cBytes--;
    266              }
    267          }
    268          
    269          
    270          /*! *********************************************************************************
    271          * \brief  This function compares two buffers.
    272          *
    273          * \param[in]  pData1  First buffer to compare.
    274          *
    275          * \param[in]  pData2  Second buffer to compare.
    276          *
    277          * \param[in]  cBytes Number of bytes to compare.
    278          *
    279          * \return  This function return TRUE if the buffers are equal and FALSE otherwise.
    280          *
    281          * \post
    282          *
    283          * \remarks
    284          *
    285          ********************************************************************************** */
    286          
    287          bool_t FLib_MemCmp (void* pData1,    // IN: First memory block to compare
    288                              void* pData2,    // IN: Second memory block to compare
    289                              uint32_t cBytes  // IN: Number of bytes to compare.
    290                             )
    291          {
    292          #if gUseToolchainMemFunc_d
    293              if( memcmp(pData1, pData2, cBytes) )
    294                  return FALSE;
    295          #else
    296              while (cBytes)
    297              {
    298                  if ( *((uint8_t *)pData1) != *((uint8_t *)pData2))
    299                  {
    300                      return FALSE;
    301                  }
    302          
    303                  pData2 = (uint8_t* )pData2+1;
    304                  pData1 = (uint8_t* )pData1+1;
    305                  cBytes--;
    306              }
    307          #endif
    308              return TRUE;
    309          }
    310          
    311          
    312          /*! *********************************************************************************
    313          * \brief  This function resets all bytes in a specified buffer to a set value.
    314          *
    315          * \param[in,out]  pDst  Address of the buffer to set.
    316          *
    317          * \param[in]  value  Set value.
    318          *
    319          * \param[in]  cBytes Number of bytes to set in the buffer (maximum 255 bytes).
    320          *
    321          * \post
    322          *
    323          * \remarks
    324          *
    325          ********************************************************************************** */
    326          void FLib_MemSet (void* pDst,
    327                            uint8_t value,
    328                            uint32_t cBytes)
    329          {
    330          #if gUseToolchainMemFunc_d
    331              memset(pDst, value, cBytes);
    332          #else
    333              while (cBytes)
    334              {
    335                  ((uint8_t* )pDst)[--cBytes] = value;
    336              }
    337          #endif
    338          }
    339          
    340          
    341          /*! *********************************************************************************
    342          * \brief  This function copies a buffer,
    343          *         possibly into the same overlapping memory as it is taken from
    344          *
    345          * \param[in, out]  pDst Pointer to the destination buffer.
    346          *
    347          * \param[in]  pSrc Pointer to the source buffer.
    348          *
    349          * \param[in]  cBytes Number of bytes to copy.
    350          *
    351          * \post
    352          *
    353          * \remarks
    354          *
    355          ********************************************************************************** */
    356          void FLib_MemInPlaceCpy (void* pDst,
    357                                   void* pSrc,
    358                                   uint32_t cBytes)
    359          {
    360              if (pDst != pSrc)
    361              {
    362                  /* Do nothing if copying to same position */
    363                  if (pDst < pSrc)
    364                  {
    365                      /* If dst is before src in memory copy forward */
    366          #if gUseToolchainMemFunc_d
    367                      memcpy(pDst, pSrc, cBytes);
    368          #else
    369                      while (cBytes)
    370                      {
    371                          *((uint8_t*)pDst) = *((uint8_t*)pSrc);
    372                          pDst = ((uint8_t*)pDst)+1;
    373                          pSrc = ((uint8_t*)pSrc)+1;
    374                          cBytes--;
    375                      }
    376          #endif
    377                  }
    378                  else
    379                  {
    380                      /* If dst is after src in memory copy backward */
    381                      while(cBytes)
    382                      {
    383                          cBytes--;
    384                          ((uint8_t* )pDst)[cBytes] = ((uint8_t* )pSrc)[cBytes];
    385                      }
    386                  }
    387              }
    388          }
    389          
    390          /*! *********************************************************************************
    391          * \brief This function copies a 16bit value to an unaligned a memory block.
    392          *
    393          * \param[in, out]  pDst Pointer to the destination memory block.
    394          *
    395          * \param[in]  val16 The value to be copied.
    396          *
    397          ********************************************************************************** */
    398          
    399          void FLib_MemCopy16Unaligned (void* pDst,
    400                                        uint16_t val16)
    401          {
    402              uint8_t* pData = (uint8_t*)pDst;
    403          
    404              *pData++ = (uint8_t)(val16);
    405              *pData =   (uint8_t)(val16 >> 8);
    406          
    407              return;
    408          }
    409          
    410          
    411          /*! *********************************************************************************
    412          * \brief This function copies a 32bit value to an unaligned a memory block.
    413          *
    414          * \param[in, out]  pDst Pointer to the destination memory block.
    415          *
    416          * \param[in]  val32 The value to be copied.
    417          *
    418          ********************************************************************************** */
    419          
    420          void FLib_MemCopy32Unaligned (void* pDst,
    421                                        uint32_t val32)
    422          {
    423              uint8_t* pData = (uint8_t*)pDst;
    424          
    425              *pData++ = (uint8_t)(val32);
    426              *pData++ = (uint8_t)(val32 >> 8);
    427              *pData++ = (uint8_t)(val32 >> 16);
    428              *pData++ = (uint8_t)(val32 >> 24);
    429          
    430              return;
    431          }
    432          
    433          
    434          /*! *********************************************************************************
    435          * \brief This function copies a 64bit value to an unaligned a memory block.
    436          *
    437          * \param[in, out]  pDst Pointer to the destination memory block.
    438          *
    439          * \param[in]  val64 The value to be copied.
    440          *
    441          ********************************************************************************** */
    442          
    443          void FLib_MemCopy64Unaligned (void* pDst,
    444                                        uint64_t val64)
    445          {
    446              uint8_t* pData = (uint8_t*)pDst;
    447          
    448              *pData++ = (uint8_t)(val64);
    449              *pData++ = (uint8_t)(val64 >> 8);
    450              *pData++ = (uint8_t)(val64 >> 16);
    451              *pData++ = (uint8_t)(val64 >> 24);
    452              *pData++ = (uint8_t)(val64 >> 32);
    453              *pData++ = (uint8_t)(val64 >> 40);
    454              *pData++ = (uint8_t)(val64 >> 48);
    455              *pData = (uint8_t)(val64 >> 56);
    456          
    457              return;
    458          }
    459          
    460          
    461          /*! *********************************************************************************
    462          * \brief  This function adds an offset to a pointer.
    463          *
    464          * \param[in,out]  pPtr  Pointer to the pointer to add the offset to
    465          *
    466          * \param[in]  offset  Offset to add to the specified pointer.
    467          *
    468          * \post
    469          *
    470          * \remarks
    471          *
    472          ********************************************************************************** */
    473          
    474          void FLib_AddOffsetToPointer (void** pPtr,
    475                                        uint32_t offset)
    476          {
    477              (*pPtr) = ((uint8_t* )*pPtr) + offset;
    478          }
    479          
    480          
    481          /************************************************************************************
    482          *************************************************************************************
    483          * Private functions
    484          *************************************************************************************
    485          ************************************************************************************/
    486          
    487          /************************************************************************************
    488          *************************************************************************************
    489          * Module debug stuff
    490          *************************************************************************************
    491          ************************************************************************************/
    492          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLib_AddOffsetToPointer
       8   FLib_MemCmp
       0   FLib_MemCopy16Unaligned
       0   FLib_MemCopy32Unaligned
      16   FLib_MemCopy64Unaligned
       4   FLib_MemCpy
      40   FLib_MemCpyAligned32bit
      24   FLib_MemCpyDir
        24   -> FLib_MemCpy
       4   FLib_MemCpyReverseOrder
       4   FLib_MemInPlaceCpy
       4   FLib_MemSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  FLib_AddOffsetToPointer
      32  FLib_MemCmp
      18  FLib_MemCopy16Unaligned
      30  FLib_MemCopy32Unaligned
      78  FLib_MemCopy64Unaligned
      20  FLib_MemCpy
     160  FLib_MemCpyAligned32bit
      42  FLib_MemCpyDir
      28  FLib_MemCpyReverseOrder
      40  FLib_MemInPlaceCpy
      14  FLib_MemSet

 
 470 bytes in section .text
 
 470 bytes of CODE memory

Errors: none
Warnings: none
